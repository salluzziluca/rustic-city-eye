<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","doc","mod.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","drones","drone.rs"],"content":"use std::{\n    sync::{mpsc, Arc, Mutex},\n    thread::{self, sleep},\n    time::Duration,\n};\n\nuse super::{drone_config::DroneConfig, drone_error::DroneError, drone_state::DroneState};\nuse crate::{\n    monitoring::incident::Incident,\n    mqtt::{\n        client::Client,\n        client_message::{self, ClientMessage},\n        messages_config,\n        publish::publish_config::PublishConfig,\n        subscribe_config::SubscribeConfig,\n        subscribe_properties::SubscribeProperties,\n    },\n    utils::{incident_payload::IncidentPayload, location::Location, payload_types::PayloadTypes},\n};\nuse chrono::{DateTime, Utc};\nuse std::f64::consts::PI;\nconst LOW_BATERRY_LEVEL: i64 = 20;\nconst DRONE_SPEED: f64 = 0.001;\nconst DRONE_MOV_SLEEP_TIME: u64 = 1;\nconst DRONE_ATTENDING_INCIDENT_SLEEP_TIME: u64 = 3;\nconst TOLERANCE_FACTOR: f64 = 0.6;\nconst MILISECONDS_PER_SECOND: f64 = 1000.0;\nconst TWO_PI: f64 = 2.0 * PI;\nconst COORDINATE_SCALE_FACTOR: f64 = 100.0;\nconst FULL_BATTERY: i64 = 100;\nconst ANGLE_SCALING_FACTOR: f64 = 0.6; // Adjust this value to make steps smaller or larger\n\n#[derive(Debug, Clone)]\npub struct Drone {\n    // ID unico para cada Drone.\n    pub id: u32,\n\n    ///posicion actual del Drone.\n    pub location: Location,\n\n    ///posicion del centro de drones al que pertenece.\n    pub center_location: Location,\n\n    /// La configuracion del Drone contiene el nivel de bateria del mismo y\n    /// el radio de operacion.\n    target_location: Location,\n\n    /// Contiene configuraciones como la tasa de movimiento, la tasa de carga y descarga de bateria,\n    /// y el radio de operacion.\n    drone_config: DroneConfig,\n\n    ///  El Drone puede tener distintos estados:\n    /// - Waiting: esta circulando en su radio de operacion, pero no esta atendiendo ningun incidente.\n    /// - AttendingIncident: un nuevo incidente fue cargado por la app de monitoreo, y el Drone fue asignado\n    ///                         a resolverlo.\n    /// - LowBatteryLevel: el Drone se quedo sin bateria, por lo que va a su central a cargarse, y no va a volver a\n    ///                    funcionar hasta que tenga el nivel de bateria completo(al terminar de cargarse, vuelve a\n    ///                    tener el estado Waiting).\n    /// - ChargingBattery: se va a utilizar cuando el Drone este cargando su bateria en su central.\n    ///                    La idea es que no patrulle ni se ponga a resolver incidentes en este estado.\n    pub drone_state: DroneState,\n\n    /// Client con el que va a interactuar en la red con las demas aplicaciones.\n    pub drone_client: Client,\n\n    /// Nivel de bateria actual del Drone.\n    pub battery_level: i64,\n\n    /// A traves de este sender, se envia la configuracion de los packets que el Drone\n    /// quiera enviar a la red.\n    send_to_client_channel: mpsc::Sender\u003cBox\u003cdyn messages_config::MessagesConfig + Send\u003e\u003e,\n\n    /// A traves de este receiver, el Drone recibe los mensajes provenientes de su Client.\n    recieve_from_client: Arc\u003cMutex\u003cmpsc::Receiver\u003cClientMessage\u003e\u003e\u003e,\n}\n\nimpl Drone {\n    /// levanto su configuracion, y me guardo su posicion inicial.\n    pub fn new(\n        id: u32,\n        location: Location,\n        center_location: Location,\n        config_file_path: \u0026str,\n        address: String,\n    ) -\u003e Result\u003cDrone, DroneError\u003e {\n        let drone_config = DroneConfig::new(config_file_path)?;\n\n        let mut connect_config =\n            match client_message::Connect::read_connect_config(\"src/drones/connect_config.json\") {\n                Ok(config) =\u003e config,\n                Err(e) =\u003e return Err(DroneError::ProtocolError(e.to_string())),\n            };\n        connect_config.client_id = id.to_string();\n        let (tx, rx) = mpsc::channel();\n        let (tx2, rx2) = mpsc::channel();\n        let subscribe_config = SubscribeConfig::new(\n            \"incidente\".to_string(),\n            1,\n            SubscribeProperties::new(1, vec![]),\n            id.to_string(),\n        );\n\n        let drone_client = match Client::new(rx, address, connect_config, tx2) {\n            Ok(client) =\u003e client,\n            Err(e) =\u003e return Err(DroneError::ProtocolError(e.to_string())),\n        };\n\n        let _ = tx.send(Box::new(subscribe_config));\n        let target_location = location;\n        Ok(Drone {\n            id,\n            location,\n            center_location,\n            target_location,\n            drone_config,\n            drone_state: DroneState::Waiting,\n            drone_client,\n            battery_level: 100,\n            send_to_client_channel: tx,\n            recieve_from_client: Arc::new(Mutex::new(rx2)),\n        })\n    }\n\n    /// Esta funcion ejecuta el Drone, creando tres threads:\n    /// - Uno para manejar la bateria del Drone: Mientras tenga un estado de Waiting, se considera\n    ///   que tiene un nivel de bateria optimo para operar: cuando este en este estado, su bateria se ira\n    ///   descargando a medida que pasa el tiempo(la tasa de descarga de bateria viene en el archivo de\n    ///   configuracion del Drone). Cuando se llega a un estado de LowBatteryLevel, se notifica al thread de movimiento\n    ///   la necesidad de ir a cargarse a la central de carga. Una vez en ella, el Drone pasa a cargarse con un estado de\n    ///   ChargingBattery(la tasa de carga de bateria viene en el archivo de configuracion del Drone).\n    ///\n    /// - Un segundo thread para mover al Drone: si esta en estado Waiting, va a patrullar\n    ///   sobre su radio de operacion; si esta en estado de LowBatteryLevel, se mueve\n    ///   hacia su central de carga; y si esta en estado de AttendingIncident, se mueve hacia la\n    ///   localizacion del incidente a resolver.\n    ///\n    /// - Un tercer thread para manejar la recepcion de mensajes de parte de su Client:\n    ///   recibe los Publish packets que vengan de los topics al que este suscrito.\n    pub fn run_drone(\u0026mut self) -\u003e Result\u003c(), DroneError\u003e {\n        match self.drone_client.client_run() {\n            Ok(client) =\u003e client,\n            Err(e) =\u003e {\n                print!(\"Error running client: {:?}\", e);\n                return Err(DroneError::ProtocolError(e.to_string()));\n            }\n        };\n\n        println!(\"Drone {} is running\", self.id);\n        let drone_ref = Arc::new(Mutex::new(self.clone()));\n        let self_clone_one = Arc::clone(\u0026drone_ref);\n        let self_clone_two = Arc::clone(\u0026drone_ref);\n        let self_clone_three = Arc::clone(\u0026drone_ref);\n\n        thread::spawn(move || {\n            let mut last_discharge_time = Utc::now();\n\n            loop {\n                let self_clone = Arc::clone(\u0026self_clone_one);\n                let mut lock = match self_clone.lock() {\n                    Ok(locked) =\u003e locked,\n                    Err(e) =\u003e {\n                        println!(\"Error locking drone: {:?}\", e);\n                        return;\n                    }\n                };\n\n                match lock.drone_state.clone() {\n                    DroneState::Waiting =\u003e {\n                        let updated_last_discharge_time =\n                            lock.battery_discharge(last_discharge_time);\n                        last_discharge_time = updated_last_discharge_time;\n                    }\n\n                    DroneState::ChargingBattery =\u003e match lock.charge_battery() {\n                        Ok(_) =\u003e (),\n                        Err(e) =\u003e {\n                            println!(\"Error charging battery: {:?}\", e);\n                            return;\n                        }\n                    },\n                    _ =\u003e (),\n                }\n            }\n        });\n\n        thread::spawn(move || loop {\n            sleep(Duration::from_millis(500));\n\n            let self_clone = Arc::clone(\u0026self_clone_two);\n            let mut lock = match self_clone.lock() {\n                Ok(locked) =\u003e locked,\n                Err(e) =\u003e {\n                    println!(\"Error locking drone: {:?}\", e);\n                    return;\n                }\n            };\n\n            match lock.drone_state.clone() {\n                DroneState::Waiting =\u003e {\n                    match lock.patrolling_in_operating_radius() {\n                        Ok(_) =\u003e (),\n                        Err(e) =\u003e {\n                            println!(\"Error while patrolling: {:?}\", e);\n                            return;\n                        }\n                    };\n                }\n                DroneState::AttendingIncident(location) =\u003e {\n                    println!(\"Esto yendo a solucionar el incidente\");\n                    match lock.drone_movement(location) {\n                        Ok(_) =\u003e {\n                            sleep(Duration::from_secs(DRONE_ATTENDING_INCIDENT_SLEEP_TIME));\n                            lock.drone_state = DroneState::Waiting;\n                            lock.patrolling_in_operating_radius().unwrap();\n                            lock.publish_attending_accident(location);\n                        }\n                        Err(e) =\u003e {\n                            println!(\"Error while moving to incident: {:?}\", e);\n                            return;\n                        }\n                    };\n                }\n                DroneState::LowBatteryLevel =\u003e {\n                    lock.redirect_to_operation_center();\n                }\n                _ =\u003e (),\n            };\n        });\n        let recieve_from_client_clone = Arc::clone(\u0026self.recieve_from_client);\n        thread::spawn(move || loop {\n            let message = {\n                let lock = recieve_from_client_clone.lock().unwrap();\n                lock.recv().unwrap()\n            };\n\n            let mut self_cloned = self_clone_three.lock().unwrap();\n            if let client_message::ClientMessage::Publish {\n                topic_name,\n                payload: PayloadTypes::IncidentLocation(payload),\n                ..\n            } = message\n            {\n                if topic_name != \"incidente\" {\n                    continue;\n                }\n                let location = payload.get_incident().get_location();\n                println!(\"yo, droncito {} recibi el pub de incidente\", self_cloned.id);\n                self_cloned.drone_state = DroneState::AttendingIncident(location);\n            }\n        });\n\n        Ok(())\n    }\n\n    pub fn get_state(self) -\u003e DroneState {\n        self.drone_state\n    }\n\n    pub fn get_id(\u0026self) -\u003e u32 {\n        self.id\n    }\n\n    /// Carga un 1% la bateria si el elapsed time (diferencial de tiempo inicial y tiempo final)\n    /// es mayor o igual al ratio de carga\n    ///\n    /// Si la bateria llega a 100%, el estado del dron pasa a Waiting\n    fn update_battery_charge(\n        \u0026mut self,\n        start_time: DateTime\u003cUtc\u003e,\n        current_time: DateTime\u003cUtc\u003e,\n    ) -\u003e (DateTime\u003cUtc\u003e, bool) {\n        let elapsed_time = current_time\n            .signed_duration_since(start_time)\n            .num_milliseconds();\n        let charge_rate = self.drone_config.get_battery_charge_rate_milisecs();\n\n        if elapsed_time \u003e= charge_rate {\n            self.battery_level += 1;\n            if self.battery_level \u003e= FULL_BATTERY - 1 {\n                self.battery_level = FULL_BATTERY;\n                self.drone_state = DroneState::Waiting;\n            }\n            (current_time, true)\n        } else {\n            (start_time, false)\n        }\n    }\n\n    /// Descarga un 1% la bateria si el elapsed time (diferencial de tiempo inicial y tiempo final)\n    /// es mayor o igual al ratio de descarga\n    /// Si la bateria llega a 20%, el estado del dron pasa a LowBatteryLevel\n    fn update_battery_discharge(\n        \u0026mut self,\n        last_discharge_time: DateTime\u003cUtc\u003e,\n        current_time: DateTime\u003cUtc\u003e,\n    ) -\u003e (DateTime\u003cUtc\u003e, bool) {\n        let elapsed_time = current_time\n            .signed_duration_since(last_discharge_time)\n            .num_milliseconds();\n        let discharge_rate = self.drone_config.get_battery_discharge_rate();\n\n        if elapsed_time \u003e= discharge_rate {\n            self.battery_level -= 1;\n            if self.battery_level == LOW_BATERRY_LEVEL {\n                self.drone_state = DroneState::LowBatteryLevel;\n            }\n            (current_time, true)\n        } else {\n            (last_discharge_time, false)\n        }\n    }\n\n    /// Se descarga el nivel de bateria del\n    /// Drone segun indique la tasa de descarga de bateria del mismo(definida\n    /// en la config del Drone).\n    ///\n    /// Cada vez que se cumpla \"un ciclo\" de la tasa de descarga, se reduce la bateria del\n    /// Drone en un 1%.\n    pub fn battery_discharge(\u0026mut self, last_discharge_time: DateTime\u003cUtc\u003e) -\u003e DateTime\u003cUtc\u003e {\n        let current_time = Utc::now();\n        let (updated_last_discharge_time, _updated) =\n            self.update_battery_discharge(last_discharge_time, current_time);\n\n        updated_last_discharge_time\n    }\n\n    /// Se carga el nivel de bateria del\n    /// Drone segun indique la tasa de carga de bateria del mismo(definida\n    /// en la config del Drone).\n    ///\n    /// Cada vez que se cumpla \"un ciclo\" de la tasa de carga, se aumenta la bateria del\n    /// Drone en un 1%.\n    pub fn battery_charge(\u0026mut self, last_charge_time: DateTime\u003cUtc\u003e) -\u003e DateTime\u003cUtc\u003e {\n        let current_time = Utc::now();\n        let (updated_last_charge_time, _updated) =\n            self.update_battery_charge(last_charge_time, current_time);\n\n        updated_last_charge_time\n    }\n\n    /// Carga al Drone de acuerdo a la tasa de carga que venga definida en la configuracion.\n    ///\n    /// Al llegar al 100%, devuelve un DroneState del tipo Waiting.\n    pub fn charge_battery(\u0026mut self) -\u003e Result\u003cDroneState, DroneError\u003e {\n        let mut start_time = Utc::now();\n\n        loop {\n            let current_time = Utc::now();\n            let (updated_start_time, updated) =\n                self.update_battery_charge(start_time, current_time);\n\n            if updated \u0026\u0026 self.battery_level \u003e FULL_BATTERY - 1 {\n                return Ok(self.drone_state.clone());\n            }\n            start_time = updated_start_time;\n        }\n    }\n\n    /// Cuando el Drone esta en estado Waiting, lo que hace es patrullar alrededor\n    /// de su radio de operacion.\n    ///\n    /// Esto se logra usando update_target_location, que calcula una nueva posicion\n    /// para seguir \"dentro de su circulo\".\n    ///\n    /// La idea es que si se llega al current_target_location, el Drone calcule una nueva\n    /// posicion para ir, y que comience a moverse.\n    fn patrolling_in_operating_radius(\u0026mut self) -\u003e Result\u003c(), DroneError\u003e {\n        if (self.location.lat * COORDINATE_SCALE_FACTOR).round() / COORDINATE_SCALE_FACTOR\n            == (self.target_location.lat * COORDINATE_SCALE_FACTOR).round()\n                / COORDINATE_SCALE_FACTOR\n            \u0026\u0026 (self.location.long * COORDINATE_SCALE_FACTOR).round() / COORDINATE_SCALE_FACTOR\n                == (self.target_location.long * COORDINATE_SCALE_FACTOR).round()\n                    / COORDINATE_SCALE_FACTOR\n        {\n            self.update_target_location()?;\n        }\n\n        let (new_lat, new_long) = self.calculate_new_position(\n            0.001,\n            \u0026self.location.lat,\n            \u0026self.location.long,\n            \u0026self.target_location.lat,\n            \u0026self.target_location.long,\n        );\n        self.location.lat = new_lat;\n        self.location.long = new_long;\n\n        self.update_location();\n\n        Ok(())\n    }\n\n    /// Una vez que el Drone entra en estado de LowBatteryLevel,\n    /// se redirecciona hacia su centro de carga.\n    ///\n    /// Una vez que llega a esta location, cambia su estado a\n    /// ChargingBattery, por lo que el Drone va a comenzar a cargarse.\n    fn redirect_to_operation_center(\u0026mut self) {\n        if (self.location.lat * COORDINATE_SCALE_FACTOR).round() / COORDINATE_SCALE_FACTOR\n            == (self.center_location.lat * COORDINATE_SCALE_FACTOR).round()\n                / COORDINATE_SCALE_FACTOR\n            \u0026\u0026 (self.location.long * COORDINATE_SCALE_FACTOR).round() / COORDINATE_SCALE_FACTOR\n                == (self.center_location.long * COORDINATE_SCALE_FACTOR).round()\n                    / COORDINATE_SCALE_FACTOR\n        {\n            self.drone_state = DroneState::ChargingBattery;\n        }\n\n        let _ = self.update_drone_position(self.center_location);\n    }\n\n    fn update_drone_position(\u0026mut self, target_location: Location) -\u003e Result\u003c(), DroneError\u003e {\n        let (new_lat, new_long) = self.calculate_new_position(\n            DRONE_SPEED,\n            \u0026self.location.lat,\n            \u0026self.location.long,\n            \u0026target_location.lat,\n            \u0026target_location.long,\n        );\n        self.location.lat = new_lat;\n        self.location.long = new_long;\n\n        self.update_location();\n        Ok(())\n    }\n\n    fn drone_movement(\u0026mut self, target_location: Location) -\u003e Result\u003c(), DroneError\u003e {\n        loop {\n            sleep(Duration::from_millis(DRONE_MOV_SLEEP_TIME));\n\n            if (self.location.lat * COORDINATE_SCALE_FACTOR).round() / COORDINATE_SCALE_FACTOR\n                == (target_location.lat * COORDINATE_SCALE_FACTOR).round() / COORDINATE_SCALE_FACTOR\n                \u0026\u0026 (self.location.long * COORDINATE_SCALE_FACTOR).round() / COORDINATE_SCALE_FACTOR\n                    == (target_location.long * COORDINATE_SCALE_FACTOR).round()\n                        / COORDINATE_SCALE_FACTOR\n            {\n                break;\n            }\n\n            self.update_drone_position(target_location)?;\n        }\n        Ok(())\n    }\n    fn calculate_new_position(\n        \u0026self,\n        speed: f64,\n        current_lat: \u0026f64,\n        current_long: \u0026f64,\n        target_lat: \u0026f64,\n        target_long: \u0026f64,\n    ) -\u003e (f64, f64) {\n        let direction_lat = target_lat - current_lat;\n        let direction_long = target_long - current_long;\n        let magnitude = (direction_lat.powi(2) + direction_long.powi(2)).sqrt();\n        let effective_range = speed * TOLERANCE_FACTOR;\n        if magnitude \u003c effective_range {\n            return (*target_lat, *target_long);\n        }\n        let unit_direction_lat = direction_lat / magnitude;\n        let unit_direction_long = direction_long / magnitude;\n\n        let new_lat = current_lat + unit_direction_lat * speed;\n        let new_long = current_long + unit_direction_long * speed;\n\n        (new_lat, new_long)\n    }\n\n    fn update_location(\u0026mut self) {\n        let publish_config = match PublishConfig::read_config(\n            \"src/drones/publish_config.json\",\n            PayloadTypes::DroneLocation(self.id, self.location),\n        ) {\n            Ok(config) =\u003e config,\n            Err(e) =\u003e {\n                println!(\"Error reading publish config: {:?}\", e);\n                return;\n            }\n        };\n\n        match self.send_to_client_channel.send(Box::new(publish_config)) {\n            Ok(_) =\u003e (),\n            Err(e) =\u003e {\n                println!(\"Error sending to client channel: {:?}\", e);\n            }\n        };\n    }\n\n    fn publish_attending_accident(\u0026mut self, location: Location) {\n        let incident_payload = IncidentPayload::new(Incident::new(location));\n        let publish_config = match PublishConfig::read_config(\n            \"src/drones/publish_attending_incident_config.json\",\n            PayloadTypes::AttendingIncident(incident_payload),\n        ) {\n            Ok(config) =\u003e config,\n            Err(e) =\u003e {\n                println!(\"Error reading publish config: {:?}\", e);\n                return;\n            }\n        };\n\n        match self.send_to_client_channel.send(Box::new(publish_config)) {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                println!(\"Error sending to client channel: {:?}\", e);\n            }\n        };\n    }\n    fn update_target_location(\u0026mut self) -\u003e Result\u003c(), DroneError\u003e {\n        let current_time = Utc::now().timestamp_millis() as f64;\n        let angle = ((current_time * ANGLE_SCALING_FACTOR) / MILISECONDS_PER_SECOND) % TWO_PI;\n        let operation_radius = self.drone_config.get_operation_radius();\n        // Ensure the drone stays within the operation radius from the center location\n        let new_target_lat = self.center_location.lat + operation_radius * angle.cos();\n        let new_target_long = self.center_location.long + operation_radius * angle.sin();\n        self.target_location = Location::new(new_target_lat, new_target_long);\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        mqtt::broker::Broker,\n        utils::location::{self, Location},\n    };\n    use std::{\n        sync::{Arc, Condvar, Mutex},\n        thread,\n    };\n\n    use super::*;\n\n    #[test]\n    fn test_01_drone_arranca_en_waiting_state() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5001\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n\n        let handle = thread::spawn(move || {\n            let latitude = 0.0;\n            let longitude = 0.0;\n            let location = location::Location::new(latitude, longitude);\n            let center_location = location::Location::new(0.0, 0.0);\n            let mut drone = Drone::new(\n                1,\n                location,\n                center_location,\n                \"./src/drones/drone_config.json\",\n                \"127.0.0.1:5001\".to_string(),\n            )\n            .unwrap();\n\n            let _ = drone.run_drone();\n\n            assert_eq!(drone.get_state(), DroneState::Waiting);\n        });\n        handle.join().unwrap();\n    }\n\n    #[test]\n    fn test_03_get_id_ok() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5003\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n\n        let handle = thread::spawn(move || {\n            let latitude = 0.0;\n            let longitude = 0.0;\n            let location = location::Location::new(latitude, longitude);\n            let center_location = location::Location::new(0.0, 0.0);\n            let drone = Drone::new(\n                1,\n                location,\n                center_location,\n                \"./tests/drone_config_test.json\",\n                \"127.0.0.1:5003\".to_string(),\n            )\n            .unwrap();\n\n            assert_eq!(drone.get_id(), 1);\n        });\n        handle.join().unwrap();\n    }\n\n    #[test]\n    fn test_04_drone_bad_config_file() {\n        let latitude = 0.0;\n        let longitude = 0.0;\n        let location = location::Location::new(latitude, longitude);\n        let center_location = location::Location::new(0.0, 0.0);\n        let drone = Drone::new(\n            1,\n            location,\n            center_location,\n            \"./tests/bad_config_file.json\",\n            \"127.0.0.1:5000\".to_string(),\n        );\n        assert!(drone.is_err());\n    }\n\n    #[test]\n    fn test_drone_stays_within_radius() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5004\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n\n        let handle = thread::spawn(move || {\n            let latitude = 0.0;\n            let longitude = 0.0;\n            let location = location::Location::new(latitude, longitude);\n            let center_location = location::Location::new(0.0, 0.0);\n            let mut drone = Drone::new(\n                1,\n                location,\n                center_location,\n                \"./src/drones/drone_config.json\",\n                \"127.0.0.1:5004\".to_string(),\n            )\n            .unwrap();\n            let target_location = location::Location::new(0.001, 0.001);\n            let radius = 0.005;\n            let _ = drone.drone_movement(target_location);\n\n            let distance_from_center =\n                ((drone.location.lat).powi(2) + (drone.location.long).powi(2)).sqrt();\n            assert!(\n                distance_from_center \u003c= radius,\n                \"Drone should stay within the radius.\"\n            );\n        });\n        handle.join().unwrap();\n    }\n\n    #[test]\n    fn test_new_drone() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5007\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n        let handle = thread::spawn(move || {\n            let location = Location {\n                lat: 0.0,\n                long: 0.0,\n            };\n            let center_location = Location {\n                lat: 0.0,\n                long: 0.0,\n            };\n            let config_file_path = \"./src/drones/drone_config.json\";\n            let address = \"127.0.0.1:5007\".to_string();\n\n            let drone: Result\u003cDrone, DroneError\u003e = Drone::new(\n                1,\n                location.clone(),\n                center_location.clone(),\n                config_file_path,\n                address,\n            );\n\n            assert!(drone.is_ok());\n            let drone = drone.unwrap();\n            assert_eq!(drone.id, 1);\n            assert_eq!(drone.location, location);\n            assert_eq!(drone.center_location, center_location);\n            assert_eq!(drone.battery_level, 100);\n            assert_eq!(drone.drone_state, DroneState::Waiting);\n        });\n        handle.join().unwrap();\n    }\n\n    #[test]\n    fn test_battery_discharge() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5008\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n        let mut drone = setup_test_drone(\"127.0.0.1:5008\".to_string());\n        for _ in 0..100 {\n            drone.update_battery_discharge(Utc::now(), Utc::now() + chrono::Duration::seconds(120));\n        }\n\n        assert!(drone.battery_level \u003c= 0);\n        assert_eq!(drone.drone_state, DroneState::LowBatteryLevel);\n    }\n\n    #[test]\n    fn test_charge_battery() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5009\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n\n        let mut drone = setup_test_drone(\"127.0.0.1:5009\".to_string());\n        for _ in 0..100 {\n            drone.update_battery_discharge(Utc::now(), Utc::now() + chrono::Duration::seconds(120));\n        }\n\n        assert!(drone.battery_level \u003c= 0);\n        assert_eq!(drone.drone_state, DroneState::LowBatteryLevel);\n\n        for _ in 0..100 {\n            drone.update_battery_charge(Utc::now(), Utc::now() + chrono::Duration::seconds(120));\n        }\n        assert_eq!(drone.battery_level, 100);\n        assert_eq!(drone.get_state(), DroneState::Waiting);\n    }\n\n    #[test]\n    fn test_drone_movement() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5010\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n        let handle = thread::spawn(move || {\n            let mut drone = setup_test_drone(\"127.0.0.1:5010\".to_string());\n            drone.location = Location {\n                lat: 0.0,\n                long: 0.0,\n            };\n            let target_location = Location {\n                lat: 1.0,\n                long: 1.0,\n            };\n            let drone_arc = Arc::new(Mutex::new(drone));\n            for _ in 0..14 {\n                let mut drone = drone_arc.lock().unwrap();\n                drone\n                    .update_drone_position(target_location.clone())\n                    .unwrap();\n            }\n            let drone = drone_arc.lock().unwrap();\n            let new_location = \u0026drone.location;\n            println!(\"New location: {:?}\", new_location);\n            assert!(new_location.lat \u003e 0.0 \u0026\u0026 new_location.lat \u003c 1.0);\n            assert!(new_location.long \u003e 0.0 \u0026\u0026 new_location.long \u003c 1.0);\n        });\n        handle.join().unwrap();\n    }\n\n    // #[test]\n    // fn drone_con_poca_bateria_va_a_cargarse() {\n    //     let args = vec![\"127.0.0.1\".to_string(), \"5020\".to_string()];\n    //     let mut broker = match Broker::new(args) {\n    //         Ok(broker) =\u003e broker,\n    //         Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n    //     };\n\n    //     let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n    //     let server_ready_clone = server_ready.clone();\n    //     thread::spawn(move || {\n    //         {\n    //             let (lock, cvar) = \u0026*server_ready_clone;\n    //             let mut ready = lock.lock().unwrap();\n    //             *ready = true;\n    //             cvar.notify_all();\n    //         }\n    //         let _ = broker.server_run();\n    //     });\n\n    //     // Wait for the server to start\n    //     {\n    //         let (lock, cvar) = \u0026*server_ready;\n    //         let mut ready = lock.lock().unwrap();\n    //         while !*ready {\n    //             ready = cvar.wait(ready).unwrap();\n    //         }\n    //     }\n    //     let handle = thread::spawn(move || {\n    //         let mut drone = setup_test_drone(\"127.0.0.1:5020\".to_string());\n    //         drone.center_location = Location {\n    //             lat: 2.0,\n    //             long: 1.0,\n    //         };\n    //         drone.location = Location {\n    //             lat: 0.0,\n    //             long: 0.0,\n    //         };\n    //         let _target_location = Location {\n    //             lat: 1.0,\n    //             long: 1.0,\n    //         };\n    //         drone.drone_state = DroneState::LowBatteryLevel;\n    //         drone.battery_level = 19;\n    //         let drone_arc = Arc::new(Mutex::new(drone));\n    //         let mut se_cargo = false;\n    //         for _ in 0..100 {\n    //             let mut drone = drone_arc.lock().unwrap();\n    //             drone.patrolling_in_operating_radius().unwrap();\n    //             if drone.location == drone.center_location {\n    //                 se_cargo = true;\n    //                 break;\n    //             }\n    //         }\n    //         assert!(se_cargo);\n    //     });\n    //     handle.join().unwrap();\n    // }\n\n    // #[test]\n    // fn test_drone_movement_out_of_bounds() {\n    //     let args = vec![\"127.0.0.1\".to_string(), \"5011\".to_string()];\n    //     let mut broker = match Broker::new(args) {\n    //         Ok(broker) =\u003e broker,\n    //         Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n    //     };\n\n    //     let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n    //     let server_ready_clone = server_ready.clone();\n    //     thread::spawn(move || {\n    //         {\n    //             let (lock, cvar) = \u0026*server_ready_clone;\n    //             let mut ready = lock.lock().unwrap();\n    //             *ready = true;\n    //             cvar.notify_all();\n    //         }\n    //         let _ = broker.server_run();\n    //     });\n\n    //     // Wait for the server to start\n    //     {\n    //         let (lock, cvar) = \u0026*server_ready;\n    //         let mut ready = lock.lock().unwrap();\n    //         while !*ready {\n    //             ready = cvar.wait(ready).unwrap();\n    //         }\n    //     }\n    //     let handle = thread::spawn(move || {\n    //         let mut drone = setup_test_drone(\"127.0.0.1:5011\".to_string());\n    //         let drone_arc = Arc::new(Mutex::new(drone.clone()));\n    //         drone.location = Location {\n    //             lat: 0.0,\n    //             long: 0.0,\n    //         };\n    //         let target_location = Location {\n    //             lat: 1.0,\n    //             long: 1.0,\n    //         };\n    //         for _ in 0..14 {\n    //             let mut drone = drone_arc.lock().unwrap();\n    //             drone\n    //                 .update_drone_position_and_battery(\u0026target_location)\n    //                 .unwrap();\n    //         }\n\n    //         let new_location = drone.location;\n\n    //         let distance_from_center =\n    //             ((new_location.lat - 0.0).powi(2) + (new_location.long - 0.0).powi(2)).sqrt();\n    //         assert!(distance_from_center \u003c= 0.005);\n    //     });\n    //     handle.join().unwrap();\n    // }\n\n    /// Esta función de prueba simula el comportamiento de un dron cuando su batería se descarga.\n    ///\n    /// La prueba comienza creando un nuevo broker y ejecutándolo en un hilo separado.\n    /// Luego, crea un dron en una ubicación específica e inicia un hilo para simular la descarga de la batería.\n    ///\n    /// En otro hilo, el dron se mueve hacia una ubicación objetivo hasta que su nivel de batería es bajo.\n    /// Cuando el nivel de batería del dron es bajo, verifica que la ubicación del dron no sea la misma que la ubicación objetivo.\n    /// Esto se debe a que el dron deberia estar en camino o yendo hacia el centro de carga debido a su nivel de bateria\n    ///\n    /// Después de que el nivel de batería del dron es bajo, deja de mover el dron y verifica que la ubicación del dron sea la misma que la ubicación objetivo.\n    /// Esto se debe a que el dron debería haber regresado a la ubicación objetivo después de que su batería se descargó.\n    ///\n    // #[test]\n    // fn test_volver_a_pos_original_despues_de_cargarse() {\n    //     let args = vec![\"127.0.0.1\".to_string(), \"5012\".to_string()];\n    //     let mut broker = match Broker::new(args) {\n    //         Ok(broker) =\u003e broker,\n    //         Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n    //     };\n\n    //     let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n    //     let server_ready_clone = server_ready.clone();\n    //     thread::spawn(move || {\n    //         {\n    //             let (lock, cvar) = \u0026*server_ready_clone;\n    //             let mut ready = lock.lock().unwrap();\n    //             *ready = true;\n    //             cvar.notify_all();\n    //         }\n    //         let _ = broker.server_run();\n    //     });\n\n    //     // Wait for the server to start\n    //     {\n    //         let (lock, cvar) = \u0026*server_ready;\n    //         let mut ready = lock.lock().unwrap();\n    //         while !*ready {\n    //             ready = cvar.wait(ready).unwrap();\n    //         }\n    //     }\n    //     let handle = thread::spawn(move || {\n    //         let latitude = 0.0;\n    //         let longitude = 0.0;\n    //         let location = location::Location::new(latitude, longitude);\n    //         let center_location = location::Location::new(0.0, 0.0);\n    //         let drone = Drone::new(\n    //             1,\n    //             location,\n    //             center_location,\n    //             \"./src/drones/drone_config.json\",\n    //             \"127.0.0.1:5012\".to_string(),\n    //         )\n    //         .unwrap();\n\n    //         //thread de descarga de bateria\n    //         let mut drone_clone = drone.clone();\n    //         let _ = thread::spawn(move || {\n    //             let _ = drone_clone.battery_discharge();\n    //         });\n\n    //         let mut drone_clone = drone.clone();\n    //         let drone_clone2 = drone.clone();\n    //         let _ = thread::spawn(move || {\n    //             let mut terminado = false;\n    //             let target_location = location::Location::new(0.001, 0.001);\n    //             let _ = drone.location.clone();\n\n    //             while !terminado {\n    //                 let target_location = location::Location::new(0.001, 0.001);\n    //                 let _ = drone_clone.location.clone();\n\n    //                 let _ = drone_clone.drone_movement(target_location.clone());\n    //                 if drone_clone2.clone().get_state() == DroneState::LowBatteryLevel {\n    //                     assert_ne!(drone_clone.location, target_location.clone());\n    //                     terminado = true;\n    //                 }\n    //             }\n    //             assert_eq!(drone_clone.location, target_location.clone());\n    //         });\n    //     });\n    //     handle.join().unwrap();\n    // }\n\n    // Helper function to setup a test drone\n    fn setup_test_drone(addres: String) -\u003e Drone {\n        let location = Location {\n            lat: 0.0,\n            long: 0.0,\n        };\n        let center_location = Location {\n            lat: 0.0,\n            long: 0.0,\n        };\n        let config_file_path = \"./src/drones/drone_config.json\";\n        let address = addres.to_string();\n\n        Drone::new(1, location, center_location, config_file_path, address).unwrap()\n    }\n}\n","traces":[{"line":79,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":670802},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":670802},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":670802},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":670798},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":670798},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":670798},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":670798},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":671016},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":671016},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":671016},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":671016},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":671016},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":226},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":228},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":226},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":670790},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":670816},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":670816},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":670816},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":670816},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":670816},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":107,"coverable":213},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","drones","drone_center.rs"],"content":"use egui::ahash::HashMap;\nuse rand::Rng;\n\nuse crate::drones::drone::Drone;\nuse crate::utils::location::Location;\n\nuse super::drone_error::DroneError;\n#[derive(Debug)]\n\n///Un drone cententer esta compuesto por sus diferentes drones.\n/// Tiene su ID unico, su ubicación, la dirección a la que se conecta\n/// y el path de su configuración.\npub struct DroneCenter {\n    pub id: u32,\n    pub location: Location,\n    pub drones: HashMap\u003cu32, Drone\u003e,\n    drone_config_path: String,\n    address: String,\n}\n\nimpl DroneCenter {\n    pub fn new(\n        id: u32,\n        location: Location,\n        drone_config_path: String,\n        address: String,\n    ) -\u003e DroneCenter {\n        Self {\n            id,\n            location,\n            drones: HashMap::default(),\n            drone_config_path,\n            address,\n        }\n    }\n\n    pub fn get_id(\u0026self) -\u003e u32 {\n        self.id\n    }\n\n    pub fn get_location(\u0026self) -\u003e Location {\n        self.location\n    }\n\n    /// Crea un dron y lo agrega al hashmap con un ID que no esté siendo utilizado\n    ///\n    /// Retorna el ID del dron creado o DroneError en caso de error.\n    pub fn add_drone(\u0026mut self, location: Location) -\u003e Result\u003cu32, DroneError\u003e {\n        // let mut rng = rand::thread_rng();\n\n        // let mut id = rng.gen();\n\n        let mut id = 0;\n        while self.drones.contains_key(\u0026id) {\n            id += 1;\n        }\n\n        let mut drone = Drone::new(\n            id,\n            location,\n            self.location,\n            \u0026self.drone_config_path.to_string(),\n            self.address.to_string(),\n        )?;\n        let _ = drone.run_drone();\n        self.drones.insert(id, drone);\n        Ok(id)\n    }\n\n    pub fn get_drones(\u0026self) -\u003e \u0026HashMap\u003cu32, Drone\u003e {\n        \u0026self.drones\n    }\n\n    /// Retorna un dron aleatorio del centro de drones\n    pub fn get_drone(\u0026self) -\u003e Option\u003c\u0026Drone\u003e {\n        let keys: Vec\u003c\u0026u32\u003e = self.drones.keys().collect();\n        if keys.is_empty() {\n            None\n        } else {\n            let idx = rand::thread_rng().gen_range(0..keys.len());\n            self.drones.get(keys[idx])\n        }\n    }\n\n    /// Retorna un dron del centro de drones segun su ID\n    pub fn get_drone_by_id(\u0026self, id: u32) -\u003e Option\u003c\u0026Drone\u003e {\n        let drone = self.drones.get(\u0026id);\n\n        drone\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use core::panic;\n    use std::thread;\n\n    use crate::{mqtt::broker::Broker, utils::location};\n\n    use super::*;\n\n    #[test]\n    fn test_01_drone_center_add_drone_ok() {\n        let latitude = 0.0;\n        let longitude = 0.0;\n        let location = location::Location::new(latitude, longitude);\n        // Set up a listener on a local port.\n        let args = vec![\"127.0.0.1\".to_string(), \"5000\".to_string()];\n        let addr = \"127.0.0.1:5000\";\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e {\n                panic!(\"Error creating broker: {:?}\", e)\n            }\n        };\n        thread::spawn(move || {\n            _ = broker.server_run();\n        });\n\n        thread::spawn(move || {\n            let mut drone_center = DroneCenter::new(\n                1,\n                location.clone(),\n                \"src/drones/drone_config.json\".to_string(),\n                addr.to_string(),\n            );\n\n            match drone_center.add_drone(location) {\n                Ok(_) =\u003e {}\n                Err(e) =\u003e {\n                    panic!(\"Error adding drone to drone center: {:?}\", e)\n                }\n            };\n\n            let drones = drone_center.get_drones();\n\n            assert_eq!(drones.len(), 1);\n        });\n    }\n\n    #[test]\n    fn test_02_drone_center_get_drone_ok() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5000\".to_string()];\n        let addr = \"127.0.0.1:5000\";\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e {\n                panic!(\"Error creating broker: {:?}\", e)\n            }\n        };\n        thread::spawn(move || {\n            _ = broker.server_run();\n        });\n\n        thread::spawn(move || {\n            let latitude = 0.0;\n            let longitude = 0.0;\n            let location = location::Location::new(latitude, longitude);\n            let mut drone_center = DroneCenter::new(\n                1,\n                location.clone(),\n                \"./src/drones/drone_config.json\".to_string(),\n                addr.to_string(),\n            );\n\n            let id = match drone_center.add_drone(location) {\n                Ok(id) =\u003e id,\n                Err(e) =\u003e {\n                    panic!(\"Error adding drone to drone center: {:?}\", e)\n                }\n            };\n\n            let drone = drone_center.get_drone_by_id(id);\n\n            assert!(drone.is_some());\n        });\n    }\n\n    #[test]\n    fn test_03_drone_center_get_drone_none() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5000\".to_string()];\n        let addr = \"127.0.0.1:5000\";\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e {\n                panic!(\"Error creating broker: {:?}\", e)\n            }\n        };\n        thread::spawn(move || {\n            _ = broker.server_run();\n        });\n\n        thread::spawn(move || {\n            let latitude = 0.0;\n            let longitude = 0.0;\n            let location = location::Location::new(latitude, longitude);\n            let mut drone_center = DroneCenter::new(\n                1,\n                location.clone(),\n                \"./src/drones/drone_config.json\".to_string(),\n                addr.to_string(),\n            );\n\n            let id = drone_center.add_drone(location).unwrap();\n\n            let drone = drone_center.get_drone_by_id(id);\n\n            assert!(drone.is_none());\n        });\n    }\n\n    #[test]\n    fn test_04_drone_center_get_location_ok() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5000\".to_string()];\n        let addr = \"127.0.0.1:5000\";\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e {\n                panic!(\"Error creating broker: {:?}\", e)\n            }\n        };\n        thread::spawn(move || {\n            _ = broker.server_run();\n        });\n\n        thread::spawn(move || {\n            let latitude = 0.0;\n            let longitude = 0.0;\n            let location = location::Location::new(latitude, longitude);\n            let drone_center = DroneCenter::new(\n                1,\n                location.clone(),\n                \"./src/drones/drone_config.json\".to_string(),\n                addr.to_string(),\n            );\n\n            let drone_center_location = drone_center.get_location();\n\n            assert_eq!(drone_center_location, location);\n        });\n    }\n\n    #[test]\n    fn test_05_get_drpnes_ok() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5000\".to_string()];\n        let addr = \"127.0.0.1:5000\";\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e {\n                panic!(\"Error creating broker: {:?}\", e)\n            }\n        };\n        thread::spawn(move || {\n            _ = broker.server_run();\n        });\n\n        thread::spawn(move || {\n            let latitude = 0.0;\n            let longitude = 0.0;\n            let location = location::Location::new(latitude, longitude);\n            let mut drone_center = DroneCenter::new(\n                1,\n                location.clone(),\n                \"./src/drones/drone_config.json\".to_string(),\n                addr.to_string(),\n            );\n\n            let _ = drone_center.add_drone(location);\n\n            let drones = drone_center.get_drones();\n\n            assert_eq!(drones.len(), 1);\n        });\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":14,"coverable":26},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","drones","drone_config.rs"],"content":"use serde::Deserialize;\n\nuse super::drone_error::DroneError;\nuse std::{env, fs::File, io::BufReader};\n\n/// Sirve para levantar la configuracion del Drone a partir del JSON.\n/// Pone a correr al Drone:\n///     - Simula su descarga de bateria.\n///     - Hace que se mueva dentro de su area de operacion.\n#[allow(dead_code)]\n#[derive(Debug, Deserialize, Clone)]\npub struct DroneConfig {\n    /// Indice la tasa de carga de la bateria en milisegundos.\n    /// Por ej: si vale 10, por cada segundo que pase, la\n    /// bateria del Drone aumentara en un 100 por ciento.\n    battery_charge_rate_milisecs: i64,\n\n    /// Indice la tasa de desgaste de la bateria en milisegundos.\n    /// Por ej: si vale 10, por cada segundo que pase, la\n    /// bateria del Drone se reducira en un 100 por ciento.\n    battery_discharge_rate_milisecs: i64,\n\n    /// El Drone circulara en un area de operacion determinado por el archivo de configuracion.\n    /// A medida que pasa el tiempo, el Drone va moviendose dentro de ese area.\n    operation_radius: f64,\n\n    /// Es la velocidad con la que el Drone va a circular.\n    /// Para simplificarle la vida al usuario, el valor que se\n    /// lee desde el archivo de configuracion esta en km/h.\n    movement_rate: i64,\n}\n\nimpl DroneConfig {\n    /// Leo la configuracion a partir de un archivo json.\n    pub fn new(config_file_path: \u0026str) -\u003e Result\u003cDroneConfig, DroneError\u003e {\n        match DroneConfig::read_drone_config(config_file_path) {\n            Ok(config) =\u003e Ok(config),\n            Err(err) =\u003e Err(err),\n        }\n    }\n\n    /// Toma un path a un archivo de configuracion y levanta el DroneConfig.\n    fn read_drone_config(file_path: \u0026str) -\u003e Result\u003cDroneConfig, DroneError\u003e {\n        println!(\"Reading config file: {}\", file_path);\n        let config_file = match File::open(file_path) {\n            Ok(file) =\u003e file,\n            Err(e) =\u003e {\n                let current_dir = match env::current_dir() {\n                    Ok(dir) =\u003e dir,\n                    Err(_) =\u003e {\n                        return Err(DroneError::ReadingConfigFileError);\n                    }\n                };\n                println!(\"Current directory: {}\", current_dir.display());\n                println!(\n                    \"Error al abrir el archivo de configuracion del Drone: {:?}\",\n                    e,\n                );\n                return Err(DroneError::ReadingConfigFileError);\n            }\n        };\n\n        let reader: BufReader\u003cFile\u003e = BufReader::new(config_file);\n        let config = match serde_json::from_reader(reader) {\n            Ok(c) =\u003e c,\n            Err(_) =\u003e return Err(DroneError::ReadingConfigFileError),\n        };\n\n        Ok(config)\n    }\n\n    /// Simula la descarga de bateria del Drone, dependiendo de su\n    /// tasa de descarga en milisegundos.\n    ///\n    /// Tambien, el Drone se movera dependiendo del tiempo\n    /// transcurrido, su velocidad asignada y su radio de operacion.\n    ///\n    /// Para poder hacer ambas cosas a la vez, trabajo con dos threads: uno encargado de descargar la bateria,\n    /// y otro que se encarga de mover al Drone(siempre y cuando tenga bateria).\n\n    pub fn get_battery_discharge_rate(\u0026self) -\u003e i64 {\n        self.battery_discharge_rate_milisecs\n    }\n\n    pub fn get_battery_charge_rate_milisecs(\u0026mut self) -\u003e i64 {\n        self.battery_charge_rate_milisecs\n    }\n    pub fn get_operation_radius(\u0026self) -\u003e f64 {\n        self.operation_radius\n    }\n\n    pub fn get_movement_rate(\u0026self) -\u003e i64 {\n        self.movement_rate\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn test_01_config_creation_cases() {\n        let config_ok = DroneConfig::new(\"./src/drones/drone_config.json\");\n\n        let config_err = DroneConfig::new(\"este/es/un/path/feo\");\n\n        assert!(config_ok.is_ok());\n        assert!(config_err.is_err());\n    }\n\n    #[test]\n    fn test_04_bad_config_file() {\n        let config = DroneConfig::read_drone_config(\"este/es/un/path/feo\");\n\n        assert!(config.is_err());\n    }\n}\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":671012},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":671012},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":20,"coverable":26},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","drones","drone_error.rs"],"content":"use std::fmt;\n\n/// Errores que se pueden lanzar desde el software de control de Drones.\n#[derive(Debug, PartialEq)]\npub enum DroneError {\n    ReadingConfigFileError,\n    DroneCenterNotFound,\n    ProtocolError(String),\n    BatteryEmpty,\n}\n\nimpl fmt::Display for DroneError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match *self {\n            DroneError::ReadingConfigFileError =\u003e {\n                write!(\n                    f,\n                    \"Error: no se ha podido encontrar el archivo de configuracion de drones.\"\n                )\n            }\n            DroneError::DroneCenterNotFound =\u003e {\n                write!(f, \"Error: no se ha podido encontrar el centro de drones.\")\n            }\n            DroneError::ProtocolError(ref err) =\u003e write!(f, \"Error de protocolo: {}\", err),\n            DroneError::BatteryEmpty =\u003e write!(\n                f,\n                \"Error: la bateria del dron está completamente descargada.\"\n            ),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_drone_error_display() {\n        let error = DroneError::ReadingConfigFileError;\n        assert_eq!(\n            format!(\"{}\", error),\n            \"Error: no se ha podido encontrar el archivo de configuracion de drones.\"\n        );\n\n        let error = DroneError::DroneCenterNotFound;\n        assert_eq!(\n            format!(\"{}\", error),\n            \"Error: no se ha podido encontrar el centro de drones.\"\n        );\n\n        let error = DroneError::ProtocolError(\"Error de protocolo\".to_string());\n        assert_eq!(\n            format!(\"{}\", error),\n            \"Error de protocolo: Error de protocolo\"\n        );\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":6,"coverable":8},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","drones","drone_location.rs"],"content":"use crate::utils::location::Location;\n\n#[derive(Debug, Clone)]\npub struct DroneLocation {\n    pub id: u32,\n    pub location: Location,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","drones","drone_state.rs"],"content":"use crate::utils::location::Location;\n\n///  El Drone puede tener distintos estados:\n/// - Waiting: esta circulando en su radio de operacion, pero no esta atendiendo ningun incidente.\n/// - AttendingIncident: un nuevo incidente fue cargado por la app de monitoreo, y el Drone fue asignado\n///                         a resolverlo.\n/// - LowBatteryLevel: el Drone se quedo sin bateria, por lo que va a su central a cargarse, y no va a volver a\n///                    funcionar hasta que tenga el nivel de bateria completo(al terminar de cargarse, vuelve a\n///                    tener el estado Waiting).\n/// - ChargingBattery: se va a utilizar cuando el Drone este cargando su bateria en su central.\n///                    La idea es que no patrulle ni se ponga a resolver incidentes en este estado.\n#[derive(Debug, PartialEq, Clone)]\npub enum DroneState {\n    Waiting,\n    AttendingIncident(Location),\n    LowBatteryLevel,\n    ChargingBattery,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","drones","drone_system.rs"],"content":"use egui::ahash::HashMap;\n\nuse crate::drones::drone_center::DroneCenter;\nuse crate::utils::location::Location;\n\nuse super::drone_error::DroneError;\n\n#[derive(Debug)]\npub struct DroneSystem {\n    pub drone_centers: HashMap\u003cu32, DroneCenter\u003e,\n    drone_config_path: String,\n    address: String,\n}\n\n/// The `DroneSystem` struct represents a system that manages drone centers and drones.\n/// It provides methods to add, retrieve, move, and remove drones and drone centers.\nimpl DroneSystem {\n    /// Creates a new instance of `DroneSystem`.\n    pub fn new(drone_config_path: String, address: String) -\u003e DroneSystem {\n        Self {\n            drone_centers: HashMap::default(),\n            drone_config_path,\n            address,\n        }\n    }\n\n    /// Agrega un nuevo centro de drones al sistema de drones.\n    ///\n    /// Devuelve su id o DroneError en caso de error.\n    pub fn add_drone_center(\u0026mut self, location: Location) -\u003e Result\u003cu32, DroneError\u003e {\n        // let mut rng = rand::thread_rng();\n\n        // let mut id = rng.gen();\n\n        let mut id = 0;\n        while self.drone_centers.contains_key(\u0026id) {\n            id += 1;\n        }\n\n        let drone_center = DroneCenter::new(\n            id,\n            location,\n            self.drone_config_path.to_string(),\n            self.address.to_string(),\n        );\n        self.drone_centers.insert(id, drone_center);\n        Ok(id)\n    }\n\n    /// Agrega un nuevo dron al centro de drones especificado segun ID\n    ///\n    /// Devuelve el id del drone o DroneError en caso de error.\n    pub fn add_drone(\n        \u0026mut self,\n        location: Location,\n        drone_center_id: u32,\n    ) -\u003e Result\u003cu32, DroneError\u003e {\n        let drone_center = match self.drone_centers.get_mut(\u0026drone_center_id) {\n            Some(drone_center) =\u003e drone_center,\n            None =\u003e return Err(DroneError::DroneCenterNotFound),\n        };\n\n        let id = drone_center.add_drone(location)?;\n        Ok(id)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::{\n        sync::{Arc, Condvar, Mutex},\n        thread::{self},\n    };\n\n    use crate::{mqtt::broker::Broker, utils::location};\n\n    use super::*;\n\n    #[test]\n    fn test_01_drone_system_add_drone_center_ok() {\n        let mut drone_system = DroneSystem::new(\n            \"src/drones/drone_config.json\".to_string(),\n            \"127.0.0.1:5099\".to_string(),\n        );\n        let location = location::Location::new(0.0, 0.0);\n        let _ = drone_system.add_drone_center(location);\n\n        assert_eq!(drone_system.drone_centers.len(), 1);\n    }\n\n    #[test]\n    fn test_02_drone_system_add_drone_ok() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5098\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = match lock.lock() {\n                    Ok(ready) =\u003e ready,\n                    Err(e) =\u003e panic!(\"Error locking mutex: {:?}\", e),\n                };\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = match lock.lock() {\n                Ok(ready) =\u003e ready,\n                Err(e) =\u003e panic!(\"Error locking mutex: {:?}\", e),\n            };\n            while !*ready {\n                ready = match cvar.wait(ready) {\n                    Ok(ready) =\u003e ready,\n                    Err(e) =\u003e panic!(\"Error waiting for condition variable: {:?}\", e),\n                };\n            }\n        }\n        let handle = thread::spawn(move || {\n            let mut drone_system = DroneSystem::new(\n                \"src/drones/drone_config.json\".to_string(),\n                \"127.0.0.1:5098\".to_string(),\n            );\n            let location = location::Location::new(0.0, 0.0);\n            let _ = drone_system.add_drone_center(location);\n\n            let location = location::Location::new(0.0, 0.0);\n            let id = match drone_system.add_drone(location, 0) {\n                Ok(id) =\u003e id,\n                Err(e) =\u003e panic!(\"Error adding drone: {:?}\", e),\n            };\n            println!(\"dron id {}\", id);\n            assert_eq!(drone_system.drone_centers[\u0026id].get_drones().len(), 1);\n        });\n\n        handle.join().unwrap();\n    }\n\n    #[test]\n    fn test_03_drone_system_add_drone_center_not_found() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5002\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n\n        let handle = thread::spawn(move || {\n            let mut drone_system = DroneSystem::new(\n                \"src/drones/drone_config.json\".to_string(),\n                \"127.0.0.1:5002\".to_string(),\n            );\n            let location = location::Location::new(0.0, 0.0);\n            let _ = drone_system.add_drone_center(location);\n\n            let location = location::Location::new(0.0, 0.0);\n            match drone_system.add_drone(location, 1) {\n                Ok(_) =\u003e (),\n                Err(e) =\u003e assert_eq!(e, DroneError::DroneCenterNotFound),\n            };\n        });\n        handle.join().unwrap();\n    }\n\n    #[test]\n    fn test_04_connect_drone() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5097\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n        let t1 = thread::spawn(move || {\n            let mut drone_system = DroneSystem::new(\n                \"src/drones/drone_config.json\".to_string(),\n                \"127.0.0.1:5097\".to_string(),\n            );\n            let location = location::Location::new(0.0, 0.0);\n            let id = drone_system.add_drone_center(location);\n\n            let location = location::Location::new(0.0, 0.0);\n            match drone_system.add_drone(location, id.unwrap()) {\n                Ok(_) =\u003e (),\n                Err(e) =\u003e panic!(\"Error adding drone: {:?}\", e),\n            };\n        });\n        t1.join().unwrap();\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":17,"coverable":18},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","lib.rs"],"content":"#![doc = include_str!(\".././src/doc/informe.md\")]\n\npub mod doc;\npub mod utils;\n#[doc = include_str!(\"doc/informe.md\")]\n#[doc = include_str!(\"doc/marco_teorico.md\")]\n\npub mod mqtt {\n    pub mod connect {\n        pub mod connect_properties;\n        pub mod last_will;\n        pub mod will_properties;\n    }\n    pub mod publish {\n        pub mod publish_config;\n        pub mod publish_properties;\n    }\n\n    pub mod messages_config;\n    pub mod subscribe_config;\n\n    pub mod broker_message;\n    pub mod client;\n    pub mod client_message;\n    pub mod connack_properties;\n    pub mod protocol_error;\n    pub mod reason_code;\n    pub mod subscribe_properties;\n    pub mod subscription;\n    pub mod topic;\n\n    pub mod broker;\n\n    pub mod client_return;\n    pub mod error;\n    pub mod protocol_return;\n\n    pub mod payload;\n}\n\npub mod monitoring {\n    pub mod incident;\n    pub mod monitoring_app;\n    pub mod monitoring_config;\n}\n\npub mod surveilling {\n    pub mod camera;\n    pub mod camera_error;\n    pub mod camera_system;\n}\n\npub mod drones {\n    pub mod drone;\n    pub mod drone_center;\n    pub mod drone_config;\n    pub mod drone_location;\n    pub mod drone_state;\n    pub mod drone_system;\n\n    pub mod drone_error;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","monitoring","incident.rs"],"content":"use serde::Deserialize;\n\nuse crate::{\n    mqtt::protocol_error::ProtocolError,\n    utils::{location::Location, writer::write_string},\n};\n\n#[derive(Debug, Clone, PartialEq, Deserialize)]\n#[allow(dead_code)]\npub struct Incident {\n    location: Location,\n}\n\nimpl Incident {\n    pub fn new(location: Location) -\u003e Incident {\n        Self { location }\n    }\n\n    pub fn get_location(\u0026self) -\u003e Location {\n        self.location\n    }\n\n    pub fn write_to(\u0026self, stream: \u0026mut dyn std::io::prelude::Write) -\u003e Result\u003c(), ProtocolError\u003e {\n        let longitude_string = self.location.long.to_string();\n        write_string(stream, \u0026longitude_string)?;\n\n        let latitude_string = self.location.lat.to_string();\n        write_string(stream, \u0026latitude_string)?;\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\n\nmod tests {\n    //use std::io::Cursor;\n\n    use super::*;\n    #[test]\n    fn test_new_incident() {\n        let location = Location::new(1.0, 2.0);\n        let incident = Incident::new(location.clone());\n        assert_eq!(incident.get_location(), location);\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":12},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","monitoring","monitoring_app.rs"],"content":"//! Se conecta mediante TCP a la dirección asignada por los args que le ingresan\n//! en su constructor.\n\nuse std::collections::HashMap;\nuse std::sync::mpsc::{self, Receiver, Sender};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nuse crate::drones::drone_system::DroneSystem;\nuse crate::monitoring::incident::Incident;\n\nuse crate::mqtt::client::ClientTrait;\nuse crate::mqtt::{\n    client_message::{self, ClientMessage},\n    messages_config::MessagesConfig,\n    publish::{\n        publish_config::PublishConfig,\n        publish_properties::{PublishProperties, TopicProperties},\n    },\n    subscribe_config::SubscribeConfig,\n    subscribe_properties::SubscribeProperties,\n    {client::Client, protocol_error::ProtocolError},\n};\n\nuse crate::surveilling::camera::Camera;\nuse crate::surveilling::camera_system::CameraSystem;\nuse crate::utils::incident_payload::IncidentPayload;\nuse crate::utils::location::Location;\nuse crate::utils::payload_types::PayloadTypes;\n\n#[derive(Debug)]\n#[allow(dead_code)]\npub struct MonitoringApp {\n    send_to_client_channel: Arc\u003cMutex\u003cSender\u003cBox\u003cdyn MessagesConfig + Send\u003e\u003e\u003e\u003e,\n    monitoring_app_client: Client,\n    camera_system: Arc\u003cMutex\u003cCameraSystem\u003cClient\u003e\u003e\u003e,\n    incidents: Arc\u003cMutex\u003cVec\u003c(Incident, u8)\u003e\u003e\u003e,\n    drone_system: DroneSystem,\n    receive_from_client: Arc\u003cMutex\u003cReceiver\u003cClientMessage\u003e\u003e\u003e,\n    active_drones: Arc\u003cMutex\u003cHashMap\u003cu32, Location\u003e\u003e\u003e,\n    cameras: Arc\u003cMutex\u003cHashMap\u003cu32, Camera\u003e\u003e\u003e,\n}\n\n#[allow(dead_code)]\nimpl MonitoringApp {\n    ///recibe una addres a la que conectarse\n    /// Crea el cliente de la app de monitoreo y lo conecta al broker\n    /// Crea un sistema de cámaras y agrega una cámara al sistema\n    pub fn new(args: Vec\u003cString\u003e) -\u003e Result\u003cMonitoringApp, ProtocolError\u003e {\n        let connect_config =\n            client_message::Connect::read_connect_config(\"src/monitoring/connect_config.json\")?;\n\n        let address = args[2].to_string() + \":\" + \u0026args[3].to_string();\n        let camera_system = match CameraSystem::\u003cClient\u003e::with_real_client(address.clone()) {\n            Ok(camera_system) =\u003e camera_system,\n            Err(err) =\u003e return Err(err),\n        };\n        let drone_system =\n            DroneSystem::new(\"src/drones/drone_config.json\".to_string(), address.clone());\n        type MessagesConfigSender = Sender\u003cBox\u003cdyn MessagesConfig + Send\u003e\u003e;\n        type MessagesConfigReceiver = Receiver\u003cBox\u003cdyn MessagesConfig + Send\u003e\u003e;\n        let (tx, rx): (MessagesConfigSender, MessagesConfigReceiver) = mpsc::channel();\n        let (tx2, rx2) = mpsc::channel();\n\n        let monitoring_app_client = match Client::new(rx, address, connect_config, tx2) {\n            Ok(client) =\u003e client,\n            Err(err) =\u003e return Err(err),\n        };\n\n        let client_id = monitoring_app_client.get_client_id();\n        let subscribe_properties: SubscribeProperties = SubscribeProperties::new(1, Vec::new());\n        let subscribe_config = SubscribeConfig::new(\n            \"drone_locations\".to_string(),\n            1,\n            subscribe_properties,\n            client_id.clone(),\n        );\n        match tx.send(Box::new(subscribe_config)) {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                println!(\"Monitoring: Error sending message: {:?}\", e);\n                return Err(ProtocolError::SubscribeError);\n            }\n        };\n\n        let subscribe_properties: SubscribeProperties = SubscribeProperties::new(1, Vec::new());\n        let subscribe_config = SubscribeConfig::new(\n            \"camera_update\".to_string(),\n            1,\n            subscribe_properties,\n            client_id.clone(),\n        );\n        match tx.send(Box::new(subscribe_config)) {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                println!(\"Monitoring: Error sending message: {:?}\", e);\n                return Err(ProtocolError::SubscribeError);\n            }\n        };\n\n        let subscribe_properties: SubscribeProperties = SubscribeProperties::new(1, Vec::new());\n        let subscribe_config = SubscribeConfig::new(\n            \"attendingincident\".to_string(),\n            1,\n            subscribe_properties,\n            client_id.clone(),\n        );\n        match tx.send(Box::new(subscribe_config)) {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                println!(\"Monitoring: Error sending message: {:?}\", e);\n                return Err(ProtocolError::SubscribeError);\n            }\n        };\n\n        let receive_from_client = Arc::new(Mutex::new(rx2));\n        let active_drones = Arc::new(Mutex::new(HashMap::new()));\n        let incidents = Arc::new(Mutex::new(Vec::new()));\n        let cameras = Arc::new(Mutex::new(HashMap::new()));\n        let tx_arc = Arc::new(Mutex::new(tx));\n        let monitoring_app = MonitoringApp {\n            send_to_client_channel: Arc::clone(\u0026tx_arc),\n            incidents: Arc::clone(\u0026incidents),\n            camera_system: Arc::new(Mutex::new(camera_system)),\n            monitoring_app_client,\n            drone_system,\n            receive_from_client: Arc::clone(\u0026receive_from_client),\n            active_drones: Arc::clone(\u0026active_drones),\n            cameras: Arc::clone(\u0026cameras),\n        };\n        thread::spawn(move || loop {\n            let receiver_clone = Arc::clone(\u0026receive_from_client);\n            let active_drones_clone = Arc::clone(\u0026active_drones);\n            let cameras_clone = Arc::clone(\u0026cameras);\n            let incidents_clone = Arc::clone(\u0026incidents);\n            let tx_clone = Arc::clone(\u0026tx_arc);\n\n            update_entities(\n                receiver_clone,\n                active_drones_clone,\n                cameras_clone,\n                incidents_clone,\n                tx_clone,\n            );\n        });\n        Ok(monitoring_app)\n    }\n\n    pub fn run_client(\u0026mut self) -\u003e Result\u003c(), ProtocolError\u003e {\n        self.monitoring_app_client.client_run()?;\n        let _ = CameraSystem::\u003cClient\u003e::run_client(None, self.camera_system.clone());\n        Ok(())\n    }\n\n    pub fn add_camera(\u0026mut self, location: Location) -\u003e Result\u003cu32, ProtocolError\u003e {\n        let mut lock = match self.camera_system.lock() {\n            Ok(lock) =\u003e lock,\n            Err(e) =\u003e {\n                println!(\"Monitoring: Error locking camera system: {:?}\", e);\n                return Err(ProtocolError::LockError);\n            }\n        };\n        match lock.add_camera(location) {\n            Ok(id) =\u003e Ok(id),\n            Err(e) =\u003e {\n                println!(\"Monitoring: Error adding camera: {:?}\", e);\n                Err(ProtocolError::CameraError(e.to_string()))\n            }\n        }\n    }\n\n    pub fn add_incident(\u0026mut self, location: Location) {\n        let incident = Incident::new(location);\n        let mut incidents = self.incidents.lock().unwrap();\n\n        let (incident, drones_attending_incident) = (incident.clone(), 0);\n\n        incidents.push((incident.clone(), drones_attending_incident));\n\n        let topic_properties = TopicProperties {\n            topic_alias: 10,\n            response_topic: \"\".to_string(),\n        };\n\n        let properties = PublishProperties::new(\n            1,\n            10,\n            topic_properties,\n            [1, 2, 3].to_vec(),\n            \"a\".to_string(),\n            1,\n            \"a\".to_string(),\n        );\n        let payload = PayloadTypes::IncidentLocation(IncidentPayload::new(incident));\n\n        let publish_config =\n            PublishConfig::new(1, 1, 1, \"incidente\".to_string(), payload, properties);\n        let send_to_client_channel: std::sync::MutexGuard\u003cSender\u003cBox\u003cdyn MessagesConfig + Send\u003e\u003e\u003e =\n            self.send_to_client_channel.lock().unwrap();\n\n        let _ = send_to_client_channel.send(Box::new(publish_config));\n    }\n\n    pub fn add_drone(\n        \u0026mut self,\n        location: Location,\n        drone_center_id: u32,\n    ) -\u003e Result\u003cu32, ProtocolError\u003e {\n        match self.drone_system.add_drone(location, drone_center_id) {\n            Ok(id) =\u003e Ok(id),\n            Err(e) =\u003e Err(ProtocolError::DroneError(e.to_string())),\n        }\n    }\n\n    pub fn add_drone_center(\u0026mut self, location: Location) -\u003e u32 {\n        self.drone_system\n            .add_drone_center(location)\n            .map_or(0, |id| id)\n    }\n\n    pub fn get_incidents(\u0026self) -\u003e Vec\u003cIncident\u003e {\n        match self.incidents.lock() {\n            Ok(incidents) =\u003e {\n                let mut incidents_without_drones = Vec::new();\n\n                for (incident, _drone_amount) in incidents.iter() {\n                    incidents_without_drones.push(incident.clone());\n                }\n\n                incidents_without_drones\n            }\n            Err(_) =\u003e Vec::new(),\n        }\n    }\n\n    pub fn get_active_drones(\u0026self) -\u003e HashMap\u003cu32, Location\u003e {\n        match self.active_drones.lock() {\n            Ok(active_drones) =\u003e active_drones.clone(),\n            Err(_) =\u003e HashMap::new(),\n        }\n    }\n\n    pub fn get_cameras(\u0026self) -\u003e HashMap\u003cu32, Camera\u003e {\n        match self.cameras.lock() {\n            Ok(cameras) =\u003e cameras.clone(),\n            Err(_) =\u003e HashMap::new(),\n        }\n    }\n}\n\npub fn update_entities(\n    recieve_from_client: Arc\u003cMutex\u003cReceiver\u003cClientMessage\u003e\u003e\u003e,\n    active_drones: Arc\u003cMutex\u003cHashMap\u003cu32, Location\u003e\u003e\u003e,\n    cameras: Arc\u003cMutex\u003cHashMap\u003cu32, Camera\u003e\u003e\u003e,\n    incidents: Arc\u003cMutex\u003cVec\u003c(Incident, u8)\u003e\u003e\u003e,\n    send_to_client_channel: Arc\u003cMutex\u003cSender\u003cBox\u003cdyn MessagesConfig + Send\u003e\u003e\u003e\u003e,\n) {\n    let receiver = match recieve_from_client.lock() {\n        Ok(receiver) =\u003e receiver,\n        Err(_) =\u003e return,\n    };\n\n    loop {\n        if let Ok(message) = receiver.try_recv() {\n            match message {\n                ClientMessage::Publish {\n                    packet_id: _,\n                    topic_name,\n                    qos: _,\n                    retain_flag: _,\n                    payload,\n                    dup_flag: _,\n                    properties: _,\n                } =\u003e {\n                    if topic_name == \"drone_locations\" {\n                        let mut active_drones: std::sync::MutexGuard\u003cHashMap\u003cu32, Location\u003e\u003e =\n                            match active_drones.try_lock() {\n                                Ok(active_drones) =\u003e active_drones,\n                                Err(_) =\u003e return,\n                            };\n                        if let PayloadTypes::DroneLocation(id, drone_locationn) = payload {\n                            active_drones.insert(id, drone_locationn);\n                        }\n                    } else if topic_name == \"camera_update\" {\n                        println!(\"Monitoring: Camera update received\");\n                        let mut cameras = match cameras.try_lock() {\n                            Ok(cameras) =\u003e cameras,\n                            Err(_) =\u003e return,\n                        };\n                        if let PayloadTypes::CamerasUpdatePayload(updated_cameras) = payload {\n                            for camera in updated_cameras {\n                                cameras.insert(camera.get_id(), camera);\n                            }\n                        }\n                    } else if topic_name == \"attendingincident\" {\n                        if let PayloadTypes::AttendingIncident(incident_payload) = payload {\n                            let mut incidents = incidents.lock().unwrap();\n\n                            let mut to_remove = Vec::new();\n\n                            for (incident, count) in incidents.iter_mut() {\n                                if incident.get_location()\n                                    == incident_payload.get_incident().get_location()\n                                {\n                                    *count += 1;\n\n                                    if *count == 2 {\n                                        to_remove.push(incident.clone());\n                                        //publish incident resolver message\n                                        let incident_payload = IncidentPayload::new(Incident::new(\n                                            incident.get_location(),\n                                        ));\n                                        let publish_config = match PublishConfig::read_config(\n                                            \"src/monitoring/publish_solved_incident_config.json\",\n                                            PayloadTypes::IncidentLocation(incident_payload),\n                                        ) {\n                                            Ok(config) =\u003e config,\n                                            Err(e) =\u003e {\n                                                println!(\"Error reading publish config: {:?}\", e);\n                                                return;\n                                            }\n                                        };\n                                        let send_to_client_channel: std::sync::MutexGuard\u003c\n                                            Sender\u003cBox\u003cdyn MessagesConfig + Send\u003e\u003e,\n                                        \u003e = send_to_client_channel.lock().unwrap();\n\n                                        match send_to_client_channel.send(Box::new(publish_config))\n                                        {\n                                            Ok(_) =\u003e {\n                                                println!(\"MONITO AAAAAAA ENVIO LAS COSASSSSSS\");\n                                            }\n                                            Err(e) =\u003e {\n                                                println!(\n                                                    \"Error sending to client channel: {:?}\",\n                                                    e\n                                                );\n                                            }\n                                        };\n                                    }\n                                }\n                            }\n\n                            // Remove incidents marked for removal\n                            incidents.retain(|(inc, _)| !to_remove.contains(inc));\n\n                            println!(\"Incidents: {:?}\", incidents);\n                        }\n                    }\n                }\n                ClientMessage::Auth {\n                    reason_code: _,\n                    authentication_data: _n_data,\n                    reason_string: _,\n                    user_properties: _,\n                    authentication_method: _,\n                } =\u003e {\n                    todo!()\n                }\n                _ =\u003e {}\n            }\n        }\n    }\n}\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":150},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","monitoring","monitoring_config.rs"],"content":"pub struct MonitoringConfig {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","monitoring","ui","camera_view.rs"],"content":"use walkers::Position;\n\nuse crate::ImagesPluginData;\n\npub struct CameraView {\n    pub image: ImagesPluginData,\n    pub position: Position,\n    pub radius: ImagesPluginData,\n    pub clicked: bool,\n}\n\nimpl CameraView {\n    pub fn select(\u0026mut self, position: Option\u003cPosition\u003e) -\u003e bool {\n        if let Some(position) = position {\n            self.clicked = self.distance(position) \u003c 0.001;\n        }\n        self.clicked\n    }\n\n    pub fn distance(\u0026self, position: Position) -\u003e f32 {\n        let dist_lat = self.position.lat() - position.lat();\n        let dist_lon = self.position.lon() - position.lon();\n        (dist_lat * dist_lat + dist_lon * dist_lon).sqrt() as f32\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","monitoring","ui","drone_center_view.rs"],"content":"use walkers::Position;\n\nuse crate::ImagesPluginData;\n\npub struct DroneCenterView {\n    pub image: ImagesPluginData,\n    pub position: Position,\n    pub clicked: bool,\n}\n\nimpl DroneCenterView {\n    pub fn select(\u0026mut self, position: Option\u003cPosition\u003e) -\u003e bool {\n        if let Some(position) = position {\n            self.clicked = self.distance(position) \u003c 0.001;\n        }\n        self.clicked\n    }\n\n    pub fn distance(\u0026self, position: Position) -\u003e f32 {\n        let dist_lat = self.position.lat() - position.lat();\n        let dist_lon = self.position.lon() - position.lon();\n        (dist_lat * dist_lat + dist_lon * dist_lon).sqrt() as f32\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","monitoring","ui","drone_view.rs"],"content":"use walkers::Position;\n\nuse crate::ImagesPluginData;\n\npub struct DroneView {\n    pub image: ImagesPluginData,\n    pub position: Position,\n    pub clicked: bool,\n    // pub id: u32,\n}\n\nimpl DroneView {\n    pub fn select(\u0026mut self, position: Option\u003cPosition\u003e) -\u003e bool {\n        if let Some(position) = position {\n            self.clicked = self.distance(position) \u003c 0.001;\n        }\n        self.clicked\n    }\n\n    pub fn distance(\u0026self, position: Position) -\u003e f32 {\n        let dist_lat = self.position.lat() - position.lat();\n        let dist_lon = self.position.lon() - position.lon();\n        (dist_lat * dist_lat + dist_lon * dist_lon).sqrt() as f32\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","monitoring","ui","incident_view.rs"],"content":"use walkers::Position;\n\nuse crate::ImagesPluginData;\n\npub struct IncidentView {\n    pub image: ImagesPluginData,\n    pub position: Position,\n    pub clicked: bool,\n}\n\nimpl IncidentView {\n    pub fn select(\u0026mut self, position: Option\u003cPosition\u003e) -\u003e bool {\n        if let Some(position) = position {\n            self.clicked = self.distance(position) \u003c 0.001;\n        }\n        self.clicked\n    }\n\n    pub fn distance(\u0026self, position: Position) -\u003e f32 {\n        let dist_lat = self.position.lat() - position.lat();\n        let dist_lon = self.position.lon() - position.lon();\n        (dist_lat * dist_lat + dist_lon * dist_lon).sqrt() as f32\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","monitoring","ui","main.rs"],"content":"mod camera_view;\nmod drone_center_view;\nmod drone_view;\nmod incident_view;\nmod plugins;\nmod windows;\n\nuse camera_view::CameraView;\nuse eframe::{run_native, App, CreationContext, NativeOptions};\nuse egui::{CentralPanel, RichText, TextStyle};\nuse incident_view::IncidentView;\nuse plugins::*;\nuse rustic_city_eye::{\n    monitoring::{incident::Incident, monitoring_app::MonitoringApp},\n    surveilling::camera::Camera,\n    utils::location::Location,\n};\nuse std::collections::HashMap;\nuse walkers::{sources::OpenStreetMap, Map, MapMemory, Position, Texture, Tiles};\nuse windows::*;\n\nstruct MyMap {\n    tiles: Tiles,\n    map_memory: MapMemory,\n    click_watcher: ClickWatcher,\n    camera_icon: ImagesPluginData,\n    cameras: HashMap\u003cu32, CameraView\u003e,\n    camera_radius: ImagesPluginData,\n    active_camera_radius: ImagesPluginData,\n    incident_icon: ImagesPluginData,\n    incidents: Vec\u003cincident_view::IncidentView\u003e,\n    drones: HashMap\u003cu32, drone_view::DroneView\u003e,\n    drone_icon: ImagesPluginData,\n    drone_centers: Vec\u003cdrone_center_view::DroneCenterView\u003e,\n    drone_center_icon: ImagesPluginData,\n    zoom_level: f32,\n}\nimpl MyMap {\n    fn update_drones(\u0026mut self, new_drone_locations: HashMap\u003cu32, Location\u003e) {\n        for (id, location) in new_drone_locations {\n            if let Some(drone) = self.drones.get_mut(\u0026id) {\n                drone.position = Position::from_lon_lat(location.long, location.lat);\n            }\n        }\n    }\n    fn update_cameras(\u0026mut self, new_cameras: HashMap\u003cu32, Camera\u003e) {\n        //update all cameras\n        for (id, camera) in new_cameras {\n            if let Some(camera_view) = self.cameras.get_mut(\u0026id) {\n                if !camera.get_sleep_mode() {\n                    camera_view.radius = ImagesPluginData::new(\n                        self.active_camera_radius.texture.clone(),\n                        self.zoom_level,\n                        self.active_camera_radius.y_scale,\n                    );\n                } else {\n                    camera_view.radius = ImagesPluginData::new(\n                        self.camera_radius.texture.clone(),\n                        self.zoom_level,\n                        self.camera_radius.y_scale,\n                    );\n                }\n            }\n        }\n    }\n\n    fn update_incidents(\u0026mut self, incidents: Vec\u003cIncident\u003e) {\n        let mut new_incident_view = vec![];\n        for incident in incidents {\n            let location = incident.get_location();\n\n            let incident_view = IncidentView {\n                image: self.incident_icon.clone(),\n                position: Position::from_lon_lat(location.long, location.lat),\n                clicked: false,\n            };\n            new_incident_view.push(incident_view);\n        }\n\n        self.incidents = new_incident_view;\n    }\n}\n\nstruct MyApp {\n    username: String,\n    password: String,\n    ip: String,\n    port: String,\n    connected: bool,\n    map: MyMap,\n    monitoring_app: Option\u003cMonitoringApp\u003e,\n}\n\nimpl ImagesPluginData {\n    /// recibe el zoom level inicial y la escala para cada una de las imagenes\n    fn new(texture: Texture, initial_zoom_level: f32, original_scale: f32) -\u003e Self {\n        let scale = initial_zoom_level * original_scale;\n        Self {\n            texture,\n            x_scale: scale,\n            y_scale: scale,\n        }\n    }\n}\nimpl MyApp {\n    fn handle_form(\u0026mut self, ctx: \u0026eframe::egui::Context, _frame: \u0026mut eframe::Frame) {\n        CentralPanel::default().show(ctx, |ui| {\n            ui.vertical_centered(|ui| {\n                ui.label(\n                    RichText::new(\"Username\")\n                        .size(20.0)\n                        .color(egui::Color32::WHITE),\n                );\n                ui.add(\n                    egui::TextEdit::singleline(\u0026mut self.username)\n                        .min_size(egui::vec2(100.0, 20.0))\n                        .text_color(egui::Color32::WHITE)\n                        .font(TextStyle::Body),\n                );\n\n                ui.label(\n                    RichText::new(\"Password\")\n                        .size(20.0)\n                        .color(egui::Color32::WHITE),\n                );\n                ui.add(\n                    egui::TextEdit::singleline(\u0026mut self.password)\n                        .min_size(egui::vec2(100.0, 20.0))\n                        .text_color(egui::Color32::WHITE)\n                        .font(TextStyle::Body),\n                );\n\n                ui.label(RichText::new(\"IP\").size(20.0).color(egui::Color32::WHITE));\n                ui.add(\n                    egui::TextEdit::singleline(\u0026mut self.ip)\n                        .min_size(egui::vec2(100.0, 20.0))\n                        .text_color(egui::Color32::WHITE)\n                        .font(TextStyle::Body),\n                );\n\n                ui.label(RichText::new(\"Port\").size(20.0).color(egui::Color32::WHITE));\n                ui.add(\n                    egui::TextEdit::singleline(\u0026mut self.port)\n                        .min_size(egui::vec2(100.0, 20.0))\n                        .text_color(egui::Color32::WHITE)\n                        .font(TextStyle::Body),\n                );\n\n                if ui.button(\"Submit\").clicked() {\n                    let mut args = vec![\n                        self.username.clone(),\n                        self.password.clone(),\n                        self.ip.clone(),\n                        self.port.clone(),\n                    ];\n                    if args[2].is_empty() \u0026\u0026 args[3].is_empty() {\n                        \"127.0.0.1\".clone_into(\u0026mut args[2]);\n                        \"5000\".clone_into(\u0026mut args[3]);\n                    }\n                    match MonitoringApp::new(args) {\n                        Ok(mut monitoring_app) =\u003e {\n                            let _ = monitoring_app.run_client();\n                            self.monitoring_app = Some(monitoring_app);\n                            self.connected = true;\n                        }\n                        Err(_) =\u003e {\n                            println!(\"La conexion ha fallado. Intenta conectarte nuevamente.\");\n                            self.username.clear();\n                            self.password.clear();\n                            self.ip.clear();\n                            self.port.clear();\n                        }\n                    };\n                }\n            })\n        });\n    }\n\n    fn handle_map(\u0026mut self, ctx: \u0026eframe::egui::Context, _frame: \u0026mut eframe::Frame) {\n        CentralPanel::default().show(ctx, |ui| {\n            let last_clicked = self.map.click_watcher.clicked_at;\n\n            ui.add(\n                Map::new(\n                    Some(\u0026mut self.map.tiles),\n                    \u0026mut self.map.map_memory,\n                    Position::from_lon_lat(-58.368925, -34.61716),\n                )\n                .with_plugin(\u0026mut self.map.click_watcher)\n                .with_plugin(cameras(\n                    \u0026mut self.map.cameras,\n                    self.map.zoom_level,\n                    last_clicked,\n                ))\n                .with_plugin(incidents(\n                    \u0026mut self.map.incidents,\n                    self.map.zoom_level,\n                    last_clicked,\n                ))\n                .with_plugin(drones(\n                    \u0026mut self.map.drones,\n                    self.map.zoom_level,\n                    last_clicked,\n                ))\n                .with_plugin(drone_centers(\n                    \u0026mut self.map.drone_centers,\n                    self.map.zoom_level,\n                    last_clicked,\n                )),\n            );\n            zoom(ui, \u0026mut self.map.map_memory, \u0026mut self.map.zoom_level);\n\n            if let Some(monitoring_app) = \u0026mut self.monitoring_app {\n                let new_locations = monitoring_app.get_active_drones();\n                self.map.update_drones(new_locations);\n                let new_cameras = monitoring_app.get_cameras();\n                self.map.update_cameras(new_cameras);\n\n                let incidents = monitoring_app.get_incidents();\n                self.map.update_incidents(incidents);\n                add_camera_window(ui, \u0026mut self.map, monitoring_app);\n                add_incident_window(ui, \u0026mut self.map, monitoring_app);\n                add_drone_window(ui, \u0026mut self.map, monitoring_app);\n                add_drone_center_window(ui, \u0026mut self.map, monitoring_app);\n                add_disconnect_window(ui, \u0026mut self.map, monitoring_app, \u0026mut self.connected);\n                add_remove_window(ui, \u0026mut self.map, monitoring_app)\n            }\n        });\n    }\n}\n\nimpl App for MyApp {\n    fn update(\u0026mut self, ctx: \u0026eframe::egui::Context, _frame: \u0026mut eframe::Frame) {\n        if !self.connected {\n            self.handle_form(ctx, _frame);\n        } else {\n            self.handle_map(ctx, _frame);\n        }\n    }\n}\n\nfn create_my_app(cc: \u0026CreationContext\u003c'_\u003e) -\u003e Box\u003cdyn App\u003e {\n    egui_extras::install_image_loaders(\u0026cc.egui_ctx);\n    let camera_bytes = include_bytes!(\"../assets/Camera.png\");\n    let camera_icon = match Texture::new(camera_bytes, \u0026cc.egui_ctx) {\n        Ok(t) =\u003e ImagesPluginData::new(t, 1.0, 0.1), // Initialize with zoom level 1.0\n        Err(_) =\u003e todo!(),\n    };\n\n    let incident_bytes = include_bytes!(\"../assets/Incident.png\");\n    let incident_icon = match Texture::new(incident_bytes, \u0026cc.egui_ctx) {\n        Ok(t) =\u003e ImagesPluginData::new(t, 1.0, 0.15), // Initialize with zoom level 1.0\n        Err(_) =\u003e todo!(),\n    };\n\n    let drone_bytes = include_bytes!(\"../assets/Drone.png\");\n    let drone_icon = match Texture::new(drone_bytes, \u0026cc.egui_ctx) {\n        Ok(t) =\u003e ImagesPluginData::new(t, 1.0, 0.06), // Initialize with zoom level 1.0\n        Err(_) =\u003e todo!(),\n    };\n\n    let drone_center_bytes = include_bytes!(\"../assets/DroneCenter.png\");\n    let drone_center_icon = match Texture::new(drone_center_bytes, \u0026cc.egui_ctx) {\n        Ok(t) =\u003e ImagesPluginData::new(t, 1.0, 0.1), // Initialize with zoom level 1.0\n        Err(_) =\u003e todo!(),\n    };\n\n    let circle_bytes = include_bytes!(\"../assets/circle.png\");\n    let circle_icon = match Texture::new(circle_bytes, \u0026cc.egui_ctx) {\n        Ok(t) =\u003e ImagesPluginData::new(t, 1.0, 0.2), // Initialize with zoom level 1.0\n        Err(_) =\u003e todo!(),\n    };\n\n    let red_circle_bytes = include_bytes!(\"../assets/red_circle.png\");\n\n    let red_circle_icon = match Texture::new(red_circle_bytes, \u0026cc.egui_ctx) {\n        Ok(t) =\u003e ImagesPluginData::new(t, 1.0, 0.2), // Initialize with zoom level 1.0\n        Err(_) =\u003e todo!(),\n    };\n\n    Box::new(MyApp {\n        username: String::new(),\n        password: String::new(),\n        ip: String::new(),\n        port: String::new(),\n        connected: false,\n        map: MyMap {\n            tiles: Tiles::new(OpenStreetMap, cc.egui_ctx.clone()),\n            map_memory: MapMemory::default(),\n            click_watcher: ClickWatcher::default(),\n            cameras: HashMap::new(),\n            incidents: vec![],\n            camera_icon,\n            incident_icon,\n            camera_radius: circle_icon,\n            active_camera_radius: red_circle_icon,\n            drones: HashMap::new(),\n            drone_icon,\n            drone_centers: vec![],\n            drone_center_icon,\n            zoom_level: 1.0,\n        },\n        monitoring_app: None,\n    })\n}\n\nfn main() {\n    let app_name = \"Rustic City Eye\";\n    let win_options = NativeOptions {\n        ..Default::default()\n    };\n    if let Err(e) = run_native(app_name, win_options, Box::new(|cc| create_my_app(cc))) {\n        eprintln!(\"Error: {}\", e);\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":122},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","monitoring","ui","plugins.rs"],"content":"use std::collections::HashMap;\n\nuse egui::Response;\nuse walkers::{\n    extras::{Image, Images, Texture},\n    Plugin, Position, Projector,\n};\n\nuse crate::{camera_view::CameraView, drone_view::DroneView};\nuse crate::{drone_center_view::DroneCenterView, incident_view::IncidentView};\n\n#[derive(Default, Clone)]\npub struct ClickWatcher {\n    pub clicked_at: Option\u003cPosition\u003e,\n}\n\nimpl ClickWatcher {\n    pub fn show_position(\u0026self, ui: \u0026egui::Ui) {\n        if let Some(clicked_at) = self.clicked_at {\n            egui::Window::new(\"Clicked Position\")\n                .collapsible(false)\n                .resizable(false)\n                .title_bar(false)\n                .anchor(egui::Align2::CENTER_BOTTOM, [0., -10.])\n                .show(ui.ctx(), |ui| {\n                    ui.label(format!(\"{:.04} {:.04}\", clicked_at.lon(), clicked_at.lat()))\n                        .on_hover_text(\"last clicked position\");\n                });\n        }\n    }\n}\n\nimpl Plugin for \u0026mut ClickWatcher {\n    fn run(\u0026mut self, response: \u0026Response, painter: egui::Painter, projector: \u0026Projector) {\n        if !response.changed() \u0026\u0026 response.clicked_by(egui::PointerButton::Primary) {\n            self.clicked_at = response\n                .interact_pointer_pos()\n                .map(|p| projector.unproject(p - response.rect.center()));\n        }\n\n        if let Some(position) = self.clicked_at {\n            painter.circle_filled(\n                projector.project(position).to_pos2(),\n                15.0,\n                egui::Color32::GRAY,\n            );\n        }\n    }\n}\n\n/// Helper structure for the `Images` plugin.\n#[derive(Clone)]\npub struct ImagesPluginData {\n    pub texture: Texture,\n    pub x_scale: f32,\n    pub y_scale: f32,\n}\n\n// Creates a built-in `Images` plugin with an example image.\npub fn cameras(\n    cameras: \u0026mut HashMap\u003cu32, CameraView\u003e,\n    zoom_level: f32,\n    last_clicked: Option\u003cPosition\u003e,\n) -\u003e impl Plugin {\n    let mut images_vec = vec![];\n\n    for camera in cameras.values_mut() {\n        let mut radius = Image::new(camera.radius.texture.clone(), camera.position);\n        radius.scale(\n            camera.radius.x_scale * zoom_level,\n            camera.radius.y_scale * zoom_level,\n        );\n        images_vec.push(radius);\n\n        let mut image = Image::new(camera.image.texture.clone(), camera.position);\n        if camera.select(last_clicked) {\n            image.scale(\n                camera.image.x_scale * zoom_level * 1.5,\n                camera.image.y_scale * zoom_level * 1.5,\n            );\n        } else {\n            image.scale(\n                camera.image.x_scale * zoom_level,\n                camera.image.y_scale * zoom_level,\n            );\n        }\n        images_vec.push(image);\n    }\n    Images::new(images_vec)\n}\n\npub fn incidents(\n    incidents: \u0026mut Vec\u003cIncidentView\u003e,\n    zoom_level: f32,\n    last_clicked: Option\u003cPosition\u003e,\n) -\u003e impl Plugin {\n    let mut images_vec = vec![];\n\n    for incident in incidents {\n        let mut image = Image::new(incident.image.texture.clone(), incident.position);\n\n        if incident.select(last_clicked) {\n            image.scale(\n                incident.image.x_scale * zoom_level * 1.5,\n                incident.image.y_scale * zoom_level * 1.5,\n            );\n        } else {\n            image.scale(\n                incident.image.x_scale * zoom_level,\n                incident.image.y_scale * zoom_level,\n            );\n        }\n        images_vec.push(image);\n    }\n    Images::new(images_vec)\n}\n\npub fn drones(\n    drones: \u0026mut HashMap\u003cu32, DroneView\u003e,\n    zoom_level: f32,\n    last_clicked: Option\u003cPosition\u003e,\n) -\u003e impl Plugin {\n    let mut images_vec = vec![];\n\n    for drone in drones.values_mut() {\n        let mut image = Image::new(drone.image.texture.clone(), drone.position);\n\n        if drone.select(last_clicked) {\n            image.scale(\n                drone.image.x_scale * zoom_level * 1.5,\n                drone.image.y_scale * zoom_level * 1.5,\n            );\n        } else {\n            image.scale(\n                drone.image.x_scale * zoom_level,\n                drone.image.y_scale * zoom_level,\n            );\n        }\n        images_vec.push(image);\n    }\n    Images::new(images_vec)\n}\n\npub fn drone_centers(\n    drone_centers: \u0026mut Vec\u003cDroneCenterView\u003e,\n    zoom_level: f32,\n    last_clicked: Option\u003cPosition\u003e,\n) -\u003e impl Plugin {\n    let mut images_vec = vec![];\n\n    for drone_center in drone_centers {\n        let mut image = Image::new(drone_center.image.texture.clone(), drone_center.position);\n\n        if drone_center.select(last_clicked) {\n            image.scale(\n                drone_center.image.x_scale * zoom_level * 1.5,\n                drone_center.image.y_scale * zoom_level * 1.5,\n            );\n        } else {\n            image.scale(\n                drone_center.image.x_scale * zoom_level,\n                drone_center.image.y_scale * zoom_level,\n            );\n        }\n        images_vec.push(image);\n    }\n    Images::new(images_vec)\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":66},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","monitoring","ui","windows.rs"],"content":"use egui::{Align2, RichText, Ui, Window};\nuse rustic_city_eye::{monitoring::monitoring_app::MonitoringApp, utils::location::Location};\nuse walkers::MapMemory;\n\nuse crate::{\n    camera_view::CameraView, drone_center_view::DroneCenterView, drone_view::DroneView,\n    incident_view::IncidentView, MyMap,\n};\n\n/// Simple GUI to zoom in and out.\n/// Se updatea el zoom level con cada click en los botones de zoom\npub fn zoom(ui: \u0026Ui, map_memory: \u0026mut MapMemory, zoom_level: \u0026mut f32) {\n    Window::new(\"Map\")\n        .collapsible(false)\n        .resizable(false)\n        .title_bar(false)\n        .anchor(Align2::LEFT_BOTTOM, [10., -10.])\n        .show(ui.ctx(), |ui| {\n            ui.horizontal(|ui| {\n                if ui.button(RichText::new(\"➕\").heading()).clicked() {\n                    let _ = map_memory.zoom_in();\n                    *zoom_level *= 2.;\n                }\n\n                if ui.button(RichText::new(\"➖\").heading()).clicked() {\n                    let _ = map_memory.zoom_out();\n                    *zoom_level /= 2.;\n                }\n            });\n        });\n}\n\npub fn add_camera_window(ui: \u0026Ui, map: \u0026mut MyMap, monitoring_app: \u0026mut MonitoringApp) {\n    Window::new(\"Add Camera\")\n        .collapsible(false)\n        .resizable(false)\n        .title_bar(false)\n        .anchor(Align2::RIGHT_TOP, [-10., 10.])\n        .show(ui.ctx(), |ui| {\n            ui.horizontal(|ui| {\n                if ui.button(RichText::new(\"📷\").heading()).clicked() {\n                    if let Some(position) = map.click_watcher.clicked_at {\n                        let location = Location::new(position.lat(), position.lon());\n                        let id = match monitoring_app.add_camera(location) {\n                            Ok(result) =\u003e result,\n                            Err(e) =\u003e {\n                                println!(\"Error adding camera: {}\", e);\n                                return;\n                            }\n                        };\n                        map.cameras.insert(\n                            id,\n                            CameraView {\n                                image: map.camera_icon.clone(),\n                                position,\n                                radius: map.camera_radius.clone(),\n                                clicked: false,\n                            },\n                        );\n                        println!(\"Camera added: {:?}\", position);\n                    }\n                }\n            });\n        });\n}\n\npub fn add_incident_window(ui: \u0026Ui, map: \u0026mut MyMap, monitoring_app: \u0026mut MonitoringApp) {\n    Window::new(\"Add Incident\")\n        .collapsible(false)\n        .resizable(false)\n        .title_bar(false)\n        .anchor(Align2::RIGHT_TOP, [-10., 50.])\n        .show(ui.ctx(), |ui| {\n            ui.horizontal(|ui| {\n                if ui.button(RichText::new(\"🚨\").heading()).clicked() {\n                    if let Some(position) = map.click_watcher.clicked_at {\n                        let location = Location::new(position.lat(), position.lon());\n                        monitoring_app.add_incident(location);\n\n                        map.incidents.push(IncidentView {\n                            image: map.incident_icon.clone(),\n                            position,\n                            clicked: false,\n                        });\n                    }\n                }\n            });\n        });\n}\n\npub fn add_drone_center_window(ui: \u0026Ui, map: \u0026mut MyMap, monitoring_app: \u0026mut MonitoringApp) {\n    Window::new(\"Add Drone Center\")\n        .collapsible(false)\n        .resizable(false)\n        .title_bar(false)\n        .anchor(Align2::RIGHT_TOP, [-10., 90.])\n        .show(ui.ctx(), |ui| {\n            ui.horizontal(|ui| {\n                if ui.button(RichText::new(\"📡\").heading()).clicked() {\n                    if let Some(position) = map.click_watcher.clicked_at {\n                        let location = Location::new(position.lat(), position.lon());\n                        monitoring_app.add_drone_center(location);\n                        map.drone_centers.push(DroneCenterView {\n                            image: map.drone_center_icon.clone(),\n                            position,\n                            clicked: false,\n                        });\n                    }\n                }\n            });\n        });\n}\n\npub fn add_drone_window(ui: \u0026Ui, map: \u0026mut MyMap, monitoring_app: \u0026mut MonitoringApp) {\n    Window::new(\"Add Drone\")\n        .collapsible(false)\n        .resizable(false)\n        .title_bar(false)\n        .anchor(Align2::RIGHT_TOP, [-10., 170.])\n        .show(ui.ctx(), |ui| {\n            ui.horizontal(|ui| {\n                if ui.button(RichText::new(\"🛸\").heading()).clicked() {\n                    if let Some(position) = map.click_watcher.clicked_at {\n                        let location = Location::new(position.lat(), position.lon());\n                        let id = match monitoring_app.add_drone(location, 0) {\n                            Ok(result) =\u003e result,\n                            Err(e) =\u003e {\n                                println!(\"Error adding drone: {}\", e);\n                                return;\n                            }\n                        };\n\n                        map.drones.insert(\n                            id,\n                            DroneView {\n                                image: map.drone_icon.clone(),\n                                position,\n                                clicked: false,\n                                // id,\n                            },\n                        );\n                    }\n                }\n            });\n        });\n}\n\npub fn add_disconnect_window(\n    ui: \u0026Ui,\n    map: \u0026mut MyMap,\n    _monitoring_app: \u0026mut MonitoringApp,\n    connected: \u0026mut bool,\n) {\n    Window::new(\"Disconnect\")\n        .collapsible(false)\n        .resizable(false)\n        .title_bar(false)\n        .anchor(Align2::RIGHT_BOTTOM, [-10., -30.])\n        .show(ui.ctx(), |ui| {\n            ui.horizontal(|ui| {\n                if ui.button(RichText::new(\"Disconnect\").heading()).clicked() {\n                    // monitoring_app.disconnect();    No está implementado?\n                    map.cameras.clear();\n                    map.incidents.clear();\n                    *connected = false;\n                }\n            });\n        });\n}\n\npub fn add_remove_window(ui: \u0026Ui, map: \u0026mut MyMap, _monitoring_app: \u0026mut MonitoringApp) {\n    Window::new(\"Remove\")\n        .collapsible(false)\n        .resizable(false)\n        .title_bar(false)\n        .anchor(Align2::RIGHT_TOP, [-10., 130.])\n        .show(ui.ctx(), |ui| {\n            ui.horizontal(|ui| {\n                if ui\n                    .button(RichText::new(\"🗑\").heading().color(egui::Color32::RED))\n                    .clicked()\n                {\n                    // for camera in \u0026map.cameras {\n                    //     if camera.clicked {\n                    //         let index = map.cameras.iter().position(|c| c.position == position);\n                    //         if let Some(index) = index {\n                    //            // monitoring_app.remove_camera(position);\n                    //         }\n                    //     }\n                    // }\n                    map.cameras.retain(|_id, camera| !camera.clicked);\n\n                    // for incident in \u0026map.incidents {\n                    //     if incident.clicked {\n                    //         let index = map.incidents.iter().position(|i| i.position == position);\n                    //         if let Some(index) = index {\n                    //             map.incidents.remove(index);\n                    //             // monitoring_app.remove_incident(position);\n                    //         }\n                    //     }\n                    // }\n                    map.incidents.retain(|incident| !incident.clicked);\n\n                    map.drones.retain(|_id, drone| !drone.clicked);\n                    // for drone in \u0026map.drones {\n                    //     if drone.clicked {\n                    //         let index = map.drones.iter().position(|d| d.position == position);\n                    //         if let Some(index) = index {\n                    //             map.drones.remove(index);\n                    //             // monitoring_app.remove_drone(id_center, drone_id, location);\n                    //         }\n                    //     }\n                    // }\n                    map.drone_centers\n                        .retain(|drone_center| !drone_center.clicked);\n                }\n            });\n        });\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":97},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","broker.rs"],"content":"use std::{\n    collections::HashMap,\n    fs::File,\n    io::{BufRead, BufReader},\n    net::{TcpListener, TcpStream},\n    sync::{mpsc, Arc, RwLock},\n    thread,\n};\n\nuse crate::mqtt::{\n    broker_message::BrokerMessage,\n    client_message::ClientMessage,\n    connack_properties::ConnackProperties,\n    protocol_error::ProtocolError,\n    protocol_return::ProtocolReturn,\n    reason_code::{SUB_ID_DUP_HEX, SUCCESS_HEX, UNSPECIFIED_ERROR_HEX},\n    subscription::Subscription,\n    topic::Topic,\n};\n\nuse crate::utils::payload_types::PayloadTypes;\nuse crate::utils::threadpool::ThreadPool;\n\nuse super::connect::last_will::LastWill;\n\nstatic SERVER_ARGS: usize = 2;\n\nconst THREADPOOL_SIZE: usize = 20;\n\n#[derive(Clone)]\n#[allow(dead_code)]\npub struct Broker {\n    address: String,\n\n    ///Contiene a todos los Topics.\n    /// Se identifican con un topic_name unico para cada topic.\n    topics: HashMap\u003cString, Topic\u003e,\n\n    /// El u16 corresponde al packet_id del package, y dentro\n    /// de esa clave se guarda el package.\n    packets: Arc\u003cRwLock\u003cHashMap\u003cu16, ClientMessage\u003e\u003e\u003e,\n\n    /// Contiene los clientes conectados al broker.\n\n    /// Contiene los clientes desconectados del broker y sus mensajes pendientes.\n    offline_clients: Arc\u003cRwLock\u003cHashMap\u003cString, Vec\u003cClientMessage\u003e\u003e\u003e\u003e,\n    #[allow(clippy::type_complexity)]\n    clients_ids: Arc\u003cRwLock\u003cHashMap\u003cString, (Option\u003cTcpStream\u003e, Option\u003cLastWill\u003e)\u003e\u003e\u003e,\n\n    /// Los clientes se guardan en un HashMap en el cual\n    /// las claves son los client_ids, y los valores son\n    /// tuplas que contienen el username y password.\n    clients_auth_info: HashMap\u003cString, (String, Vec\u003cu8\u003e)\u003e,\n}\n\nimpl Broker {\n    ///Chequea que el numero de argumentos sea valido.\n    pub fn new(args: Vec\u003cString\u003e) -\u003e Result\u003cBroker, ProtocolError\u003e {\n        if args.len() != SERVER_ARGS {\n            let app_name = \u0026args[0];\n            println!(\"Usage:\\n{:?} \u003cpuerto\u003e\", app_name);\n            return Err(ProtocolError::InvalidNumberOfArguments);\n        }\n\n        let address = \"0.0.0.0:\".to_owned() + \u0026args[1];\n\n        let topics = Broker::get_broker_starting_topics(\"./src/monitoring/topics.txt\")?;\n        let clients_auth_info = Broker::process_clients_file(\"./src/monitoring/clients.txt\")?;\n\n        let packets = HashMap::new();\n\n        Ok(Broker {\n            address,\n            topics,\n            clients_auth_info,\n            packets: Arc::new(RwLock::new(packets)),\n            clients_ids: Arc::new(RwLock::new(HashMap::new())),\n            offline_clients: Arc::new(RwLock::new(HashMap::new())),\n        })\n    }\n\n    pub fn get_broker_starting_topics(\n        file_path: \u0026str,\n    ) -\u003e Result\u003cHashMap\u003cString, Topic\u003e, ProtocolError\u003e {\n        let mut topics = HashMap::new();\n        let topic_readings = Broker::process_topic_config_file(file_path)?;\n\n        for topic in topic_readings {\n            topics.insert(topic, Topic::new());\n        }\n\n        Ok(topics)\n    }\n\n    ///Abro y devuelvo las lecturas del archivo de topics.\n    fn process_topic_config_file(file_path: \u0026str) -\u003e Result\u003cVec\u003cString\u003e, ProtocolError\u003e {\n        let file = match File::open(file_path) {\n            Ok(file) =\u003e file,\n            Err(_) =\u003e return Err(ProtocolError::ReadingTopicConfigFileError),\n        };\n\n        let readings = Broker::read_topic_config_file(\u0026file)?;\n\n        Ok(readings)\n    }\n\n    ///Devuelvo las lecturas que haga en el archivo de topics.\n    fn read_topic_config_file(file: \u0026File) -\u003e Result\u003cVec\u003cString\u003e, ProtocolError\u003e {\n        let reader = BufReader::new(file).lines();\n        let mut readings = Vec::new();\n\n        for line in reader {\n            match line {\n                Ok(line) =\u003e readings.push(line),\n                Err(_err) =\u003e return Err(ProtocolError::ReadingTopicConfigFileError),\n            }\n        }\n\n        Ok(readings)\n    }\n\n    ///Abro y devuelvo las lecturas del archivo de clients.\n    pub fn process_clients_file(\n        file_path: \u0026str,\n    ) -\u003e Result\u003cHashMap\u003cString, (String, Vec\u003cu8\u003e)\u003e, ProtocolError\u003e {\n        let file = match File::open(file_path) {\n            Ok(file) =\u003e file,\n            Err(_) =\u003e return Err(ProtocolError::ReadingClientsFileError),\n        };\n\n        let readings = Broker::read_clients_file(\u0026file)?;\n\n        Ok(readings)\n    }\n\n    ///Devuelvo las lecturas que haga en el archivo de clients.\n    fn read_clients_file(file: \u0026File) -\u003e Result\u003cHashMap\u003cString, (String, Vec\u003cu8\u003e)\u003e, ProtocolError\u003e {\n        let reader = BufReader::new(file).lines();\n        let mut readings = HashMap::new();\n\n        for line in reader.map_while(Result::ok) {\n            let parts: Vec\u003c\u0026str\u003e = line.split(',').collect();\n            if parts.len() == 3 {\n                let client_id = parts[0].trim().to_string();\n                let username = parts[1].trim().to_string();\n                let password = parts[2].trim().to_string().into_bytes();\n                readings.insert(client_id, (username, password));\n            }\n        }\n\n        Ok(readings)\n    }\n\n    /// Ejecuta el servidor.\n    /// Crea un enlace en la dirección del broker y, para\n    /// cada conexión entrante, crea un hilo para manejar el nuevo cliente.\n    pub fn server_run(\u0026mut self) -\u003e std::io::Result\u003c()\u003e {\n        let listener = TcpListener::bind(\u0026self.address)?;\n        println!(\"Broker escuchando en {}\", self.address);\n        let threadpool = ThreadPool::new(THREADPOOL_SIZE);\n\n        for stream in listener.incoming() {\n            match stream {\n                Ok(stream) =\u003e {\n                    let topics_clone = self.topics.clone();\n                    let packets_clone = self.packets.clone();\n                    let clients_auth_info_clone = self.clients_auth_info.clone();\n\n                    let client_id = Arc::new(String::new());\n                    let (id_sender, id_receiver) = mpsc::channel();\n                    threadpool.execute({\n                        let mut client_id: Arc\u003cString\u003e = Arc::clone(\u0026client_id);\n\n                        move || loop {\n                            if let Ok(id) = id_receiver.try_recv() {\n                                let client_id_guard = Arc::make_mut(\u0026mut client_id);\n                                *client_id_guard = id;\n                                break;\n                            }\n                        }\n                    });\n                    let self_clone = self.clone();\n                    threadpool.execute({\n                        let client_id = Arc::clone(\u0026client_id);\n                        let clients_ids_clone = Arc::clone(\u0026self.clients_ids);\n                        let clients_ids_clone2 = Arc::clone(\u0026clients_ids_clone);\n                        let self_ref = Arc::new(self.clone()); // wrap `self` in an Arc\n\n                        move || {\n                            let result = match self_clone.handle_client(\n                                stream,\n                                topics_clone.clone(),\n                                packets_clone,\n                                clients_ids_clone,\n                                clients_auth_info_clone,\n                                id_sender,\n                            ) {\n                                Ok(_) =\u003e Ok(()),\n                                Err(err) =\u003e {\n                                    println!(\"Error en el hilo del cliente, {:?}\", err);\n                                    //busco a ver si hay un will message asociado al cliente\n                                    if err == ProtocolError::StreamError\n                                        || err == ProtocolError::AbnormalDisconnection\n                                    {\n                                        let client_id_guard = client_id;\n                                        #[allow(clippy::type_complexity)]\n                                        let clients_ids_guard: std::sync::RwLockReadGuard\u003c\n                                            HashMap\u003cString, (Option\u003cTcpStream\u003e, Option\u003cLastWill\u003e)\u003e,\n                                        \u003e = match clients_ids_clone2.read() {\n                                            Ok(clients_ids_guard) =\u003e clients_ids_guard,\n                                            Err(_) =\u003e return Err(err),\n                                        };\n                                        if let Some((_, will_message)) =\n                                            clients_ids_guard.get(\u0026*client_id_guard)\n                                        {\n                                            let will_message = match will_message {\n                                                Some(will_message) =\u003e will_message,\n                                                None =\u003e return Err(err),\n                                            };\n                                            let self_clone2 = self_ref.clone();\n                                            self_clone2\n                                                .clone()\n                                                .send_last_will(will_message, topics_clone);\n                                        }\n                                    }\n\n                                    Err(err)\n                                }\n                            };\n                            result\n                        }\n                    });\n                }\n                Err(err) =\u003e return Err(err),\n            }\n        }\n        Ok(())\n    }\n\n    /// Se encarga del manejo de los mensajes del cliente. Envia los ACKs correspondientes.\n    #[allow(clippy::type_complexity)]\n    pub fn handle_client(\n        self,\n        stream: TcpStream,\n        topics: HashMap\u003cString, Topic\u003e,\n        packets: Arc\u003cRwLock\u003cHashMap\u003cu16, ClientMessage\u003e\u003e\u003e,\n        clients_ids: Arc\u003cRwLock\u003cHashMap\u003cString, (Option\u003cTcpStream\u003e, Option\u003cLastWill\u003e)\u003e\u003e\u003e,\n        clients_auth_info: HashMap\u003cString, (String, Vec\u003cu8\u003e)\u003e,\n        id_sender: std::sync::mpsc::Sender\u003cString\u003e,\n    ) -\u003e Result\u003c(), ProtocolError\u003e {\n        println!(\"entre a handle client\");\n        loop {\n            let cloned_stream = match stream.try_clone() {\n                Ok(stream) =\u003e stream,\n                Err(_) =\u003e {\n                    return Err(ProtocolError::StreamError);\n                }\n            };\n            match stream.peek(\u0026mut [0]) {\n                Ok(_) =\u003e {}\n                Err(_) =\u003e return Err(ProtocolError::AbnormalDisconnection),\n            }\n            match self.handle_messages(\n                cloned_stream,\n                topics.clone(),\n                packets.clone(),\n                clients_ids.clone(),\n                clients_auth_info.clone(),\n                id_sender.clone(),\n            ) {\n                Ok(return_val) =\u003e {\n                    if return_val == ProtocolReturn::DisconnectRecieved {\n                        return Ok(());\n                    }\n                }\n                Err(err) =\u003e {\n                    return Err(err);\n                }\n            }\n        }\n    }\n\n    /// Maneja la subscripcion de un cliente a un topic.\n    /// Devuelve el reason code correspondiente a si la subscripcion fue exitosa o no.\n    /// Si el reason code es 0, el cliente se ha suscrito exitosamente.\n    fn handle_subscribe(\n        mut topics: HashMap\u003cString, Topic\u003e,\n        topic_name: String,\n        subscription: Subscription,\n    ) -\u003e Result\u003cu8, ProtocolError\u003e {\n        let reason_code;\n        if let Some(topic) = topics.get_mut(\u0026topic_name) {\n            match topic.add_user_to_topic(subscription) {\n                0 =\u003e {\n                    reason_code = SUCCESS_HEX;\n                }\n                0x92 =\u003e {\n                    reason_code = SUB_ID_DUP_HEX;\n                }\n                _ =\u003e {\n                    reason_code = UNSPECIFIED_ERROR_HEX;\n                }\n            }\n        } else {\n            reason_code = UNSPECIFIED_ERROR_HEX;\n        }\n\n        Ok(reason_code)\n    }\n\n    fn handle_publish(\n        \u0026self,\n        message: ClientMessage,\n        mut topics: HashMap\u003cString, Topic\u003e,\n        topic_name: String,\n    ) -\u003e Result\u003cu8, ProtocolError\u003e {\n        //convert the ClientMessage to ClientMessage:Publish\n        let mensaje = match message.clone() {\n            ClientMessage::Publish {\n                packet_id,\n                topic_name,\n                qos,\n                retain_flag,\n                payload,\n                dup_flag,\n                properties,\n            } =\u003e BrokerMessage::PublishDelivery {\n                packet_id,\n                topic_name,\n                qos,\n                retain_flag,\n                payload,\n                dup_flag,\n                properties,\n            },\n            _ =\u003e return Err(ProtocolError::UnspecifiedError),\n        };\n\n        // verifico si el topic exite\n        if let Some(topic) = topics.get_mut(\u0026topic_name) {\n            //obtengo los users que corresponden a ese topic\n            let users = topic.get_topic_users();\n            println!(\"users subscriptos al topic {:?}\", users);\n            let message_clone = message.clone();\n            for user in users {\n                //verifico si el user esta conectado\n                let mut es_qos_1 = false;\n                let mut esta_offline = false;\n\n                match self.clients_ids.read() {\n                    Ok(clients) =\u003e {\n                        if let Some(tuple) = clients.get(\u0026user.client_id) {\n                            let tuple_clone = tuple;\n                            if let Some(stream) = \u0026tuple_clone.0 {\n                                let mut stream_clone =\n                                    stream.try_clone().expect(\"Failed to clone stream\");\n                                //envio el mensaje al user\n                                match mensaje.write_to(\u0026mut stream_clone) {\n                                    Ok(_) =\u003e {\n                                        println!(\"Mensaje enviado a {}\", user.client_id);\n                                    }\n                                    Err(_) =\u003e {\n                                        // si es qos 1 me guardo el mensaje\n                                        if user.qos == 1 {\n                                            es_qos_1 = true;\n                                        }\n                                    }\n                                }\n                                // si el mensaje es qos 1, envio el ack\n                            }\n                        } else {\n                            match self.offline_clients.read() {\n                                Ok(offline_clients) =\u003e {\n                                    if let Some(_stream) = offline_clients.get(\u0026user.client_id) {\n                                        //guardo el mensaje para enviarlo cuando el user se conecte\n                                        esta_offline = true;\n                                    }\n                                }\n                                Err(_) =\u003e {\n                                    // Manejo de error al leer offline_clients\n                                }\n                            }\n                        }\n                    }\n                    Err(_) =\u003e {\n                        // Manejo de error al leer clients_ids\n                    }\n                }\n\n                if esta_offline \u0026\u0026 es_qos_1 {\n                    if let Ok(mut lock) = self.offline_clients.write() {\n                        if let Some(messages) = lock.get_mut(\u0026user.client_id) {\n                            messages.push(message_clone.clone());\n                        } else {\n                            lock.insert(user.client_id, vec![message_clone.clone()]);\n                        }\n                    } else {\n                        return Ok(0x80_u8);\n                    }\n                }\n            }\n        }\n\n        Ok(0x80_u8) //Unspecified Error reason code\n    }\n\n    /// Maneja la desubscripcion de un cliente a un topic\n    /// Devuelve el reason code correspondiente a si la desubscripcion fue exitosa o no\n    /// Si el reason code es 0, el cliente se ha desuscrito exitosamente.\n    fn handle_unsubscribe(\n        mut topics: HashMap\u003cString, Topic\u003e,\n        topic_name: String,\n        usersubscription: Subscription,\n    ) -\u003e Result\u003cu8, ProtocolError\u003e {\n        let reason_code;\n\n        if let Some(topic) = topics.get_mut(\u0026topic_name) {\n            match topic.remove_user_from_topic(usersubscription) {\n                0 =\u003e {\n                    println!(\"Unsubscribe exitoso\");\n                    reason_code = SUCCESS_HEX;\n                }\n                _ =\u003e {\n                    println!(\"Error no especificado\");\n                    reason_code = UNSPECIFIED_ERROR_HEX;\n                }\n            }\n        } else {\n            println!(\"Error no especificado\");\n            reason_code = UNSPECIFIED_ERROR_HEX;\n        }\n        println!(\"reason code {:?}\", reason_code);\n\n        Ok(reason_code)\n    }\n\n    ///Se toma un packet con su respectivo ID y se lo guarda en el hashmap de mensajes que tiene el Broker.\n    fn save_packet(\n        packets: Arc\u003cRwLock\u003cHashMap\u003cu16, ClientMessage\u003e\u003e\u003e,\n        message: ClientMessage,\n        packet_id: u16,\n    ) {\n        let mut lock = match packets.write() {\n            Ok(lock) =\u003e lock,\n            Err(_) =\u003e return,\n        };\n\n        lock.insert(packet_id, message);\n    }\n\n    /// Envia el mensaje de Last Will al cliente.\n    ///\n    /// Se encarga de la logica necesaria segun los parametros del Last Will y sus properties\n    ///\n    /// Si hay un delay en el envio del mensaje (delay_interval), se encarga de esperar el tiempo correspondiente.\n    ///\n    /// Convierte el mensaje en un Publish y lo envia al broker.\n    fn send_last_will(\u0026self, will_message: \u0026LastWill, topics: HashMap\u003cString, Topic\u003e) {\n        let properties = will_message.get_properties();\n        let interval = properties.get_last_will_delay_interval();\n        thread::sleep(std::time::Duration::from_secs(interval as u64));\n        let will_topic = will_message.get_topic();\n        let message = will_message.get_message();\n        let will_qos = will_message.get_qos();\n        let will_retain = will_message.get_retain();\n\n        let will_payload = PayloadTypes::WillPayload(message.to_string());\n\n        //publish\n        let will_publish = ClientMessage::Publish {\n            packet_id: 0,\n            topic_name: will_topic.to_string(), //TODO: aca habria que ver bien cual topic le cargamos\n            qos: will_qos as usize,\n            retain_flag: will_retain as usize,\n            payload: will_payload,\n            dup_flag: 0,\n            properties: will_message\n                .get_properties()\n                .clone()\n                .to_publish_properties(),\n        };\n        _ = self.handle_publish(will_publish, topics, will_topic.to_string());\n    }\n\n    /// Lee del stream un mensaje y lo procesa\n    /// Devuelve un ProtocolReturn con informacion del mensaje recibido\n    /// O ProtocolError en caso de erro    #[allow(clippy::type_complexity)]\n    #[allow(clippy::type_complexity)]\n    pub fn handle_messages(\n        \u0026self,\n        mut stream: TcpStream,\n        topics: HashMap\u003cString, Topic\u003e,\n        packets: Arc\u003cRwLock\u003cHashMap\u003cu16, ClientMessage\u003e\u003e\u003e,\n        _clients_ids: Arc\u003cRwLock\u003cHashMap\u003cString, (Option\u003cTcpStream\u003e, Option\u003cLastWill\u003e)\u003e\u003e\u003e,\n        clients_auth_info: HashMap\u003cString, (String, Vec\u003cu8\u003e)\u003e,\n        _id_sender: std::sync::mpsc::Sender\u003cString\u003e,\n    ) -\u003e Result\u003cProtocolReturn, ProtocolError\u003e {\n        let mensaje = match ClientMessage::read_from(\u0026mut stream) {\n            Ok(mensaje) =\u003e mensaje,\n            Err(e) =\u003e {\n                println!(\"Error al leer mensaje: {:?}\", e);\n                return Err(ProtocolError::StreamError);\n            }\n        };\n\n        match mensaje {\n            ClientMessage::Connect { 0: connect } =\u003e {\n                println!(\"Recibí un Connect\");\n\n                // si el cliente ya está conectado, no permite la nueva conexión y la rechaza con CLIENT_DUP\n                match self.clients_ids.read() {\n                    Ok(clients) =\u003e {\n                        if clients.contains_key(\u0026connect.client_id) {\n                            let disconnect = BrokerMessage::Disconnect {\n                                reason_code: 0,\n                                session_expiry_interval: 0,\n                                reason_string: \"CLIENT_DUP\".to_string(),\n                                user_properties: Vec::new(),\n                            };\n\n                            match disconnect.write_to(\u0026mut stream) {\n                                Ok(_) =\u003e {\n                                    println!(\"Disconnect enviado\");\n                                    return Ok(ProtocolReturn::DisconnectSent);\n                                }\n                                Err(err) =\u003e println!(\"Error al enviar Disconnect: {:?}\", err),\n                            }\n                        }\n                    }\n                    Err(_) =\u003e {\n                        // Manejo de error al leer clients_ids\n                    }\n                }\n                // reibe los mensajes de cuando estuvo offline\n                if let Ok(offline_clients) = self.offline_clients.read() {\n                    if offline_clients.contains_key(\u0026connect.client_id) {\n                        if let Some(pending_messages) = offline_clients.get(\u0026connect.client_id) {\n                            for message in pending_messages {\n                                match message.write_to(\u0026mut stream) {\n                                    Ok(_) =\u003e {\n                                        println!(\"Mensaje enviado a {}\", connect.client_id);\n                                    }\n                                    Err(_) =\u003e return Err(ProtocolError::UnspecifiedError),\n                                }\n                            }\n                        }\n                    }\n                }\n\n                //si está en offline_clients lo elimino de ahí\n                if let Ok(mut lock) = self.offline_clients.write() {\n                    lock.remove(\u0026connect.client_id);\n                } else {\n                    return Err(ProtocolError::UnspecifiedError);\n                }\n\n                //clona stream con ok err\n                let cloned_stream = match stream.try_clone() {\n                    Ok(stream) =\u003e stream,\n                    Err(_) =\u003e return Err(ProtocolError::StreamError),\n                };\n\n                let will_message = connect.clone().give_will_message();\n                if let Ok(mut clients) = self.clients_ids.write() {\n                    clients.insert(\n                        connect.client_id.clone(),\n                        (Some(cloned_stream), will_message),\n                    );\n                } else {\n                    return Err(ProtocolError::UnspecifiedError);\n                }\n\n                let connect_clone = connect.clone();\n                let _connack_reason_code = match authenticate_client(\n                    connect_clone.properties.authentication_method,\n                    connect_clone.client_id,\n                    connect_clone.username,\n                    connect_clone.password,\n                    clients_auth_info,\n                ) {\n                    Ok(r) =\u003e r,\n                    Err(e) =\u003e return Err(e),\n                };\n\n                let properties = ConnackProperties {\n                    session_expiry_interval: 0,\n                    receive_maximum: 0,\n                    maximum_packet_size: 0,\n                    topic_alias_maximum: 0,\n                    user_properties: Vec::new(),\n                    authentication_method: \"none\".to_string(),\n                    authentication_data: Vec::new(),\n                    assigned_client_identifier: \"none\".to_string(),\n                    maximum_qos: true,\n                    reason_string: \"none\".to_string(),\n                    wildcard_subscription_available: false,\n                    subscription_identifier_available: false,\n                    shared_subscription_available: false,\n                    server_keep_alive: 0,\n                    response_information: \"none\".to_string(),\n                    server_reference: \"none\".to_string(),\n                    retain_available: false,\n                };\n                let connack = BrokerMessage::Connack {\n                    session_present: false,\n                    reason_code: 0,\n                    properties,\n                };\n                println!(\"Enviando un Connack\");\n                match connack.write_to(\u0026mut stream) {\n                    Ok(_) =\u003e return Ok(ProtocolReturn::ConnackSent),\n                    Err(err) =\u003e {\n                        println!(\"{:?}\", err);\n                    }\n                }\n            }\n            ClientMessage::Publish {\n                packet_id,\n                topic_name,\n                qos,\n                retain_flag,\n                payload,\n                dup_flag,\n                properties,\n            } =\u003e {\n                println!(\"Recibí un Publish\");\n                println!(\"Topic name: {}\", topic_name);\n                println!(\"Payload: {:?}\", payload);\n                let msg = ClientMessage::Publish {\n                    packet_id,\n                    topic_name: topic_name.clone(),\n                    qos,\n                    retain_flag,\n                    payload: payload.clone(),\n                    dup_flag,\n                    properties,\n                };\n                Broker::save_packet(packets.clone(), msg.clone(), packet_id);\n\n                let packet_id_bytes: [u8; 2] = packet_id.to_be_bytes();\n\n                let reason_code = self.handle_publish(msg, topics.clone(), topic_name)?;\n                if qos == 1 {\n                    let puback = BrokerMessage::Puback {\n                        packet_id_msb: packet_id_bytes[0],\n                        packet_id_lsb: packet_id_bytes[1],\n                        reason_code,\n                    };\n                    println!(\"Enviando un Puback\");\n                    match puback.write_to(\u0026mut stream) {\n                        Ok(_) =\u003e {\n                            println!(\"Puback enviado\");\n                            return Ok(ProtocolReturn::PubackSent);\n                        }\n                        Err(err) =\u003e println!(\"Error al enviar Puback: {:?}\", err),\n                    }\n                } else {\n                    return Ok(ProtocolReturn::NoAckSent);\n                }\n            }\n            ClientMessage::Subscribe {\n                packet_id,\n                properties,\n                payload,\n            } =\u003e {\n                println!(\"Recibí un Subscribe\");\n                let msg = ClientMessage::Subscribe {\n                    packet_id,\n                    properties: properties.clone(),\n                    payload: payload.clone(),\n                };\n                Broker::save_packet(packets.clone(), msg, packet_id);\n\n                let packet_id_bytes: [u8; 2] = packet_id.to_be_bytes();\n\n                let mut reason_code_vec = Vec::new();\n\n                for p in payload {\n                    let reason_code =\n                        Broker::handle_subscribe(topics.clone(), p.topic.clone(), p.clone())?;\n\n                    reason_code_vec.push(reason_code);\n                }\n\n                if reason_code_vec.iter().any(|\u0026x| x != SUCCESS_HEX) {\n                    let suback = BrokerMessage::Suback {\n                        packet_id_msb: packet_id_bytes[0],\n                        packet_id_lsb: packet_id_bytes[1],\n                        reason_code: UNSPECIFIED_ERROR_HEX,\n                    };\n                    println!(\"Enviando un Suback\");\n                    match suback.write_to(\u0026mut stream) {\n                        Ok(_) =\u003e {\n                            println!(\"Suback enviado\");\n                            return Ok(ProtocolReturn::SubackSent);\n                        }\n                        Err(err) =\u003e println!(\"Error al enviar suback: {:?}\", err),\n                    }\n                }\n\n                let suback = BrokerMessage::Suback {\n                    packet_id_msb: packet_id_bytes[0],\n                    packet_id_lsb: packet_id_bytes[1],\n                    reason_code: SUCCESS_HEX,\n                };\n                println!(\"Enviando un Suback\");\n                match suback.write_to(\u0026mut stream) {\n                    Ok(_) =\u003e {\n                        println!(\"Suback enviado\");\n                        return Ok(ProtocolReturn::SubackSent);\n                    }\n                    Err(err) =\u003e println!(\"Error al enviar suback: {:?}\", err),\n                }\n\n                return Ok(ProtocolReturn::SubackSent);\n            }\n            ClientMessage::Unsubscribe {\n                packet_id,\n                properties,\n                payload,\n            } =\u003e {\n                println!(\"Recibí un Unsubscribe\");\n                let msg = ClientMessage::Unsubscribe {\n                    packet_id,\n                    properties: properties.clone(),\n                    payload: payload.clone(),\n                };\n                Broker::save_packet(packets.clone(), msg, packet_id);\n\n                let packet_id_bytes: [u8; 2] = packet_id.to_be_bytes();\n\n                let mut reason_code_vec = Vec::new();\n\n                for p in payload {\n                    let reason_code =\n                        Broker::handle_unsubscribe(topics.clone(), p.topic.clone(), p.clone())?;\n                    reason_code_vec.push(reason_code);\n                }\n\n                if reason_code_vec.iter().any(|\u0026x| x != SUCCESS_HEX) {\n                    let suback = BrokerMessage::Suback {\n                        packet_id_msb: packet_id_bytes[0],\n                        packet_id_lsb: packet_id_bytes[1],\n                        reason_code: UNSPECIFIED_ERROR_HEX,\n                    };\n                    println!(\"Enviando un Suback\");\n                    match suback.write_to(\u0026mut stream) {\n                        Ok(_) =\u003e {\n                            println!(\"Suback enviado\");\n                            return Ok(ProtocolReturn::SubackSent);\n                        }\n                        Err(err) =\u003e println!(\"Error al enviar suback: {:?}\", err),\n                    }\n                }\n\n                let unsuback = BrokerMessage::Unsuback {\n                    packet_id_msb: packet_id_bytes[0],\n                    packet_id_lsb: packet_id_bytes[1],\n                    reason_code: SUCCESS_HEX,\n                };\n                println!(\"Enviando un Unsuback\");\n                match unsuback.write_to(\u0026mut stream) {\n                    Ok(_) =\u003e {\n                        println!(\"Unsuback enviado\");\n                        return Ok(ProtocolReturn::UnsubackSent);\n                    }\n                    Err(err) =\u003e println!(\"Error al enviar Unsuback: {:?}\", err),\n                }\n            }\n\n            ClientMessage::Disconnect {\n                reason_code: _,\n                session_expiry_interval: _,\n                reason_string,\n                client_id,\n            } =\u003e {\n                println!(\n                    \"Recibí un Disconnect, razon de desconexión: {:?}\",\n                    reason_string\n                );\n\n                if reason_string == \"CLIENT_DUP\" {\n                    return Ok(ProtocolReturn::DisconnectRecieved);\n                }\n\n                // elimino el client_id de clients_ids\n                if let Ok(mut lock) = self.clients_ids.write() {\n                    lock.remove(\u0026client_id);\n                } else {\n                    return Err(ProtocolError::UnspecifiedError);\n                }\n\n                // agrego el client_id a offline_clients\n                if let Ok(mut lock) = self.offline_clients.write() {\n                    lock.insert(client_id, Vec::new());\n                } else {\n                    return Err(ProtocolError::UnspecifiedError);\n                }\n\n                return Ok(ProtocolReturn::DisconnectRecieved);\n            }\n            ClientMessage::Pingreq =\u003e {\n                println!(\"Recibí un Pingreq\");\n                let pingresp = BrokerMessage::Pingresp;\n                println!(\"Enviando un Pingresp\");\n                match pingresp.write_to(\u0026mut stream) {\n                    Ok(_) =\u003e {\n                        println!(\"Pingresp enviado\");\n                        return Ok(ProtocolReturn::PingrespSent);\n                    }\n                    Err(err) =\u003e println!(\"Error al enviar Pingresp: {:?}\", err),\n                }\n            }\n            ClientMessage::Auth {\n                reason_code: _,\n                authentication_method,\n                authentication_data,\n                reason_string,\n                user_properties,\n            } =\u003e {\n                println!(\"Recibi un auth\");\n\n                match authentication_method.as_str() {\n                    \"password-based\" =\u003e return Ok(ProtocolReturn::AuthRecieved),\n                    _ =\u003e {\n                        let properties = ConnackProperties {\n                            session_expiry_interval: 0,\n                            receive_maximum: 0,\n                            maximum_packet_size: 0,\n                            topic_alias_maximum: 0,\n                            user_properties,\n                            authentication_method,\n                            authentication_data,\n                            assigned_client_identifier: \"none\".to_string(),\n                            maximum_qos: true,\n                            reason_string,\n                            wildcard_subscription_available: false,\n                            subscription_identifier_available: false,\n                            shared_subscription_available: false,\n                            server_keep_alive: 0,\n                            response_information: \"none\".to_string(),\n                            server_reference: \"none\".to_string(),\n                            retain_available: false,\n                        };\n\n                        let connack = BrokerMessage::Connack {\n                            session_present: false,\n                            reason_code: 0x8C, //Bad auth method\n                            properties,\n                        };\n                        println!(\"Parece que intentaste autenticarte con un metodo no soportado por el broker :(\");\n\n                        match connack.write_to(\u0026mut stream) {\n                            Ok(_) =\u003e return Ok(ProtocolReturn::ConnackSent),\n                            Err(err) =\u003e {\n                                println!(\"{:?}\", err);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        Err(ProtocolError::UnspecifiedError)\n    }\n\n    /// Devuelve los clientes offline y sus mensajes pendientes de manera estática\n    /// para poder testear\n    pub fn get_offline_clients(\u0026self) -\u003e HashMap\u003cString, Vec\u003cClientMessage\u003e\u003e {\n        match self.offline_clients.read() {\n            Ok(lock) =\u003e lock.clone(),\n            Err(_) =\u003e HashMap::new(),\n        }\n    }\n\n    /// Devuelve los clientes conectados de manera estática\n    /// para poder testear\n    pub fn get_clients_ids(\u0026self) -\u003e Vec\u003cString\u003e {\n        let mut clients_ids = Vec::new();\n        let lock = match self.clients_ids.read() {\n            Ok(lock) =\u003e lock,\n            Err(_) =\u003e return clients_ids,\n        };\n        for client_id in lock.keys() {\n            // agrego el client_id al vector\n            clients_ids.push(client_id.clone());\n        }\n\n        clients_ids\n    }\n}\n\n/// Aca se realiza la autenticacion del cliente. Solo se debe llamar apenas llega un packet del tipo\n/// Connect.\n///\n/// Le ingresan como parametros el auth_method(solo vamos a soportar el metodo password-based),\n/// el username, client_id y password que vienen definidos en el packet Connect que envia el usuario.\n///\n/// Devuele en caso exitoso un u8 que representa el reason code del packet Connack que el Broker va a\n/// enviarle al Client.\npub fn authenticate_client(\n    authentication_method: String,\n    client_id: String,\n    username: Option\u003cString\u003e,\n    password: Option\u003cVec\u003cu8\u003e\u003e,\n    clients_auth_info: HashMap\u003cString, (String, Vec\u003cu8\u003e)\u003e,\n) -\u003e Result\u003cu8, ProtocolError\u003e {\n    let mut connack_reason_code = 0x00_u8; //success :D\n\n    match authentication_method.as_str() {\n        \"password-based\" =\u003e {\n            match clients_auth_info.get(\u0026client_id) {\n                Some(value) =\u003e {\n                    if let (Some(username), Some(password)) = (username, password) {\n                        if value == \u0026(username, password) {\n                            return Ok(connack_reason_code);\n                        }\n                        connack_reason_code = 0x86_u8; //bad username or password\n                    } else {\n                        connack_reason_code = 0x86_u8;\n                    }\n                }\n                None =\u003e connack_reason_code = 0x85_u8, //client_id not valid\n            }\n        }\n        _ =\u003e connack_reason_code = 0x8C_u8,\n    }\n    Ok(connack_reason_code)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n    use std::sync::{Arc, RwLock};\n    use std::thread;\n\n    // #[test]\n    // fn test_01_creating_broker_config_ok() -\u003e std::io::Result\u003c()\u003e {\n    //     let topics = match Broker::get_broker_starting_topics(\"./src/monitoring/topics.txt\") {\n    //         Ok(topics) =\u003e topics,\n    //         Err(_) =\u003e return Err(std::io::Error::new(std::io::ErrorKind::Other, \"Error\")),\n    //     };\n    //     let clients_auth_info = match Broker::process_clients_file(\"./src/monitoring/clients.txt\") {\n    //         Ok(clients_auth_info) =\u003e clients_auth_info,\n    //         Err(_) =\u003e return Err(std::io::Error::new(std::io::ErrorKind::Other, \"Error\")),\n    //     };\n\n    //     let mut expected_topics = HashMap::new();\n    //     let mut expected_clients = HashMap::new();\n\n    //     expected_topics.insert(\"accidente\".to_string(), Topic::new());\n    //     expected_topics.insert(\"mensajes para juan\".to_string(), Topic::new());\n    //     expected_topics.insert(\"messi\".to_string(), Topic::new());\n    //     expected_topics.insert(\"fulbito\".to_string(), Topic::new());\n    //     expected_topics.insert(\"incidente\".to_string(), Topic::new());\n\n    //     expected_clients.insert(\n    //         \"monitoring_app\".to_string(),\n    //         (\n    //             \"monitoreo\".to_string(),\n    //             \"monitoreando_la_vida2004\".to_string().into_bytes(),\n    //         ),\n    //     );\n\n    //     expected_clients.insert(\n    //         \"camera_system\".to_string(),\n    //         (\n    //             \"sistema_camaras\".to_string(),\n    //             \"CamareandoCamaritasForever\".to_string().into_bytes(),\n    //         ),\n    //     );\n\n    //     let topics_to_check = vec![\n    //         \"accidente\",\n    //         \"mensajes para juan\",\n    //         \"messi\",\n    //         \"fulbito\",\n    //         \"incidente\",\n    //     ];\n\n    //     for topic in topics_to_check {\n    //         assert!(topics.contains_key(topic));\n    //     }\n\n    //     assert_eq!(expected_clients, clients_auth_info);\n\n    //     Ok(())\n    // }\n\n    #[test]\n    fn test_02_reading_config_files_err() {\n        let topics: Result\u003cHashMap\u003cString, Topic\u003e, ProtocolError\u003e =\n            Broker::get_broker_starting_topics(\"./aca/estan/los/topics\");\n        let clients_auth_info = Broker::process_clients_file(\"./ahperoacavanlosclientesno\");\n\n        assert!(topics.is_err());\n        assert!(clients_auth_info.is_err());\n    }\n\n    #[test]\n    fn test_handle_client() {\n        // Set up a listener on a local port.\n        let listener = match TcpListener::bind(\"127.0.0.1:0\") {\n            Ok(listener) =\u003e listener,\n            Err(_) =\u003e return,\n        };\n        let addr = match listener.local_addr() {\n            Ok(addr) =\u003e addr,\n            Err(_) =\u003e return,\n        };\n\n        // Spawn a thread to simulate a client.\n        thread::spawn(move || {\n            let mut stream = match TcpStream::connect(addr) {\n                Ok(stream) =\u003e stream,\n                Err(_) =\u003e return,\n            };\n            if stream.write_all(b\"Hello, world!\").is_ok() {}\n        });\n        let packets = Arc::new(RwLock::new(HashMap::new()));\n        let clients_ids = Arc::new(RwLock::new(HashMap::new()));\n        let clients_auth_info = HashMap::new();\n        let topics = HashMap::new();\n        // Write a ClientMessage to the stream.\n        // You'll need to replace this with a real ClientMessage.\n        let mut result: Result\u003c(), ProtocolError\u003e = Err(ProtocolError::UnspecifiedError);\n        let broker = match Broker::new(vec![\"127.0.0.1\".to_string(), \"5000\".to_string()]) {\n            Ok(broker) =\u003e broker,\n            Err(_) =\u003e return,\n        };\n\n        // Accept the connection and pass the stream to the function.\n        if let Ok((stream, _)) = listener.accept() {\n            let (id_sender, _) = mpsc::channel();\n            // Perform your assertions here\n            result = broker.handle_client(\n                stream,\n                topics,\n                packets,\n                clients_ids,\n                clients_auth_info,\n                id_sender,\n            );\n        }\n\n        // Check that the function returned Ok.\n        // You might want to add more checks here, depending on what\n        // handle_client is supposed to do.\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":140},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1104},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":345},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":139},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":759},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":345},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":139},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":207},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":414},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":207},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":207},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":207},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":207},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":21214132},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":134},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":179},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":662,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":672,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":674,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":710,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":746,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":747,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":749,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":764,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":775,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":806,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":808,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":809,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":820,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":856,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":863,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":870,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":871,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":877,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":879,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":881,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":883,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":888,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":900,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":907,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":910,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":914,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":915,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":919,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":922,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":927,"address":[],"length":0,"stats":{"Line":25},"fn_name":null}],"covered":233,"coverable":348},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","broker_message.rs"],"content":"use std::io::{BufWriter, Error, ErrorKind, Read, Write};\n\nuse crate::{\n    utils::payload_types::PayloadTypes,\n    utils::{reader::*, writer::*},\n};\n\nconst SESSION_EXPIRY_INTERVAL_ID: u8 = 0x11;\nconst REASON_STRING_ID: u8 = 0x1F;\nconst USER_PROPERTY_ID: u8 = 0x26;\nuse super::{\n    connack_properties::ConnackProperties, payload::Payload, protocol_error::ProtocolError,\n    publish::publish_properties::PublishProperties,\n};\nuse crate::utils::{\n    reader::{read_string, read_u8},\n    writer::{write_string, write_u8},\n};\n\n#[derive(Debug, PartialEq)]\npub enum BrokerMessage {\n    Connack {\n        session_present: bool,\n        reason_code: u8,\n        properties: ConnackProperties,\n    },\n\n    /// Puback es la respuesta a un Publish packet con QoS 1.\n    Puback {\n        packet_id_msb: u8,\n        packet_id_lsb: u8,\n        reason_code: u8,\n    },\n    /// El Suback se utiliza para confirmar la suscripción a un topic\n    ///\n    /// reason_code es el código de razón de la confirmación\n    /// packet_id_msb y packet_id_lsb son los bytes más significativos y menos significativos del packet_id\n    Suback {\n        /// packet_id_msb es el byte más significativo del packet_id\n        packet_id_msb: u8,\n        /// packet_id_lsb es el byte menos significativo del packet_id\n        packet_id_lsb: u8,\n        /// reason_code es el código de razón de la confirmación\n        reason_code: u8,\n    },\n    PublishDelivery {\n        packet_id: u16,\n        topic_name: String,\n        qos: usize,\n        retain_flag: usize,\n        payload: PayloadTypes,\n        dup_flag: usize,\n        properties: PublishProperties,\n    },\n    Unsuback {\n        packet_id_msb: u8,\n        packet_id_lsb: u8,\n        reason_code: u8,\n    },\n    Disconnect {\n        reason_code: u8,\n        session_expiry_interval: u32,\n        reason_string: String,\n        user_properties: Vec\u003c(String, String)\u003e,\n    },\n    Pingresp,\n\n    /// Sirve para autenticar usuarios. Tanto el Broker como el Client pueden enviar estos packets(van a ser iguales).\n    ///\n    /// La idea es utilizar propiedades que se definen dentro de los packets del tipo Connect, y poder realizar la\n    /// autenticacion correctamente.\n    Auth {\n        /// Nos indica el estado de nuestra autenticacion.\n        reason_code: u8,\n\n        /// Indica el metodo de autenticacion a seguir.\n        authentication_method: String,\n\n        /// Contiene data binaria sobre la autenticacion.\n        authentication_data: Vec\u003cu8\u003e,\n\n        /// Aca se muestra mas a detalle la razon de la desconexion. La idea es mostrarle\n        /// al usuario a traves de un texto legible el por que el broker decidio desconectarlo.\n        reason_string: String,\n\n        /// Para diagnosticos e informacion adicionales.\n        user_properties: Vec\u003c(String, String)\u003e,\n    },\n}\n#[allow(dead_code)]\nimpl BrokerMessage {\n    pub fn write_to(\u0026self, stream: \u0026mut dyn Write) -\u003e Result\u003c(), ProtocolError\u003e {\n        let mut writer = BufWriter::new(stream);\n        match self {\n            BrokerMessage::Connack {\n                session_present,\n                reason_code,\n                properties,\n            } =\u003e {\n                let byte_1: u8 = 0x20_u8.to_le(); //00100000\n                let _ = writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_| ProtocolError::WriteError);\n\n                write_bool(\u0026mut writer, session_present)?;\n                write_u8(\u0026mut writer, reason_code)?;\n                properties.write_to(\u0026mut writer)?;\n                let _ = writer.flush().map_err(|_| ProtocolError::WriteError);\n\n                Ok(())\n            }\n            BrokerMessage::Puback {\n                packet_id_msb,\n                packet_id_lsb,\n                reason_code,\n            } =\u003e {\n                //fixed header\n                let byte_1: u8 = 0x40_u8.to_le(); //01000000\n\n                let _ = writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_| ProtocolError::WriteError);\n\n                //variable header\n                //packet_id\n                write_u8(\u0026mut writer, packet_id_msb)?;\n                write_u8(\u0026mut writer, packet_id_lsb)?;\n\n                //reason code\n                write_u8(\u0026mut writer, reason_code)?;\n\n                let _ = writer.flush().map_err(|_e| ProtocolError::WriteError);\n\n                Ok(())\n            }\n            BrokerMessage::Suback {\n                packet_id_msb,\n                packet_id_lsb,\n                reason_code,\n            } =\u003e {\n                //fixed header\n                let byte_1: u8 = 0x90_u8.to_le(); //10010000\n\n                let _ = writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError);\n\n                write_u8(\u0026mut writer, packet_id_msb)?;\n                write_u8(\u0026mut writer, packet_id_lsb)?;\n\n                //reason code\n                write_u8(\u0026mut writer, reason_code)?;\n\n                //sub_id\n                let _ = writer.flush().map_err(|_e| ProtocolError::WriteError);\n\n                Ok(())\n            }\n            BrokerMessage::PublishDelivery {\n                packet_id,\n                topic_name,\n                qos,\n                retain_flag,\n                payload,\n                dup_flag,\n                properties,\n            } =\u003e {\n                //fixed header -\u003e es uno de juguete, hay que pensarlo mejor\n                let byte_1: u8 = 0x00_u8.to_le();\n                let _ = writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError);\n\n                //variable header\n                //packet_id\n                write_u8(\u0026mut writer, \u0026packet_id.to_be_bytes()[0])?;\n                write_u8(\u0026mut writer, \u0026packet_id.to_be_bytes()[1])?;\n\n                //topic_name\n                write_string(\u0026mut writer, topic_name)?;\n\n                //qos\n                write_u8(\u0026mut writer, \u0026qos.to_be_bytes()[0])?;\n\n                //retain_flag\n                write_u8(\u0026mut writer, \u0026retain_flag.to_be_bytes()[0])?;\n\n                //payload\n                payload.write_to(\u0026mut writer)?;\n                // write_string(\u0026mut writer, payload)?;\n\n                //dup_flag\n                write_u8(\u0026mut writer, \u0026dup_flag.to_be_bytes()[0])?;\n\n                //properties\n                properties.write_properties(\u0026mut writer)?;\n\n                let _ = writer.flush().map_err(|_e| ProtocolError::WriteError);\n\n                Ok(())\n            }\n            BrokerMessage::Unsuback {\n                packet_id_msb,\n                packet_id_lsb,\n                reason_code,\n            } =\u003e {\n                //fixed header\n                let byte_1: u8 = 0xB0_u8.to_le(); //10110000\n\n                let _ = writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError);\n\n                //variable header\n                //packet_id\n                write_u8(\u0026mut writer, packet_id_msb)?;\n                write_u8(\u0026mut writer, packet_id_lsb)?;\n                write_u8(\u0026mut writer, reason_code)?;\n\n                let _ = writer.flush().map_err(|_e| ProtocolError::WriteError);\n\n                Ok(())\n            }\n            BrokerMessage::Disconnect {\n                reason_code,\n                session_expiry_interval,\n                reason_string,\n                user_properties,\n            } =\u003e {\n                //fixed header\n                let header: u8 = 0xE0_u8.to_le(); //11100000\n                write_u8(\u0026mut writer, \u0026header)?;\n                //variable_header\n                write_u8(\u0026mut writer, reason_code)?;\n\n                write_u8(\u0026mut writer, \u0026SESSION_EXPIRY_INTERVAL_ID)?;\n                write_u32(\u0026mut writer, session_expiry_interval)?;\n\n                write_u8(\u0026mut writer, \u0026REASON_STRING_ID)?;\n                write_string(\u0026mut writer, reason_string)?;\n\n                write_u8(\u0026mut writer, \u0026USER_PROPERTY_ID)?;\n                write_string_pairs(\u0026mut writer, user_properties)?;\n                let _ = writer.flush().map_err(|_e| ProtocolError::WriteError);\n                Ok(())\n            }\n            BrokerMessage::Pingresp =\u003e {\n                let byte_1: u8 = 0xD0_u8.to_le();\n                let _ = writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError);\n                let _ = writer.flush().map_err(|_e| ProtocolError::WriteError);\n\n                Ok(())\n            }\n            BrokerMessage::Auth {\n                reason_code,\n                authentication_method,\n                authentication_data,\n                reason_string,\n                user_properties,\n            } =\u003e {\n                let byte_1 = 0xF0_u8;\n                let _ = writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError);\n\n                write_u8(\u0026mut writer, reason_code)?;\n\n                let authentication_method_id: u8 = 0x15_u8;\n                let _ = writer\n                    .write_all(\u0026[authentication_method_id])\n                    .map_err(|_e| ProtocolError::WriteError);\n                write_string(\u0026mut writer, authentication_method)?;\n\n                let authentication_data_id: u8 = 0x16_u8;\n                let _ = writer\n                    .write_all(\u0026[authentication_data_id])\n                    .map_err(|_e| ProtocolError::WriteError);\n                write_bin_vec(\u0026mut writer, authentication_data)?;\n\n                let reason_string_id: u8 = 0x1F_u8;\n                let _ = writer\n                    .write_all(\u0026[reason_string_id])\n                    .map_err(|_e| ProtocolError::WriteError);\n                write_string(\u0026mut writer, reason_string)?;\n\n                let user_properties_id: u8 = 0x26_u8; // 38\n                let _ = writer\n                    .write_all(\u0026[user_properties_id])\n                    .map_err(|_e| ProtocolError::WriteError);\n                write_tuple_vec(\u0026mut writer, user_properties)?;\n\n                let _ = writer.flush().map_err(|_e| ProtocolError::WriteError);\n\n                Ok(())\n            }\n        }\n    }\n\n    pub fn read_from(stream: \u0026mut dyn Read) -\u003e Result\u003cBrokerMessage, Error\u003e {\n        let mut header = [0u8; 1];\n        stream.read_exact(\u0026mut header)?;\n        let header = u8::from_le_bytes(header);\n\n        match header {\n            0x00 =\u003e {\n                let packet_id_msb = read_u8(stream)?;\n                let packet_id_lsb = read_u8(stream)?;\n                let topic_name = read_string(stream)?;\n                let qos = read_u8(stream)? as usize;\n                let retain_flag = read_u8(stream)? as usize;\n                let payload = PayloadTypes::read_from(stream)?;\n\n                let dup_flag = read_u8(stream)? as usize;\n                let properties = PublishProperties::read_from(stream)?;\n\n                Ok(BrokerMessage::PublishDelivery {\n                    packet_id: u16::from_be_bytes([packet_id_msb, packet_id_lsb]),\n                    topic_name,\n                    qos,\n                    retain_flag,\n                    payload,\n                    dup_flag,\n                    properties,\n                })\n            }\n            0x20 =\u003e {\n                let session_present = read_bool(stream)?;\n                let reason_code = read_u8(stream)?;\n                let properties = ConnackProperties::read_from(stream)?;\n                Ok(BrokerMessage::Connack {\n                    session_present,\n                    reason_code,\n                    properties,\n                })\n            }\n            0x40 =\u003e {\n                let packet_id_msb = read_u8(stream)?;\n                let packet_id_lsb = read_u8(stream)?;\n                let reason_code = read_u8(stream)?;\n\n                Ok(BrokerMessage::Puback {\n                    packet_id_msb,\n                    packet_id_lsb,\n                    reason_code,\n                })\n            }\n            0x90 =\u003e {\n                let packet_id_msb = read_u8(stream)?;\n                let packet_id_lsb = read_u8(stream)?;\n                let reason_code = read_u8(stream)?;\n                Ok(BrokerMessage::Suback {\n                    packet_id_msb,\n                    packet_id_lsb,\n                    reason_code,\n                })\n            }\n            0xB0 =\u003e {\n                let packet_id_msb = read_u8(stream)?;\n                let packet_id_lsb = read_u8(stream)?;\n                let reason_code = read_u8(stream)?;\n\n                Ok(BrokerMessage::Unsuback {\n                    packet_id_msb,\n                    packet_id_lsb,\n                    reason_code,\n                })\n            }\n            0xE0 =\u003e {\n                let reason_code = read_u8(stream)?;\n                let session_expiry_interval_id = read_u8(stream)?;\n                if session_expiry_interval_id != SESSION_EXPIRY_INTERVAL_ID {\n                    return Err(Error::new(\n                        std::io::ErrorKind::Other,\n                        \"Invalid session expiry interval id\",\n                    ));\n                }\n                let session_expiry_interval = read_u32(stream)?;\n\n                let reason_string_id = read_u8(stream)?;\n                if reason_string_id != REASON_STRING_ID {\n                    return Err(Error::new(\n                        std::io::ErrorKind::Other,\n                        \"Invalid reason string id\",\n                    ));\n                }\n                let reason_string = read_string(stream)?;\n\n                let user_property_id = read_u8(stream)?;\n                if user_property_id != USER_PROPERTY_ID {\n                    return Err(Error::new(\n                        std::io::ErrorKind::Other,\n                        \"Invalid user property id\",\n                    ));\n                }\n                let user_properties = read_string_pairs(stream)?;\n\n                Ok(BrokerMessage::Disconnect {\n                    reason_code,\n                    session_expiry_interval,\n                    reason_string,\n                    user_properties,\n                })\n            }\n            0xD0 =\u003e Ok(BrokerMessage::Pingresp),\n            0xF0 =\u003e {\n                let reason_code = read_u8(stream)?;\n                let mut authentication_method: Option\u003cString\u003e = None;\n                let mut authentication_data: Option\u003cVec\u003cu8\u003e\u003e = None;\n                let mut reason_string: Option\u003cString\u003e = None;\n                let mut user_properties: Option\u003cVec\u003c(String, String)\u003e\u003e = None;\n\n                let mut count = 0;\n                while let Ok(property_id) = read_u8(stream) {\n                    match property_id {\n                        0x15 =\u003e {\n                            let value = read_string(stream)?;\n                            authentication_method = Some(value);\n                        }\n                        0x16 =\u003e {\n                            let value = read_bin_vec(stream)?;\n                            authentication_data = Some(value);\n                        }\n                        0x26 =\u003e {\n                            let value = read_tuple_vec(stream)?;\n                            user_properties = Some(value);\n                        }\n                        0x1F =\u003e {\n                            let value = read_string(stream)?;\n                            reason_string = Some(value);\n                        }\n                        _ =\u003e {\n                            return Err(Error::new(ErrorKind::InvalidData, \"Property ID inválido\"));\n                        }\n                    }\n                    count += 1;\n                    if count == 4 {\n                        break;\n                    }\n                }\n\n                Ok(BrokerMessage::Auth {\n                    reason_code,\n                    user_properties: user_properties.ok_or(Error::new(\n                        ErrorKind::InvalidData,\n                        \"Missing user_properties property\",\n                    ))?,\n                    authentication_method: authentication_method.ok_or(Error::new(\n                        ErrorKind::InvalidData,\n                        \"Missing authentication_method property\",\n                    ))?,\n                    authentication_data: authentication_data.ok_or(Error::new(\n                        ErrorKind::InvalidData,\n                        \"Missing authentication_data property\",\n                    ))?,\n                    reason_string: reason_string.ok_or(Error::new(\n                        ErrorKind::InvalidData,\n                        \"Missing reason_string property\",\n                    ))?,\n                })\n            }\n            _ =\u003e Err(Error::new(std::io::ErrorKind::Other, \"Invalid header\")),\n        }\n    }\n\n    pub fn analize_packet_id(\u0026self, packet_id: u16) -\u003e bool {\n        match self {\n            BrokerMessage::Connack {\n                session_present: _,\n                reason_code: _,\n                properties: _,\n            } =\u003e true,\n            BrokerMessage::Puback {\n                packet_id_msb,\n                packet_id_lsb,\n                reason_code: _,\n            } =\u003e {\n                let bytes = packet_id.to_be_bytes();\n\n                bytes[0] == *packet_id_msb \u0026\u0026 bytes[1] == *packet_id_lsb\n            }\n            BrokerMessage::Suback {\n                packet_id_msb,\n                packet_id_lsb,\n                reason_code: _,\n            } =\u003e {\n                let bytes = packet_id.to_be_bytes();\n\n                bytes[0] == *packet_id_msb \u0026\u0026 bytes[1] == *packet_id_lsb\n            }\n            BrokerMessage::PublishDelivery {\n                packet_id: _,\n                topic_name: _,\n                qos: _,\n                retain_flag: _,\n                dup_flag: _,\n                properties: _,\n                payload: _,\n            } =\u003e true,\n            BrokerMessage::Unsuback {\n                packet_id_msb,\n                packet_id_lsb,\n                reason_code: _,\n            } =\u003e {\n                let bytes = packet_id.to_be_bytes();\n\n                bytes[0] == *packet_id_msb \u0026\u0026 bytes[1] == *packet_id_lsb\n            }\n            BrokerMessage::Pingresp =\u003e true,\n            BrokerMessage::Disconnect {\n                reason_code: _,\n                session_expiry_interval: _,\n                reason_string: _,\n                user_properties: _,\n            } =\u003e true,\n\n            BrokerMessage::Auth {\n                reason_code: _,\n                authentication_method: _,\n                authentication_data: _,\n                reason_string: _,\n                user_properties: _,\n            } =\u003e true,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::io::Cursor;\n\n    use super::*;\n\n    #[test]\n    fn test_02_analizing_packet_ids_ok() {\n        let suback = BrokerMessage::Suback {\n            reason_code: 1,\n            packet_id_msb: 2,\n            packet_id_lsb: 1,\n        };\n\n        let puback = BrokerMessage::Puback {\n            packet_id_msb: 1,\n            packet_id_lsb: 5,\n            reason_code: 1,\n        };\n\n        assert!(suback.analize_packet_id(513));\n        assert!(puback.analize_packet_id(261));\n    }\n\n    #[test]\n    fn test_03_unsuback_ok() {\n        let unsuback = BrokerMessage::Unsuback {\n            packet_id_msb: 1,\n            packet_id_lsb: 1,\n            reason_code: 1,\n        };\n\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        match unsuback.write_to(\u0026mut cursor) {\n            Ok(_) =\u003e {}\n            Err(err) =\u003e {\n                println!(\"Error: {:?}\", err);\n                panic!();\n            }\n        }\n        cursor.set_position(0);\n        let read_unsuback = match BrokerMessage::read_from(\u0026mut cursor) {\n            Ok(unsuback) =\u003e unsuback,\n            Err(err) =\u003e {\n                println!(\"Error: {:?}\", err);\n\n                panic!()\n            }\n        };\n        assert_eq!(unsuback, read_unsuback);\n    }\n}\n","traces":[{"line":92,"address":[],"length":0,"stats":{"Line":91},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":91},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":91},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":229,"coverable":256},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","client.rs"],"content":"use rand::Rng;\nuse std::{\n    net::TcpStream,\n    sync::{\n        mpsc::{self, Receiver, Sender},\n        Arc, Mutex,\n    },\n    thread,\n    time::Duration,\n};\n\nuse crate::{\n    mqtt::{\n        broker_message::BrokerMessage, client_message::ClientMessage,\n        messages_config::MessagesConfig, protocol_error::ProtocolError,\n    },\n    utils::threadpool::ThreadPool,\n};\n\nuse super::{client_message, client_return::ClientReturn, error::ClientError};\n\npub trait ClientTrait {\n    fn client_run(\u0026mut self) -\u003e Result\u003c(), ProtocolError\u003e;\n    fn clone_box(\u0026self) -\u003e Box\u003cdyn ClientTrait\u003e;\n    fn assign_packet_id(\u0026self) -\u003e u16;\n    fn get_publish_end_channel(\n        \u0026self,\n    ) -\u003e Arc\u003cstd::sync::Mutex\u003cstd::sync::mpsc::Receiver\u003cBox\u003c(dyn MessagesConfig + Send + 'static)\u003e\u003e\u003e\u003e;\n    fn get_client_id(\u0026self) -\u003e String;\n}\nimpl Clone for Box\u003cdyn ClientTrait\u003e {\n    fn clone(\u0026self) -\u003e Box\u003cdyn ClientTrait\u003e {\n        self.clone_box()\n    }\n}\n#[derive(Debug, Clone)]\npub struct Client {\n    receiver_channel: Arc\u003cMutex\u003cReceiver\u003cBox\u003cdyn MessagesConfig + Send\u003e\u003e\u003e\u003e,\n\n    // stream es el socket que se conecta al broker\n    stream: Arc\u003cMutex\u003cTcpStream\u003e\u003e,\n\n    // las subscriptions es un vector de topics a los que el cliente está subscrito\n    pub subscriptions: Arc\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e,\n\n    // client_id es el identificador del cliente\n    pub client_id: String,\n    // las subscriptions son un hashmap de topic y sub_id\n    // user_id: u32,\n    pub packets_ids: Arc\u003cMutex\u003cVec\u003cu16\u003e\u003e\u003e,\n\n    sender_channel: Sender\u003cClientMessage\u003e,\n}\n\nimpl Client {\n    /// Se intenta connectar al servidor corriendo en address.\n    ///\n    /// Si la conexion es exitosa, inmediatamente envia un packet del tipo Connect(que\n    /// ingresa como parametro).\n    ///\n    /// Si el enviado del Connect es exitoso, se espera una respuesta del Broker, la cual\n    /// debe ser un Connack packet.\n    ///\n    /// Al recibir un Connack, se ve su reason_code, y si este es 0x00(conexion exitosa), se crea la instancia\n    /// del Client.\n    pub fn new(\n        receiver_channel: Receiver\u003cBox\u003cdyn MessagesConfig + Send\u003e\u003e,\n        address: String,\n        connect: client_message::Connect,\n        sender_channel: Sender\u003cClientMessage\u003e,\n    ) -\u003e Result\u003cClient, ProtocolError\u003e {\n        let stream = match TcpStream::connect(address) {\n            Ok(stream) =\u003e Arc::new(Mutex::new(stream)),\n            Err(_) =\u003e return Err(ProtocolError::ConectionError),\n        };\n        let mut stream_lock = match stream.lock() {\n            Ok(stream) =\u003e stream,\n            Err(_) =\u003e return Err(ProtocolError::StreamError),\n        };\n        let connect_message = ClientMessage::Connect(connect.clone());\n        // println!(\"Connect: {:?}\", connect);\n\n        println!(\"Enviando connect message to broker\");\n\n        match connect_message.write_to(\u0026mut *stream_lock) {\n            Ok(()) =\u003e println!(\"Connect message enviado\"),\n            Err(_) =\u003e println!(\"Error al enviar connect message\"),\n        }\n        //flush\n\n        if let Ok(message) = BrokerMessage::read_from(\u0026mut *stream_lock) {\n            match message {\n                BrokerMessage::Connack {\n                    session_present: _,\n                    reason_code,\n                    properties: _,\n                } =\u003e {\n                    println!(\"Recibí un Connack\");\n                    let stream_clone = Arc::clone(\u0026stream);\n\n                    match reason_code {\n                        0x00_u8 =\u003e {\n                            println!(\"Conexion exitosa!\");\n\n                            let client_id = connect.client_id;\n                            Ok(Client {\n                                receiver_channel: Arc::new(Mutex::new(receiver_channel)),\n                                stream: stream_clone,\n                                subscriptions: Arc::new(Mutex::new(Vec::new())),\n                                packets_ids: Arc::new(Mutex::new(Vec::new())),\n                                sender_channel,\n                                client_id,\n                            })\n                        }\n                        _ =\u003e {\n                            println!(\"Connack con reason code {}\", reason_code);\n                            Err(ProtocolError::AuthError)\n                        }\n                    }\n                }\n                _ =\u003e Err(ProtocolError::ExpectedConnack),\n            }\n        } else {\n            Err(ProtocolError::NotReceivedMessageError)\n        }\n    }\n\n    /// Publica un mensaje en un topic determinado.\n    pub fn publish_message(\n        message: ClientMessage,\n        mut stream: TcpStream,\n        packet_id: u16,\n    ) -\u003e Result\u003cu16, ClientError\u003e {\n        //chequeo si el mensaje es de tipo publish\n        if let ClientMessage::Publish {\n            packet_id: _,\n            topic_name,\n            qos: _,\n            retain_flag: _,\n            payload: _,\n            dup_flag: _,\n            properties: _,\n        } = message.clone()\n        {\n            // println!(\"Enviando publish\");\n            match message.write_to(\u0026mut stream) {\n                Ok(()) =\u003e {\n                    println!(\"envio publish con topic_name: {:?}\", topic_name);\n                    Ok(packet_id)\n                }\n                Err(_) =\u003e Err(ClientError::new(\"Error al enviar mensaje\")),\n            }\n        } else {\n            Err(ClientError::new(\"El mensaje no es de tipo publish\"))\n        }\n    }\n\n    pub fn subscribe(\n        message: ClientMessage,\n        packet_id: u16,\n        mut stream: TcpStream,\n    ) -\u003e Result\u003cu16, ClientError\u003e {\n        match message.write_to(\u0026mut stream) {\n            Ok(()) =\u003e Ok(packet_id),\n            Err(_) =\u003e Err(ClientError::new(\"Error al enviar mensaje\")),\n        }\n    }\n\n    pub fn unsubscribe(\n        message: ClientMessage,\n        mut stream: TcpStream,\n        packet_id: u16,\n    ) -\u003e Result\u003cu16, ClientError\u003e {\n        match message.write_to(\u0026mut stream) {\n            Ok(()) =\u003e Ok(packet_id),\n            Err(_) =\u003e Err(ClientError::new(\"Error al enviar mensaje\")),\n        }\n    }\n\n    fn _assign_subscription_id() -\u003e u8 {\n        let mut rng = rand::thread_rng();\n\n        let sub_id: u8 = rng.gen();\n\n        sub_id\n    }\n\n    ///recibe un string que indica la razón de la desconexión y un stream y envia un disconnect message al broker\n    /// segun el str reason recibido, modifica el reason_code y el reason_string del mensaje\n    ///\n    /// devuelve el packet_id del mensaje enviado o un ClientError en caso de error\n    pub fn handle_disconnect(\n        client_id: String,\n        reason: \u0026str,\n        mut stream: TcpStream,\n    ) -\u003e Result\u003cu16, ClientError\u003e {\n        let packet_id = 1;\n        let reason_code: u8;\n        let reason_string: String;\n        match reason {\n            \"normal\" =\u003e {\n                reason_code = 0x00;\n                reason_string =\n                    \"Close the connection normally. Do not send the Will Message.\".to_string();\n            }\n            \"with_will\" =\u003e {\n                reason_code = 0x04;\n                reason_string = \"The Client wishes to disconnect but requires that the Server also publishes its Will Message\"\n                    .to_string();\n            }\n            _ =\u003e {\n                reason_code = 0x80;\n                reason_string = \"The Connection is closed but the sender either does not wish to reveal reason or none of the other Reason Codes apply. \"\n                    .to_string();\n            }\n        }\n        let disconnect = ClientMessage::Disconnect {\n            reason_code,\n            session_expiry_interval: 0,\n            reason_string,\n            client_id,\n        };\n\n        match disconnect.write_to(\u0026mut stream) {\n            Ok(()) =\u003e Ok(packet_id),\n            Err(_) =\u003e Err(ClientError::new(\"Error al enviar mensaje\")),\n        }\n    }\n\n    /// Se encarga de que el cliente este funcionando correctamente.\n    /// El Client debe encargarse de dos tareas: leer mensajes que le lleguen del Broker.\n    /// Estos mensajes pueden ser tanto acks (Connack, Puback, etc.)\n    /// como pubs que vengan por parte otros clientes (mediante el broker)\n    /// a cuyos topics esté subscrito.\n    ///\n    /// Su segunda tarea es enviar mensajes:\n    /// puede enviar mensajes como Publish, Suscribe, etc.\n    ///\n    /// Las dos tareas del Client se deben ejecutar concurrentemente,\n    /// por eso su tilizan dos threads(uno de lectura y otro de escritura),\n    /// ambos threads deben compaten el recurso TcpStream.\n    ///\n    /// El thread de escritura (write_messages) recibe por consola los mensajes a enviar.\n    /// Si logra enviar los mensajes correctamente, envia el pacjet id mediante el channel\n    ///\n    /// El thread de lectura (read_messages) se encarga de leer los mensajes que le llegan del broker.\n    pub fn client_run(\u0026mut self) -\u003e Result\u003c(), ProtocolError\u003e {\n        let (write_sender, recieve_receiver) = mpsc::channel();\n        let (reciever_sender, write_receiver) = mpsc::channel();\n\n        let receiver_channel = self.receiver_channel.clone();\n\n        let desconectar = false;\n        let stream_lock = match self.stream.lock() {\n            Ok(stream) =\u003e stream,\n            Err(_) =\u003e return Err(ProtocolError::StreamError),\n        };\n\n        let stream_clone_one = match stream_lock.try_clone() {\n            Ok(stream) =\u003e stream,\n            Err(_) =\u003e return Err(ProtocolError::StreamError),\n        };\n        let stream_clone_two = match stream_lock.try_clone() {\n            Ok(stream) =\u003e stream,\n            Err(_) =\u003e return Err(ProtocolError::StreamError),\n        };\n\n        let threadpool = ThreadPool::new(5);\n\n        let subscriptions_clone = self.subscriptions.clone();\n\n        let cloned_self = self.clone();\n        let _write_messages = threadpool.execute(move || {\n            cloned_self.write_messages(\n                stream_clone_one,\n                receiver_channel,\n                desconectar,\n                write_sender,\n                subscriptions_clone,\n                write_receiver,\n            )\n        });\n\n        let sender_channel_clone = self.sender_channel.clone();\n        let _read_messages = threadpool.execute(move || {\n            Client::receive_messages(\n                stream_clone_two,\n                recieve_receiver,\n                reciever_sender,\n                sender_channel_clone,\n            )\n        });\n\n        Ok(())\n    }\n\n    pub fn receive_messages(\n        stream: TcpStream,\n        receiver: Receiver\u003cu16\u003e,\n        sender: Sender\u003cbool\u003e,\n        sender_channel: Sender\u003cClientMessage\u003e,\n    ) -\u003e Result\u003c(), ProtocolError\u003e {\n        let mut pending_messages = Vec::new();\n\n        loop {\n            if let Ok(packet) = receiver.try_recv() {\n                if !pending_messages.contains(\u0026packet) {\n                    pending_messages.push(packet);\n                }\n            }\n\n            if let Ok(stream_clone) = stream.try_clone() {\n                match handle_message(\n                    stream_clone,\n                    pending_messages.clone(),\n                    sender.clone(),\n                    sender_channel.clone(),\n                ) {\n                    Ok(return_val) =\u003e {\n                        if return_val == ClientReturn::DisconnectRecieved {\n                            return Ok(());\n                        }\n                    }\n                    Err(err) =\u003e {\n                        return Err(err);\n                    }\n                }\n            } else {\n                println!(\"Error al clonar el stream\");\n            }\n        }\n    }\n\n    /// Esta funcion se encarga de la escritura de mensajes que recibe mediante el channel.\n    ///\n    ///\n    /// Si el mensaje es un publish con qos 1, se envia el mensaje y se espera un puback. Si no se recibe, espera 0.5 segundos y reenvia el mensaje. aumentando en 1 el dup_flag, indicando que es al vez numero n que se envia el publish.\n    fn write_messages(\n        \u0026self,\n        stream: TcpStream,\n        receiver_channel: Arc\u003cMutex\u003cReceiver\u003cBox\u003cdyn MessagesConfig + Send\u003e\u003e\u003e\u003e,\n        mut desconectar: bool,\n        sender: Sender\u003cu16\u003e,\n        subscriptions_clone: Arc\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e,\n        receiver: Receiver\u003cbool\u003e,\n    ) -\u003e Result\u003c(), ProtocolError\u003e {\n        while !desconectar {\n            loop {\n                let lock = match receiver_channel.lock() {\n                    Ok(lock) =\u003e lock,\n                    Err(_) =\u003e return Err(ProtocolError::StreamError),\n                };\n                if let Ok(message_config) = lock.recv() {\n                    let packet_id = self.assign_packet_id();\n\n                    let message = message_config.parse_message(packet_id);\n\n                    match message {\n                        ClientMessage::Connect { 0: _ } =\u003e todo!(),\n                        ClientMessage::Publish {\n                            packet_id,\n                            topic_name,\n                            qos,\n                            retain_flag,\n                            payload,\n                            dup_flag,\n                            properties,\n                        } =\u003e match stream.try_clone() {\n                            Ok(stream_clone) =\u003e {\n                                let publish = ClientMessage::Publish {\n                                    packet_id,\n                                    topic_name: topic_name.clone(),\n                                    qos,\n                                    retain_flag,\n                                    payload: payload.clone(),\n                                    dup_flag,\n                                    properties: properties.clone(),\n                                };\n\n                                if let Ok(packet_id) = Client::publish_message(\n                                    publish,\n                                    match stream_clone.try_clone() {\n                                        Ok(stream) =\u003e stream,\n                                        Err(_) =\u003e return Err(ProtocolError::StreamError),\n                                    },\n                                    packet_id,\n                                ) {\n                                    if qos == 1 {\n                                        let stream_clone = match stream_clone.try_clone() {\n                                            Ok(stream) =\u003e stream,\n                                            Err(_) =\u003e return Err(ProtocolError::StreamError),\n                                        };\n                                        match sender.send(packet_id) {\n                                            Ok(_) =\u003e {\n                                                if let Ok(puback_recieved) = receiver.try_recv() {\n                                                    if !puback_recieved {\n                                                        //reenviar el msj con un dup_flag + 1\n\n                                                        thread::sleep(Duration::from_millis(500));\n                                                        let publish = ClientMessage::Publish {\n                                                            packet_id,\n                                                            topic_name,\n                                                            qos,\n                                                            retain_flag,\n                                                            payload,\n                                                            dup_flag: dup_flag + 1,\n                                                            properties,\n                                                        };\n                                                        match Client::publish_message(\n                                                            publish,\n                                                            stream_clone,\n                                                            packet_id,\n                                                        ) {\n                                                            Ok(_) =\u003e {\n                                                                println!(\"Reenviando mensaje con dup_flag + 1\")\n                                                            }\n                                                            Err(_) =\u003e {\n                                                                println!(\n                                                                    \"Error al reenviar mensaje\"\n                                                                )\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            Err(_) =\u003e {\n                                                println!(\n                                                \"Error al enviar packet_id de puback al receiver\"\n                                            )\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            Err(_) =\u003e {\n                                return Err::\u003c(), ProtocolError\u003e(ProtocolError::StreamError);\n                            }\n                        },\n                        ClientMessage::Subscribe {\n                            packet_id,\n                            properties,\n                            payload,\n                        } =\u003e match stream.try_clone() {\n                            Ok(stream_clone) =\u003e {\n                                let subscribe = ClientMessage::Subscribe {\n                                    packet_id,\n                                    properties,\n                                    payload: payload.clone(),\n                                };\n                                for p in payload {\n                                    if let Ok(stream) = stream_clone.try_clone() {\n                                        if let Ok(packet_id) =\n                                            Client::subscribe(subscribe.clone(), packet_id, stream)\n                                        {\n                                            match sender.send(packet_id) {\n                                                Ok(_) =\u003e {\n                                                    let topic_new = p.topic.to_string();\n                                                    match subscriptions_clone.lock() {\n                                                        Ok(mut guard) =\u003e {\n                                                            guard.push(topic_new);\n                                                        }\n                                                        Err(_) =\u003e {\n                                                            return Err::\u003c(), ProtocolError\u003e(\n                                                                ProtocolError::StreamError,\n                                                            );\n                                                        }\n                                                    }\n                                                }\n                                                Err(_) =\u003e {\n                                                    return Err::\u003c(), ProtocolError\u003e(\n                                                        ProtocolError::StreamError,\n                                                    );\n                                                }\n                                            }\n                                        }\n                                    } else {\n                                        return Err::\u003c(), ProtocolError\u003e(\n                                            ProtocolError::StreamError,\n                                        );\n                                    }\n                                }\n                            }\n                            Err(_) =\u003e {\n                                return Err::\u003c(), ProtocolError\u003e(ProtocolError::StreamError);\n                            }\n                        },\n                        ClientMessage::Unsubscribe {\n                            packet_id,\n                            properties,\n                            payload,\n                        } =\u003e match stream.try_clone() {\n                            Ok(stream_clone) =\u003e {\n                                let unsubscribe = ClientMessage::Unsubscribe {\n                                    packet_id,\n                                    properties,\n                                    payload: payload.clone(),\n                                };\n\n                                for p in payload {\n                                    if let Ok(stream) = stream_clone.try_clone() {\n                                        if let Ok(packet_id) = Client::unsubscribe(\n                                            unsubscribe.clone(),\n                                            stream,\n                                            packet_id,\n                                        ) {\n                                            match sender.send(packet_id) {\n                                                Ok(_) =\u003e {\n                                                    let topic_new = p.topic.to_string();\n                                                    match subscriptions_clone.lock() {\n                                                        Ok(mut guard) =\u003e {\n                                                            guard.retain(|x| x != \u0026topic_new);\n                                                        }\n                                                        Err(_) =\u003e {\n                                                            return Err::\u003c(), ProtocolError\u003e(\n                                                                ProtocolError::StreamError,\n                                                            );\n                                                        }\n                                                    }\n                                                }\n                                                Err(_) =\u003e {\n                                                    return Err::\u003c(), ProtocolError\u003e(\n                                                        ProtocolError::StreamError,\n                                                    );\n                                                }\n                                            }\n                                        }\n                                    } else {\n                                        return Err::\u003c(), ProtocolError\u003e(\n                                            ProtocolError::StreamError,\n                                        );\n                                    }\n                                }\n                            }\n                            Err(_) =\u003e {\n                                return Err::\u003c(), ProtocolError\u003e(ProtocolError::StreamError);\n                            }\n                        },\n                        ClientMessage::Disconnect {\n                            reason_code: _,\n                            session_expiry_interval: _,\n                            reason_string: _,\n                            client_id,\n                        } =\u003e {\n                            match stream.try_clone() {\n                                Ok(stream_clone) =\u003e {\n                                    let reason = \"normal\";\n\n                                    let _disconnect = ClientMessage::Disconnect {\n                                        reason_code: 0x00,\n                                        session_expiry_interval: 0,\n                                        reason_string: \"Disconnecting\".to_string(),\n                                        client_id: client_id.clone(),\n                                    };\n\n                                    if let Ok(packet_id) =\n                                        Client::handle_disconnect(client_id, reason, stream_clone)\n                                    {\n                                        match sender.send(packet_id) {\n                                            Ok(_) =\u003e continue,\n                                            Err(_) =\u003e {\n                                                println!(\n                                                    \"Error al enviar packet_id de puback al receiver\"\n                                                )\n                                            }\n                                        }\n                                        desconectar = true;\n                                        break;\n                                    }\n                                }\n                                Err(_) =\u003e {\n                                    return Err::\u003c(), ProtocolError\u003e(ProtocolError::StreamError);\n                                }\n                            }\n                            break;\n                        }\n                        ClientMessage::Pingreq =\u003e {\n                            match stream.try_clone() {\n                                Ok(mut stream_clone) =\u003e {\n                                    let pingreq = ClientMessage::Pingreq;\n                                    match pingreq.write_to(\u0026mut stream_clone) {\n                                        //chequear esto\n                                        Ok(()) =\u003e println!(\"Pingreq enviado\"),\n                                        Err(_) =\u003e println!(\"Error al enviar pingreq\"),\n                                    }\n                                }\n                                Err(_) =\u003e {\n                                    return Err::\u003c(), ProtocolError\u003e(ProtocolError::StreamError);\n                                }\n                            }\n                        }\n                        ClientMessage::Auth {\n                            reason_code: _,\n                            authentication_method: _,\n                            authentication_data: _,\n                            reason_string: _,\n                            user_properties: _,\n                        } =\u003e {\n                            println!(\"auth enviado\");\n                        }\n                    }\n                }\n            }\n        }\n        Ok(())\n    }\n\n    pub fn get_publish_end_channel(\n        \u0026self,\n    ) -\u003e Arc\u003cstd::sync::Mutex\u003cstd::sync::mpsc::Receiver\u003cBox\u003c(dyn MessagesConfig + Send + 'static)\u003e\u003e\u003e\u003e\n    {\n        self.receiver_channel.clone()\n    }\n\n    ///Asigna un id random\n    pub fn assign_packet_id(\u0026self) -\u003e u16 {\n        let mut rng = rand::thread_rng();\n        let mut packet_ids = match self.packets_ids.lock() {\n            Ok(packet_ids) =\u003e packet_ids,\n            Err(_) =\u003e return 0,\n        };\n\n        let mut packet_id: u16;\n        loop {\n            packet_id = rng.gen();\n            if packet_id != 0 \u0026\u0026 !packet_ids.contains(\u0026packet_id) {\n                packet_ids.push(packet_id);\n                break;\n            }\n        }\n        packet_id\n    }\n}\n\nimpl ClientTrait for Client {\n    fn client_run(\u0026mut self) -\u003e Result\u003c(), ProtocolError\u003e {\n        self.client_run()\n    }\n\n    fn clone_box(\u0026self) -\u003e Box\u003cdyn ClientTrait\u003e {\n        Box::new(self.clone())\n    }\n    fn assign_packet_id(\u0026self) -\u003e u16 {\n        self.assign_packet_id()\n    }\n\n    fn get_publish_end_channel(\n        \u0026self,\n    ) -\u003e Arc\u003cstd::sync::Mutex\u003cstd::sync::mpsc::Receiver\u003cBox\u003c(dyn MessagesConfig + Send + 'static)\u003e\u003e\u003e\u003e\n    {\n        self.get_publish_end_channel()\n    }\n    fn get_client_id(\u0026self) -\u003e String {\n        self.client_id.clone()\n    }\n}\n\n/// Lee del stream un mensaje y lo procesa\n/// Devuelve un ClientReturn con informacion del mensaje recibido\n/// O ProtocolError en caso de error\npub fn handle_message(\n    mut stream: TcpStream,\n    pending_messages: Vec\u003cu16\u003e,\n    sender: Sender\u003cbool\u003e,\n    sender_chanell: Sender\u003cClientMessage\u003e,\n) -\u003e Result\u003cClientReturn, ProtocolError\u003e {\n    if let Ok(message) = BrokerMessage::read_from(\u0026mut stream) {\n        match message {\n            BrokerMessage::Connack {\n                session_present: _,\n                reason_code: _,\n                properties: _,\n            } =\u003e {\n                println!(\"Recibí un Connack\");\n                Ok(ClientReturn::ConnackReceived)\n            }\n            BrokerMessage::Puback {\n                packet_id_msb,\n                packet_id_lsb,\n                reason_code: _,\n            } =\u003e {\n                for pending_message in \u0026pending_messages {\n                    let packet_id_bytes: [u8; 2] = pending_message.to_be_bytes();\n                    if packet_id_bytes[0] == packet_id_msb \u0026\u0026 packet_id_bytes[1] == packet_id_lsb {}\n                }\n                match sender.send(true) {\n                    Ok(_) =\u003e Ok(ClientReturn::PubackRecieved),\n                    Err(e) =\u003e Err(ProtocolError::ChanellError(e.to_string())),\n                }\n            }\n            BrokerMessage::Disconnect {\n                reason_code: _,\n                session_expiry_interval: _,\n                reason_string,\n                user_properties: _,\n            } =\u003e {\n                println!(\n                    \"Recibí un Disconnect, razon de desconexión: {:?}\",\n                    reason_string\n                );\n\n                Ok(ClientReturn::DisconnectRecieved)\n            }\n            BrokerMessage::Suback {\n                packet_id_msb,\n                packet_id_lsb,\n                reason_code: _,\n            } =\u003e {\n                for pending_message in \u0026pending_messages {\n                    let packet_id_bytes: [u8; 2] = pending_message.to_be_bytes();\n\n                    if packet_id_bytes[0] == packet_id_msb \u0026\u0026 packet_id_bytes[1] == packet_id_lsb {\n                        println!(\"suback con id {} {} recibido\", packet_id_msb, packet_id_lsb);\n                    }\n                }\n\n                println!(\"Recibi un mensaje {:?}\", message);\n                Ok(ClientReturn::SubackRecieved)\n            }\n            BrokerMessage::PublishDelivery {\n                packet_id,\n                topic_name,\n                qos,\n                retain_flag,\n                dup_flag,\n                properties,\n                payload,\n            } =\u003e {\n                // println!(\n                // \"PublishDelivery con id {} recibido, payload: {:?}\",\n                // packet_id, payload\n                // );\n                match sender_chanell.send(ClientMessage::Publish {\n                    packet_id,\n                    topic_name,\n                    qos,\n                    retain_flag,\n                    dup_flag,\n                    properties,\n                    payload,\n                }) {\n                    Ok(_) =\u003e {}\n                    Err(e) =\u003e println!(\"Error al enviar publish al sistema: {:?}\", e),\n                }\n\n                Ok(ClientReturn::PublishDeliveryRecieved)\n            }\n            BrokerMessage::Unsuback {\n                packet_id_msb,\n                packet_id_lsb,\n                reason_code: _,\n            } =\u003e {\n                for pending_message in \u0026pending_messages {\n                    let packet_id_bytes: [u8; 2] = pending_message.to_be_bytes();\n                    if packet_id_bytes[0] == packet_id_msb \u0026\u0026 packet_id_bytes[1] == packet_id_lsb {\n                        println!(\n                            \"Unsuback con id {} {} recibido\",\n                            packet_id_msb, packet_id_lsb\n                        );\n                    }\n                }\n\n                println!(\"Recibi un mensaje {:?}\", message);\n                Ok(ClientReturn::UnsubackRecieved)\n            }\n            BrokerMessage::Pingresp =\u003e {\n                println!(\"Recibi un mensaje {:?}\", message);\n                Ok(ClientReturn::PingrespRecieved)\n            }\n            BrokerMessage::Auth {\n                reason_code: _,\n                authentication_method: _,\n                authentication_data: _,\n                reason_string: _,\n                user_properties: _,\n            } =\u003e {\n                println!(\"recibi un auth!\");\n                Ok(ClientReturn::AuthRecieved)\n            }\n        }\n    } else {\n        Err(ProtocolError::StreamError)\n    }\n}\n\n#[cfg(test)]\n\nmod tests {\n\n    use std::sync::Condvar;\n\n    use crate::mqtt::broker::Broker;\n\n    use super::*;\n\n    #[test]\n    fn test_assign_packet_id() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5047\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n        let handle = thread::spawn(move || {\n            let connect_config =\n                client_message::Connect::read_connect_config(\"src/drones/connect_config.json\")\n                    .unwrap();\n            let (_, rx) = mpsc::channel();\n            let (tx2, _) = mpsc::channel();\n            let address = \"127.0.0.1:5047\";\n            let client = Client::new(rx, address.to_string(), connect_config, tx2).unwrap();\n            let packet_id = client.assign_packet_id();\n            assert_ne!(packet_id, 0);\n        });\n        handle.join().unwrap();\n    }\n\n    #[test]\n    fn test_si_el_id_de_paquete_es_unico() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5039\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n        let handle = thread::spawn(move || {\n            let connect_config =\n                client_message::Connect::read_connect_config(\"src/drones/connect_config.json\")\n                    .unwrap();\n            let (_, rx) = mpsc::channel();\n            let (tx2, _) = mpsc::channel();\n            let address = \"127.0.0.1:5039\";\n            let client = Client::new(rx, address.to_string(), connect_config, tx2).unwrap();\n            let packet_id = client.assign_packet_id();\n            let packet_id_2 = client.assign_packet_id();\n            assert_ne!(packet_id, packet_id_2);\n        });\n        handle.join().unwrap();\n    }\n\n    #[test]\n    fn test_si_el_id_de_paquete_es_distinto_de_cero() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5028\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n        let handle = thread::spawn(move || {\n            let connect_config =\n                client_message::Connect::read_connect_config(\"src/drones/connect_config.json\")\n                    .unwrap();\n            let (_, rx) = mpsc::channel();\n            let (tx2, _) = mpsc::channel();\n            let address = \"127.0.0.1:5028\";\n            let client = Client::new(rx, address.to_string(), connect_config, tx2).unwrap();\n            let packet_id = client.assign_packet_id();\n            assert_ne!(packet_id, 0);\n        });\n        handle.join().unwrap();\n    }\n\n    #[test]\n    fn test_assign_subscription_id() {\n        let sub_id = Client::_assign_subscription_id();\n        assert_ne!(sub_id, 0);\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":673,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":674,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":745,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":749,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":755,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":756,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":766,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":781,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":154,"coverable":286},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","client_message.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse crate::mqtt::subscribe_properties::SubscribeProperties;\nuse crate::utils::payload_types::PayloadTypes;\nuse std::env;\nuse std::fs::File;\nuse std::io::{BufReader, BufWriter, Error, ErrorKind, Read, Write};\n\nuse crate::mqtt::publish::publish_properties::PublishProperties;\nuse crate::utils::{reader::*, writer::*};\n\nuse super::connect::connect_properties::ConnectProperties;\nuse super::connect::will_properties::WillProperties;\nuse super::messages_config::MessagesConfig;\nuse super::payload::Payload;\nuse super::subscription::Subscription;\n\nuse super::protocol_error::ProtocolError;\nuse crate::mqtt::connect::last_will::LastWill;\nconst PROTOCOL_VERSION: u8 = 5;\nconst SESSION_EXPIRY_INTERVAL_ID: u8 = 0x11;\nconst REASON_STRING_ID: u8 = 0x1F;\n\n#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]\n///El Connect Message es el primer mensaje que el cliente envia cuando se conecta al broker. Este contiene toda la informacion necesaria para que el broker identifique al cliente y pueda establecer una sesion con los parametros establecidos.\n///\n/// clean_start especifica si se debe limpiar la sesion previa del cliente y arrancar una nueva limpia y desde cero.\n///\n/// last_will_flag especifica si el will message se debe guardar asociado a la sesion, last_will_qos especifica el QoS level utilizado cuando se publique el will message, last_will_retain especifica si el will message se retiene despues de ser publicado.\n///\n/// keep_alive especifica el tiempo en segundos que el broker debe esperar entre mensajes del cliente antes de desconectarlo.\n///\n/// Si el will flag es true, se escriben el will topic y el will message.\n///\n/// finalmente, si el cliente envia un username y un password, estos se escriben en el payload.\npub struct Connect {\n    clean_start: bool,\n    last_will_flag: bool,\n    last_will_qos: u8,\n    last_will_retain: bool,\n    keep_alive: u16,\n    pub(crate) properties: ConnectProperties,\n\n    /// Connect Payload\n    /// Ayuda a que el servidor identifique al cliente. Siempre debe ser\n    /// el primer campo del payload del packet Connect.\n    pub(crate) client_id: String,\n\n    will_properties: Option\u003cWillProperties\u003e,\n    last_will_topic: Option\u003cString\u003e,\n    last_will_message: Option\u003cString\u003e,\n    pub(crate) username: Option\u003cString\u003e,\n    pub(crate) password: Option\u003cVec\u003cu8\u003e\u003e,\n}\n\n#[derive(Debug, PartialEq, Clone)]\npub enum ClientMessage {\n    Connect(Connect),\n\n    /// El paquete Publish es enviado desde un cliente al servidor, o desde un servidor al cliente para transportar un mensaje de aplicacion.\n    Publish {\n        packet_id: u16,\n\n        ///Identifica el canal de informacion por el cual el Payload data se va a publicar.\n        topic_name: String,\n\n        ///Indica el nivel de garantia de delivery de un application message.\n        qos: usize,\n\n        /// Si vale 1, el server debe reemplazar cualquier retained message para ese topic\n        /// y guardar este application message.\n        retain_flag: usize,\n\n        ///Es el application message que se esta publicando.\n        ///El contenido y formato de la data es especificado por la aplicacion.\n        payload: PayloadTypes,\n\n        ///Dup flag indica si fue la primera ocasion que el client o el servidor intento enviar este packete.\n        /// Debe ser 0 para todos los mensajes con QoS 0.\n        /// Debe valer 1 para indicar que es el segundo intento de envio del packete.\n        dup_flag: usize,\n\n        /// Una property es un identificador que define el uso y tipos de data, seguido de un valor.\n        properties: PublishProperties,\n    },\n\n    /// El Subscribe Message se utiliza para suscribirse a uno o más topics. El cliente puede enviar un mensaje de subscribe con un packet id y una lista de topics a los que se quiere suscribir. El broker responde con un mensaje de suback con el mismo packet id y una lista de return codes que indican si la suscripcion fue exitosa o no.\n    Subscribe {\n        /// packet_id es un identificador unico que el cliente asigna a cada mensaje que envia.\n        packet_id: u16,\n        /// properties es un struct que contiene las propiedades del mensaje de subscribe.\n        properties: SubscribeProperties,\n        /// Vector de subscription es un struct que contiene la informacion de la suscripcion.\n        payload: Vec\u003cSubscription\u003e,\n    },\n    Unsubscribe {\n        packet_id: u16,\n        properties: SubscribeProperties,\n        payload: Vec\u003cSubscription\u003e,\n    },\n    /// Es el ultimo mensaje que el cliente envia antes de desconectarse, este mensaje contiene informacion sobre la razon de la desconexión y propiedades adicionales.\n    /// reason_code es el codigo de la razon de la desconexión.\n    /// session_expiry_interval es el tiempo en segundos que el broker debe mantener la sesion del cliente activa despues de que este se desconecte.\n    /// reason_string es un mensaje de texto que describe la razon de la desconexión.\n    /// client_id es el identificador unico del cliente.\n    Disconnect {\n        reason_code: u8,\n        session_expiry_interval: u32,\n        reason_string: String,\n        client_id: String,\n    },\n    /// El Pingreq Message es un mensaje que el cliente envia al broker para mantener la conexion activa.\n    Pingreq,\n\n    /// Sirve para autenticar usuarios. Tanto el Broker como el Client pueden enviar estos packets(van a ser iguales).\n    ///\n    /// La idea es utilizar propiedades que se definen dentro de los packets del tipo Connect, y poder realizar la\n    /// autenticacion correctamente.\n    Auth {\n        /// Nos indica el estado de nuestra autenticacion.\n        reason_code: u8,\n\n        /// Indica el metodo de autenticacion a seguir.\n        authentication_method: String,\n\n        /// Contiene data binaria sobre la autenticacion.\n        authentication_data: Vec\u003cu8\u003e,\n\n        /// Aca se muestra mas a detalle la razon de la desconexion. La idea es mostrarle\n        /// al usuario a traves de un texto legible el por que el broker decidio desconectarlo.\n        reason_string: String,\n\n        /// Para diagnosticos e informacion adicionales.\n        user_properties: Vec\u003c(String, String)\u003e,\n    },\n}\nimpl MessagesConfig for Connect {\n    /// Hereda del trait de MessagesConfig, por lo que sabe\n    /// crear un ClientMessage -\u003e en este caso devolvera\n    /// siempre un mensaje del tipo Connect.\n    fn parse_message(\u0026self, _packet_id: u16) -\u003e ClientMessage {\n        ClientMessage::Connect(self.clone())\n    }\n}\nimpl MessagesConfig for ClientMessage {\n    fn parse_message(\u0026self, _packet_id: u16) -\u003e ClientMessage {\n        self.clone()\n    }\n}\nimpl Connect {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        clean_start: bool,\n        last_will_flag: bool,\n        last_will_qos: u8,\n        last_will_retain: bool,\n        keep_alive: u16,\n        properties: ConnectProperties,\n        client_id: String,\n        will_properties: WillProperties,\n        last_will_topic: String,\n        last_will_message: String,\n        username: String,\n        password: String,\n    ) -\u003e Connect {\n        Connect {\n            clean_start,\n            last_will_flag,\n            last_will_qos,\n            last_will_retain,\n            keep_alive,\n            properties,\n            client_id,\n            will_properties: Some(will_properties),\n            last_will_topic: Some(last_will_topic),\n            last_will_message: Some(last_will_message),\n            username: Some(username),\n            password: Some(password.into_bytes()),\n        }\n    }\n\n    /// Devuelve, en caso de que haya, un last will. Si el will flag está seteado en false, devuelve None\n    pub fn give_will_message(self) -\u003e Option\u003cLastWill\u003e {\n        if !self.last_will_flag {\n            return None;\n        }\n\n        let last_will_topic = self.last_will_topic?;\n        let last_will_message = self.last_will_message?;\n        let will_properties = self.will_properties?;\n\n        Some(LastWill::new(\n            last_will_topic,\n            last_will_message,\n            self.last_will_qos,\n            self.last_will_retain,\n            will_properties,\n        ))\n    }\n    /// Abre un archivo de configuracion con propiedades y guarda sus lecturas.\n    pub fn read_connect_config(file_path: \u0026str) -\u003e Result\u003cConnect, ProtocolError\u003e {\n        let current_dir = match env::current_dir() {\n            Ok(dir) =\u003e dir,\n            Err(_) =\u003e return Err(ProtocolError::ReadingConfigFileError),\n        };\n        println!(\"Current directory: {}\", current_dir.display());\n        let config_file = match File::open(file_path) {\n            Ok(file) =\u003e file,\n            Err(_) =\u003e {\n                return Err(ProtocolError::ReadingConfigFileError);\n            }\n        };\n\n        let reader: BufReader\u003cFile\u003e = BufReader::new(config_file);\n        let connect: Connect = match serde_json::from_reader(reader) {\n            Ok(c) =\u003e c,\n            Err(_) =\u003e return Err(ProtocolError::ReadingConfigFileError),\n        };\n\n        connect.check_will_properties()?;\n\n        Ok(connect)\n    }\n\n    /// Abre un archivo de configuracion con propiedades y guarda sus lecturas.\n    pub fn read_connect(file_path: \u0026str) -\u003e Result\u003cConnect, ProtocolError\u003e {\n        let config_file = match File::open(file_path) {\n            Ok(file) =\u003e file,\n            Err(_) =\u003e return Err(ProtocolError::ReadingConfigFileError),\n        };\n\n        let reader: BufReader\u003cFile\u003e = BufReader::new(config_file);\n        let config: Connect = match serde_json::from_reader(reader) {\n            Ok(c) =\u003e c,\n            Err(_) =\u003e return Err(ProtocolError::ReadingConfigFileError),\n        };\n\n        config.check_will_properties()?;\n\n        Ok(config)\n    }\n\n    fn check_will_properties(\u0026self) -\u003e Result\u003c(), ProtocolError\u003e {\n        if let (Some(_), Some(_), Some(_)) = (\n            \u0026self.will_properties,\n            \u0026self.last_will_topic,\n            \u0026self.last_will_message,\n        ) {\n            if self.last_will_qos \u003e 1 {\n                //si es una QoS no soportada...\n                return Err(ProtocolError::InvalidQOS);\n            }\n            return Ok(());\n        }\n\n        Err(ProtocolError::MissingWillMessageProperties)\n    }\n\n    pub fn write_to(\u0026self, writer: \u0026mut dyn Write) -\u003e Result\u003c(), ProtocolError\u003e {\n        //fixed header\n        let byte_1: u8 = 0x10_u8.to_le(); //00010000\n        let _ = writer\n            .write_all(\u0026[byte_1])\n            .map_err(|_e| ProtocolError::WriteError);\n\n        //protocol name\n        let protocol_name = \"MQTT\";\n        write_string(writer, protocol_name)?;\n\n        //protocol version\n        let protocol_version: u8 = 0x05;\n        let _ = writer\n            .write_all(\u0026[protocol_version])\n            .map_err(|_e| ProtocolError::WriteError);\n        //connection flags\n        let mut connect_flags: u8 = 0x00;\n        if self.clean_start {\n            connect_flags |= 1 \u003c\u003c 1; //set bit 1 to 1\n        }\n\n        if self.last_will_flag {\n            connect_flags |= 1 \u003c\u003c 2;\n        }\n        if self.last_will_qos \u003e 1 {\n            return Err(ProtocolError::InvalidQOS);\n        }\n        connect_flags |= (self.last_will_qos \u0026 0b11) \u003c\u003c 3;\n\n        if self.last_will_retain {\n            connect_flags |= 1 \u003c\u003c 5;\n        }\n\n        if let Some(password) = self.password.as_ref() {\n            if !password.is_empty() {\n                connect_flags |= 1 \u003c\u003c 6;\n            }\n        }\n\n        if let Some(username) = self.username.as_ref() {\n            if !username.is_empty() {\n                connect_flags |= 1 \u003c\u003c 7;\n            }\n        }\n\n        let _ = writer\n            .write_all(\u0026[connect_flags])\n            .map_err(|_e| ProtocolError::WriteError);\n\n        //keep alive\n        write_u16(writer, \u0026self.keep_alive)?;\n        write_string(writer, \u0026self.client_id)?;\n\n        if let (Some(will_properties), Some(last_will_topic), Some(last_will_message)) = (\n            self.will_properties.clone(),\n            self.last_will_topic.clone(),\n            self.last_will_message.clone(),\n        ) {\n            if self.last_will_flag {\n                will_properties.write_to(writer)?;\n                write_string(writer, \u0026last_will_topic)?;\n                write_string(writer, \u0026last_will_message)?;\n            }\n        }\n\n        if let Some(username) = self.username.as_ref() {\n            if !username.is_empty() {\n                write_string(writer, username)?;\n            }\n        }\n\n        if let Some(password) = self.password.as_ref() {\n            if !password.is_empty() {\n                write_bin_vec(writer, password)?;\n            }\n        }\n\n        self.properties.write_to(writer)?;\n\n        Ok(())\n    }\n\n    pub fn read_from(stream: \u0026mut impl Read) -\u003e Result\u003cConnect, Error\u003e {\n        let protocol_name = read_string(stream)?;\n\n        if protocol_name != \"MQTT\" {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Nombre de protocolo inválido\",\n            ));\n        }\n        //protocol version\n        let protocol_version = read_u8(stream)?;\n\n        if protocol_version != PROTOCOL_VERSION {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Version de protocol inválido\",\n            ));\n        }\n        //connect flags\n        let connect_flags = read_u8(stream)?;\n        let clean_start = (connect_flags \u0026 (1 \u003c\u003c 1)) != 0;\n        let last_will_flag = (connect_flags \u0026 (1 \u003c\u003c 2)) != 0;\n        let last_will_qos = (connect_flags \u003e\u003e 3) \u0026 0b11;\n        let last_will_retain = (connect_flags \u0026 (1 \u003c\u003c 5)) != 0;\n\n        //keep alive\n        let keep_alive = read_u16(stream)?;\n        //payload\n        //client ID\n        let client_id = read_string(stream)?;\n\n        let mut last_will_topic = String::new();\n        let mut will_message = String::new();\n\n        let will_properties = WillProperties::read_from(stream)?;\n        if last_will_flag {\n            last_will_topic = read_string(stream)?;\n            will_message = read_string(stream)?;\n        }\n\n        let hay_user = (connect_flags \u0026 (1 \u003c\u003c 7)) != 0;\n        let mut user = String::new();\n        if hay_user {\n            user = read_string(stream)?;\n        }\n\n        let hay_pass = (connect_flags \u0026 (1 \u003c\u003c 6)) != 0;\n        let mut pass = Vec::new();\n        if hay_pass {\n            pass = read_bin_vec(stream)?;\n        }\n\n        //properties\n        let properties: ConnectProperties = ConnectProperties::read_from(stream)?;\n\n        Ok(Connect {\n            clean_start,\n            last_will_flag,\n            last_will_qos,\n            last_will_retain,\n            keep_alive,\n            properties,\n            client_id,\n            will_properties: Some(will_properties),\n            last_will_topic: Some(last_will_topic),\n            last_will_message: Some(will_message),\n            username: Some(user),\n            password: Some(pass),\n        })\n    }\n}\n\nimpl ClientMessage {\n    pub fn write_to(\u0026self, stream: \u0026mut dyn Write) -\u003e Result\u003c(), ProtocolError\u003e {\n        let mut writer = BufWriter::new(stream);\n        match self {\n            ClientMessage::Connect(connect) =\u003e {\n                connect.write_to(\u0026mut writer)?;\n                let _ = writer.flush().map_err(|_e| ProtocolError::WriteError);\n\n                Ok(())\n            }\n            ClientMessage::Publish {\n                packet_id,\n                topic_name,\n                qos,\n                retain_flag,\n                payload,\n                dup_flag,\n                properties,\n            } =\u003e {\n                //fixed header\n                let mut byte_1 = 0x30_u8;\n\n                if *retain_flag == 1 {\n                    //we must replace any existing retained message for this topic and store\n                    //the app message.\n                    byte_1 |= 1 \u003c\u003c 0;\n                }\n\n                if *qos == 1 {\n                    byte_1 |= 1 \u003c\u003c 1;\n                    byte_1 |= 0 \u003c\u003c 2;\n                } else if *qos != 0x00 \u0026\u0026 *qos != 0x01 {\n                    return Err(ProtocolError::InvalidQOS);\n                }\n\n                if *dup_flag == 1 {\n                    byte_1 |= 1 \u003c\u003c 3;\n                }\n\n                //Dup flag must be set to 0 for all QoS 0 messages.\n                if *qos == 0x00 {\n                    byte_1 |= 0 \u003c\u003c 3;\n                }\n\n                let _ = writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError);\n\n                //Remaining Length\n                write_u16(\u0026mut writer, packet_id)?;\n\n                write_string(\u0026mut writer, topic_name)?;\n\n                //Properties\n                let _ = properties\n                    .write_properties(\u0026mut writer)\n                    .map_err(|_e| ProtocolError::WriteError);\n\n                //Payload\n                payload.write_to(\u0026mut writer)?;\n\n                let _ = writer.flush().map_err(|_e| ProtocolError::WriteError);\n                Ok(())\n            }\n            ClientMessage::Subscribe {\n                packet_id,\n                properties,\n                payload,\n            } =\u003e {\n                // fixed header\n                let byte_1: u8 = 0x82_u8;\n                writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError)?;\n\n                // variable header\n                write_u16(\u0026mut writer, packet_id)?;\n\n                //Properties\n                properties.write_properties(\u0026mut writer)?;\n\n                // escribir largo del payload\n                let payload_length = payload.len() as u32;\n                write_u32(\u0026mut writer, \u0026payload_length)?;\n\n                // payload\n                for subscription in payload {\n                    write_string(\u0026mut writer, \u0026subscription.topic)?;\n                    write_string(\u0026mut writer, \u0026subscription.client_id)?;\n                    write_u8(\u0026mut writer, \u0026subscription.qos)?;\n                }\n\n                writer.flush().map_err(|_e| ProtocolError::WriteError)?;\n                Ok(())\n            }\n            ClientMessage::Unsubscribe {\n                packet_id,\n                properties,\n                payload,\n            } =\u003e {\n                // fixed header\n                self.write_first_packet_byte(\u0026mut writer)?;\n\n                // variable header\n                write_u16(\u0026mut writer, packet_id)?;\n\n                // variable header\n                properties.write_properties(\u0026mut writer)?;\n\n                // escribir largo del payload\n                let payload_length = payload.len() as u32;\n                write_u32(\u0026mut writer, \u0026payload_length)?;\n\n                //payload\n                for subscription in payload {\n                    write_string(\u0026mut writer, \u0026subscription.topic)?;\n                    write_string(\u0026mut writer, \u0026subscription.client_id)?;\n                    write_u8(\u0026mut writer, \u0026subscription.qos)?;\n                }\n\n                writer.flush().map_err(|_e| ProtocolError::WriteError)?;\n                Ok(())\n            }\n            ClientMessage::Disconnect {\n                reason_code,\n                session_expiry_interval,\n                reason_string,\n                client_id,\n            } =\u003e {\n                //fixed header\n                let header: u8 = 0xE0_u8.to_le(); //11100000\n                write_u8(\u0026mut writer, \u0026header)?;\n\n                //variable_header\n                write_u8(\u0026mut writer, reason_code)?;\n\n                write_u8(\u0026mut writer, \u0026SESSION_EXPIRY_INTERVAL_ID)?;\n                write_u32(\u0026mut writer, session_expiry_interval)?;\n\n                write_u8(\u0026mut writer, \u0026REASON_STRING_ID)?;\n                write_string(\u0026mut writer, reason_string)?;\n\n                write_string(\u0026mut writer, client_id)?;\n\n                let _ = writer.flush().map_err(|_e| ProtocolError::WriteError);\n                Ok(())\n            }\n            ClientMessage::Pingreq =\u003e {\n                let byte_1: u8 = 0xC0_u8;\n                let _ = writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError);\n                let _ = writer.flush().map_err(|_e| ProtocolError::WriteError);\n                Ok(())\n            }\n            ClientMessage::Auth {\n                reason_code,\n                authentication_method: _,\n                authentication_data: _,\n                reason_string: _,\n                user_properties: _,\n            } =\u003e {\n                println!(\"authenticating user...\");\n                self.write_first_packet_byte(\u0026mut writer)?;\n\n                write_u8(\u0026mut writer, reason_code)?;\n                self.write_packet_properties(\u0026mut writer)?;\n                writer.flush().map_err(|_e| ProtocolError::WriteError)?;\n\n                Ok(())\n            }\n        }\n    }\n\n    fn write_first_packet_byte(\n        \u0026self,\n        writer: \u0026mut BufWriter\u003c\u0026mut dyn Write\u003e,\n    ) -\u003e Result\u003c(), ProtocolError\u003e {\n        match self {\n            ClientMessage::Connect { .. } =\u003e {\n                let byte_1: u8 = 0x10_u8.to_le(); //00010000\n                writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError)?;\n            }\n            ClientMessage::Publish {\n                packet_id: _,\n                topic_name: _,\n                qos,\n                retain_flag,\n                payload: _,\n                dup_flag,\n                properties: _,\n            } =\u003e {\n                let mut byte_1 = 0x30_u8;\n\n                if *retain_flag == 1 {\n                    //we must replace any existing retained message for this topic and store\n                    //the app message.\n                    byte_1 |= 1 \u003c\u003c 0;\n                }\n\n                if *qos == 1 {\n                    byte_1 |= 1 \u003c\u003c 1;\n                    byte_1 |= 0 \u003c\u003c 2;\n                } else if *qos != 0x00 \u0026\u0026 *qos != 0x01 {\n                    //we should throw a DISCONNECT with reason code 0x81(Malformed packet).\n                    println!(\"Qos inválido\");\n                }\n\n                if *dup_flag == 1 {\n                    byte_1 |= 1 \u003c\u003c 3;\n                }\n\n                //Dup flag must be set to 0 for all QoS 0 messages.\n                if *qos == 0x00 {\n                    byte_1 |= 0 \u003c\u003c 3;\n                }\n\n                match writer.write_all(\u0026[byte_1]) {\n                    Ok(_) =\u003e {}\n                    Err(_) =\u003e {\n                        return Err(ProtocolError::WriteError);\n                    }\n                }\n            }\n            ClientMessage::Subscribe {\n                packet_id: _,\n                properties: _,\n                payload: _,\n            } =\u003e {\n                let byte_1: u8 = 0x82_u8;\n                println!(\"estoy mandnado el header {:?}\", byte_1);\n                writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError)?;\n            }\n            ClientMessage::Unsubscribe {\n                packet_id: _,\n                properties: _,\n                payload: _,\n            } =\u003e {\n                let byte_1: u8 = 0xA2_u8;\n                writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError)?;\n            }\n            ClientMessage::Disconnect {\n                reason_code: _,\n                session_expiry_interval: _,\n                reason_string: _,\n                client_id: _,\n            } =\u003e {\n                let byte_1: u8 = 0xE0_u8;\n                writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError)?;\n            }\n            ClientMessage::Pingreq =\u003e {\n                let byte_1: u8 = 0xC0_u8;\n                writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError)?;\n            }\n            ClientMessage::Auth {\n                reason_code: _,\n                authentication_method: _,\n                authentication_data: _,\n                reason_string: _,\n                user_properties: _,\n            } =\u003e {\n                let byte_1 = 0xF0_u8;\n                writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError)?;\n            }\n        }\n        Ok(())\n    }\n\n    fn write_packet_properties(\n        \u0026self,\n        mut writer: \u0026mut BufWriter\u003c\u0026mut dyn Write\u003e,\n    ) -\u003e Result\u003c(), ProtocolError\u003e {\n        match self {\n            ClientMessage::Connect { .. } =\u003e Ok(()),\n            ClientMessage::Publish {\n                packet_id,\n                topic_name,\n                qos: _,\n                retain_flag: _,\n                payload: _,\n                dup_flag: _,\n                properties,\n            } =\u003e {\n                write_u16(writer, packet_id)?;\n\n                write_string(writer, topic_name)?;\n\n                //Properties\n                properties.write_properties(writer)?;\n                Ok(())\n            }\n            ClientMessage::Subscribe {\n                packet_id,\n                properties,\n                payload,\n            } =\u003e {\n                write_u16(writer, packet_id)?;\n\n                //Properties\n                properties.write_properties(writer)?;\n\n                // escribir largo del payload\n                let payload_length = payload.len() as u32;\n                write_u32(writer, \u0026payload_length)?;\n\n                // payload\n                for subscription in payload {\n                    write_string(writer, \u0026subscription.topic)?;\n                    write_string(writer, \u0026subscription.client_id)?;\n                    write_u8(writer, \u0026subscription.qos)?;\n                }\n                Ok(())\n            }\n            ClientMessage::Unsubscribe {\n                packet_id,\n                properties,\n                payload,\n            } =\u003e {\n                write_u16(writer, packet_id)?;\n\n                // variable header\n                properties.write_properties(writer)?;\n\n                // escribir largo del payload\n                let payload_length = payload.len() as u32;\n                write_u32(writer, \u0026payload_length)?;\n\n                //payload\n                for subscription in payload {\n                    write_string(writer, \u0026subscription.topic)?;\n                    write_string(writer, \u0026subscription.client_id)?;\n                    write_u8(writer, \u0026subscription.qos)?;\n                }\n                Ok(())\n            }\n            ClientMessage::Disconnect {\n                reason_code,\n                session_expiry_interval,\n                reason_string,\n                client_id,\n            } =\u003e {\n                //fixed header\n                let header: u8 = 0xE0_u8.to_le(); //11100000\n                write_u8(writer, \u0026header)?;\n                //variable_header\n                write_u8(writer, reason_code)?;\n\n                write_u8(writer, \u0026SESSION_EXPIRY_INTERVAL_ID)?;\n                write_u32(writer, session_expiry_interval)?;\n\n                write_u8(writer, \u0026REASON_STRING_ID)?;\n                write_string(writer, reason_string)?;\n\n                write_string(writer, client_id)?;\n\n                writer.flush().map_err(|_e| ProtocolError::WriteError)?;\n\n                Ok(())\n            }\n            ClientMessage::Pingreq =\u003e {\n                let byte_1: u8 = 0xC0_u8;\n                writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError)?;\n                writer.flush().map_err(|_e| ProtocolError::WriteError)?;\n                Ok(())\n            }\n            ClientMessage::Auth {\n                reason_code,\n                authentication_method,\n                authentication_data,\n                reason_string,\n                user_properties,\n            } =\u003e {\n                let byte_1 = 0xF0_u8;\n                let _ = writer\n                    .write_all(\u0026[byte_1])\n                    .map_err(|_e| ProtocolError::WriteError);\n\n                write_u8(\u0026mut writer, reason_code).map_err(|_e| ProtocolError::WriteError)?;\n\n                let authentication_method_id: u8 = 0x15_u8;\n                let _ = writer\n                    .write_all(\u0026[authentication_method_id])\n                    .map_err(|_e| ProtocolError::WriteError);\n                write_string(\u0026mut writer, authentication_method)?;\n\n                let authentication_data_id: u8 = 0x16_u8;\n                let _ = writer\n                    .write_all(\u0026[authentication_data_id])\n                    .map_err(|_e| ProtocolError::WriteError);\n                write_bin_vec(\u0026mut writer, authentication_data)?;\n\n                let reason_string_id: u8 = 0x1F_u8;\n                let _ = writer\n                    .write_all(\u0026[reason_string_id])\n                    .map_err(|_e| ProtocolError::WriteError);\n                write_string(\u0026mut writer, reason_string)?;\n\n                let user_properties_id: u8 = 0x26_u8; // 38\n                let _ = writer\n                    .write_all(\u0026[user_properties_id])\n                    .map_err(|_e| ProtocolError::WriteError);\n                write_tuple_vec(\u0026mut writer, user_properties)?;\n\n                let _ = writer.flush().map_err(|_e| ProtocolError::WriteError);\n\n                Ok(())\n            }\n        }\n    }\n\n    pub fn read_from(stream: \u0026mut impl Read) -\u003e Result\u003cClientMessage, Error\u003e {\n        let mut header = [0u8; 1];\n        stream.read_exact(\u0026mut header)?;\n\n        let mut header = u8::from_le_bytes(header);\n        let (mut dup_flag, mut qos, mut retain_flag) = (0, 0, 0);\n\n        let first_header_digits = header \u003e\u003e 4;\n        if first_header_digits == 0x3 {\n            let mask = 0b00001111;\n            let last_header_digits = header \u0026 mask;\n\n            header = 0x30_u8.to_le();\n\n            if last_header_digits \u0026 0b00000001 == 0b00000001 {\n                retain_flag = 1;\n            }\n            if last_header_digits \u0026 0b00000010 == 0b00000010 {\n                qos = 1;\n            }\n            if (last_header_digits \u003e\u003e 3) == 1 {\n                dup_flag = 1;\n            }\n        }\n\n        match header {\n            0x10 =\u003e {\n                //leo el protocol name\n\n                let connect = Connect::read_from(stream)?;\n\n                Ok(ClientMessage::Connect(connect))\n            }\n            0x30 =\u003e {\n                println!(\"Reading publish message\");\n\n                let packet_id = read_u16(stream)?;\n                let topic_name = read_string(stream)?;\n                let properties = PublishProperties::read_from(stream)?;\n\n                let payload = PayloadTypes::read_from(stream)?;\n\n                Ok(ClientMessage::Publish {\n                    packet_id,\n                    topic_name,\n                    qos,\n                    retain_flag,\n                    payload,\n                    dup_flag,\n                    properties,\n                })\n            }\n            0x82 =\u003e {\n                let packet_id = read_u16(stream)?;\n\n                let properties = SubscribeProperties::read_properties(stream)?;\n\n                let payload_length = read_u32(stream)?;\n                let mut payload = Vec::with_capacity(payload_length as usize);\n\n                for _ in 0..payload_length {\n                    let topic = read_string(stream)?;\n                    if topic.is_empty() {\n                        return Err(Error::new(std::io::ErrorKind::Other, \"Invalid topic name\"));\n                    }\n                    let client_id = read_string(stream)?;\n                    let qos = read_u8(stream)?;\n\n                    payload.push(Subscription {\n                        topic,\n                        client_id,\n                        qos,\n                    });\n                }\n\n                Ok(ClientMessage::Subscribe {\n                    packet_id,\n                    properties,\n                    payload,\n                })\n            }\n            0xA2 =\u003e {\n                let packet_id = read_u16(stream)?;\n\n                let properties = SubscribeProperties::read_properties(stream)?;\n\n                let payload_length = read_u32(stream)?;\n                let mut payload = Vec::with_capacity(payload_length as usize);\n\n                for _ in 0..payload_length {\n                    let topic = read_string(stream)?;\n                    let client_id = read_string(stream)?;\n                    let qos = read_u8(stream)?;\n\n                    payload.push(Subscription {\n                        topic,\n                        client_id,\n                        qos,\n                    });\n                }\n\n                Ok(ClientMessage::Unsubscribe {\n                    packet_id,\n                    properties,\n                    payload,\n                })\n            }\n            0xE0 =\u003e {\n                let reason_code = read_u8(stream)?;\n                let session_expiry_interval_id = read_u8(stream)?;\n                if session_expiry_interval_id != SESSION_EXPIRY_INTERVAL_ID {\n                    return Err(Error::new(\n                        std::io::ErrorKind::Other,\n                        \"Invalid session expiry interval id\",\n                    ));\n                }\n                let session_expiry_interval = read_u32(stream)?;\n\n                let reason_string_id = read_u8(stream)?;\n                if reason_string_id != REASON_STRING_ID {\n                    return Err(Error::new(\n                        std::io::ErrorKind::Other,\n                        \"Invalid reason string id\",\n                    ));\n                }\n                let reason_string = read_string(stream)?;\n\n                let client_id = read_string(stream)?;\n\n                Ok(ClientMessage::Disconnect {\n                    reason_code,\n                    session_expiry_interval,\n                    reason_string,\n                    client_id,\n                })\n            }\n            0xC0 =\u003e Ok(ClientMessage::Pingreq),\n            0xF0 =\u003e {\n                let reason_code = read_u8(stream)?;\n                let mut authentication_method: Option\u003cString\u003e = None;\n                let mut authentication_data: Option\u003cVec\u003cu8\u003e\u003e = None;\n                let mut reason_string: Option\u003cString\u003e = None;\n                let mut user_properties: Option\u003cVec\u003c(String, String)\u003e\u003e = None;\n\n                let mut count = 0;\n                while let Ok(property_id) = read_u8(stream) {\n                    match property_id {\n                        0x15 =\u003e {\n                            let value = read_string(stream)?;\n                            authentication_method = Some(value);\n                        }\n                        0x16 =\u003e {\n                            let value = read_bin_vec(stream)?;\n                            authentication_data = Some(value);\n                        }\n                        0x26 =\u003e {\n                            let value = read_tuple_vec(stream)?;\n                            user_properties = Some(value);\n                        }\n                        0x1F =\u003e {\n                            let value = read_string(stream)?;\n                            reason_string = Some(value);\n                        }\n                        _ =\u003e {\n                            return Err(Error::new(ErrorKind::InvalidData, \"Property ID inválido\"));\n                        }\n                    }\n                    count += 1;\n                    if count == 4 {\n                        break;\n                    }\n                }\n\n                Ok(ClientMessage::Auth {\n                    reason_code,\n                    user_properties: user_properties.ok_or(Error::new(\n                        ErrorKind::InvalidData,\n                        \"Missing user_properties property\",\n                    ))?,\n                    authentication_method: authentication_method.ok_or(Error::new(\n                        ErrorKind::InvalidData,\n                        \"Missing authentication_method property\",\n                    ))?,\n                    authentication_data: authentication_data.ok_or(Error::new(\n                        ErrorKind::InvalidData,\n                        \"Missing authentication_data property\",\n                    ))?,\n                    reason_string: reason_string.ok_or(Error::new(\n                        ErrorKind::InvalidData,\n                        \"Missing reason_string property\",\n                    ))?,\n                })\n            }\n            _ =\u003e Err(Error::new(std::io::ErrorKind::Other, \"Invalid header\")),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::io::Cursor;\n\n    use crate::{\n        monitoring::incident::Incident,\n        mqtt::{\n            connect::{connect_properties::ConnectProperties, will_properties::WillProperties},\n            publish::publish_properties::TopicProperties,\n        },\n        utils::{incident_payload::IncidentPayload, location::Location},\n    };\n\n    use super::*;\n    fn read_json_to_connect_config(json_data: \u0026str) -\u003e Result\u003cConnect, Box\u003cdyn std::error::Error\u003e\u003e {\n        let connect_config: Connect = serde_json::from_str(json_data)?;\n        Ok(connect_config)\n    }\n    #[test]\n    fn test_01_connect_message_ok() {\n        let connect_read = Connect::read_connect(\"./src/monitoring/connect_config.json\").unwrap();\n\n        let connect = ClientMessage::Connect(connect_read.clone());\n\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        match connect.write_to(\u0026mut cursor) {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                panic!(\"no se pudo escribir en el cursor {:?}\", e);\n            }\n        }\n\n        cursor.set_position(0);\n\n        match ClientMessage::read_from(\u0026mut cursor) {\n            Ok(_) =\u003e {\n                assert_eq!(\n                    connect,\n                    crate::mqtt::client_message::ClientMessage::Connect(connect_read)\n                );\n            }\n            Err(e) =\u003e {\n                panic!(\"no se pudo leer del cursor {:?}\", e);\n            }\n        }\n    }\n\n    #[test]\n    fn test_02_connect_without_props_err() {\n        let connect = ClientMessage::Connect(Connect::new(\n            true,\n            true,\n            1,\n            true,\n            35,\n            ConnectProperties::new(\n                30,\n                1,\n                20,\n                20,\n                true,\n                true,\n                vec![(\"hola\".to_string(), \"chau\".to_string())],\n                \"password-based\".to_string(),\n                vec![1, 2, 3],\n            ),\n            \"kvtr33\".to_string(),\n            WillProperties::new(\n                1,\n                1,\n                1,\n                \"a\".to_string(),\n                \"a\".to_string(),\n                [1, 2, 3].to_vec(),\n                vec![(\"a\".to_string(), \"a\".to_string())],\n            ),\n            \"camera system\".to_string(),\n            \"soy el monitoring y me desconecte\".to_string(),\n            \"a\".to_string(),\n            \"a\".to_string(),\n        ));\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        match connect.write_to(\u0026mut cursor) {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                panic!(\"no se pudo escribir en el cursor {:?}\", e);\n            }\n        }\n        cursor.set_position(0);\n\n        match ClientMessage::read_from(\u0026mut cursor) {\n            Ok(read_connect) =\u003e {\n                assert_eq!(connect, read_connect);\n            }\n            Err(e) =\u003e {\n                panic!(\"no se pudo leer del cursor {:?}\", e);\n            }\n        }\n    }\n\n    #[test]\n    fn test_03_publish_message_ok() {\n        let topic_properties = TopicProperties {\n            topic_alias: 10,\n            response_topic: \"String\".to_string(),\n        };\n\n        let properties = PublishProperties::new(\n            1,\n            10,\n            topic_properties,\n            [1, 2, 3].to_vec(),\n            \"a\".to_string(),\n            1,\n            \"a\".to_string(),\n        );\n\n        let location = Location::new(12.1, 25.0);\n        let incident = Incident::new(location);\n\n        let payload = PayloadTypes::IncidentLocation(IncidentPayload::new(incident));\n\n        let publish = ClientMessage::Publish {\n            packet_id: 1,\n            topic_name: \"mensajes para juan\".to_string(),\n            qos: 1,\n            retain_flag: 1,\n            payload,\n            dup_flag: 1,\n            properties,\n        };\n\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        match publish.write_to(\u0026mut cursor) {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                panic!(\"no se pudo escribir en el cursor {:?}\", e);\n            }\n        }\n        cursor.set_position(0);\n\n        match ClientMessage::read_from(\u0026mut cursor) {\n            Ok(read_publish) =\u003e {\n                // println!(\"{:?}\", read_publish);\n                assert_eq!(publish, read_publish);\n            }\n            Err(e) =\u003e {\n                panic!(\"no se pudo leer del cursor {:?}\", e);\n            }\n        }\n    }\n\n    #[test]\n    fn test_04_subscribe_ok() {\n        let vector = vec![Subscription {\n            topic: \"topic\".to_string(),\n            client_id: \"client\".to_string(),\n            qos: 1,\n        }];\n\n        let sub = ClientMessage::Subscribe {\n            packet_id: 1,\n            properties: SubscribeProperties::new(\n                1,\n                vec![(\"propiedad\".to_string(), \"valor\".to_string())],\n            ),\n            payload: vector,\n        };\n\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        match sub.write_to(\u0026mut cursor) {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                panic!(\"no se pudo escribir en el cursor {:?}\", e);\n            }\n        };\n        cursor.set_position(0);\n        let read_sub = match ClientMessage::read_from(\u0026mut cursor) {\n            Ok(sub) =\u003e sub,\n            Err(e) =\u003e {\n                panic!(\"no se pudo leer del cursor {:?}\", e);\n            }\n        };\n\n        println!(\"{:?}\", read_sub);\n        println!(\"{:?}\", sub);\n        assert_eq!(sub, read_sub);\n    }\n\n    #[test]\n    fn test_05_unsubscribe_ok() {\n        let vector = vec![Subscription {\n            topic: \"topic\".to_string(),\n            client_id: \"client\".to_string(),\n            qos: 1,\n        }];\n\n        let unsub = ClientMessage::Unsubscribe {\n            packet_id: 1,\n            properties: SubscribeProperties::new(\n                1,\n                vec![(\"propiedad\".to_string(), \"valor\".to_string())],\n            ),\n            payload: vector,\n        };\n\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        match unsub.write_to(\u0026mut cursor) {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                panic!(\"no se pudo escribir en el cursor {:?}\", e);\n            }\n        }\n        cursor.set_position(0);\n        let read_unsub = match ClientMessage::read_from(\u0026mut cursor) {\n            Ok(unsub) =\u003e unsub,\n            Err(e) =\u003e {\n                panic!(\"no se pudo leer del cursor {:?}\", e);\n            }\n        };\n\n        assert_eq!(unsub, read_unsub);\n    }\n\n    #[test]\n    fn test_06_disconnect_ok() {\n        let disconect = ClientMessage::Disconnect {\n            reason_code: 1,\n            session_expiry_interval: 1,\n            reason_string: \"hola\".to_string(),\n            client_id: \"client\".to_string(),\n        };\n\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        match disconect.write_to(\u0026mut cursor) {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                panic!(\"no se pudo escribir en el cursor {:?}\", e);\n            }\n        }\n        cursor.set_position(0);\n        let read_disconect = match ClientMessage::read_from(\u0026mut cursor) {\n            Ok(disconect) =\u003e disconect,\n            Err(e) =\u003e {\n                panic!(\"no se pudo leer del cursor {:?}\", e);\n            }\n        };\n        assert_eq!(disconect, read_disconect);\n    }\n\n    // #\n    // fn test_07_auth_ok() {\n    //     let auth = ClientMessage::Auth {\n    //         reason_code: 0x00_u8,\n    //         authentication_method: \"password-based\".to_string(),\n    //         authentication_data: vec![],\n    //         reason_string: \"usuario no encontrado\".to_string(),\n    //         user_properties: vec![(\"propiedad\".to_string(), \"valor\".to_string())],\n    //     };\n\n    //     let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n    //     match auth.write_to(\u0026mut cursor) {\n    //         Ok(_) =\u003e {}\n    //         Err(e) =\u003e {\n    //             panic!(\"no se pudo escribir en el cursor {:?}\", e);\n    //         }\n    //     }\n    //     cursor.set_position(0);\n    //     let read_auth = match ClientMessage::read_from(\u0026mut cursor) {\n    //         Ok(auth) =\u003e auth,\n    //         Err(e) =\u003e {\n    //             panic!(\"no se pudo leer del cursor {:?}\", e);\n    //         }\n    //     };\n    //     assert_eq!(auth, read_auth);\n    // }\n\n    #[test]\n    fn test_07_connect_with_invalid_qos_throws_err() -\u003e std::io::Result\u003c()\u003e {\n        let connect = ClientMessage::Connect(Connect::new(\n            true,\n            true,\n            1,\n            true,\n            35,\n            ConnectProperties::new(\n                30,\n                1,\n                20,\n                20,\n                true,\n                true,\n                vec![(\"hola\".to_string(), \"chau\".to_string())],\n                \"password-based\".to_string(),\n                vec![1, 2, 3],\n            ),\n            \"kvtr33\".to_string(),\n            WillProperties::new(\n                1,\n                1,\n                1,\n                \"a\".to_string(),\n                \"a\".to_string(),\n                [1, 2, 3].to_vec(),\n                vec![(\"a\".to_string(), \"a\".to_string())],\n            ),\n            \"camera system\".to_string(),\n            \"soy el monitoring y me desconecte\".to_string(),\n            \"a\".to_string(),\n            \"a\".to_string(),\n        ));\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n\n        match connect.write_to(\u0026mut cursor) {\n            Ok(_) =\u003e Ok(()),\n            Err(e) =\u003e {\n                println!(\"QoS invalida\");\n                assert_eq!(e, ProtocolError::InvalidQOS);\n                Ok(())\n            }\n        }\n    }\n\n    #[test]\n    fn test_01_config_creation_cases() {\n        let config_ok = Connect::read_connect_config(\"./src/monitoring/connect_config.json\");\n\n        let config_err = Connect::read_connect_config(\"este/es/un/path/feo\");\n\n        assert!(config_ok.is_ok());\n        assert!(config_err.is_err());\n    }\n\n    #[test]\n    fn test_02_config_without_last_will_msg_throws_err() {\n        let config_err = Connect::read_connect_config(\n            \"./tests/connect_config_test/config_without_will_msg.json\",\n        );\n\n        assert!(config_err.is_err());\n    }\n\n    #[test]\n    fn test_03_config_with_lat_will_invalid_qos_err() {\n        let config_err = Connect::read_connect_config(\n            \"./tests/connect_config_test/connect_config_invalid_qos.json\",\n        );\n\n        assert!(config_err.is_err());\n    }\n\n    #[test]\n    fn test_read_json_connect_config() {\n        let json_data = r#\"{\n            \"clean_start\": true,\n            \"last_will_flag\": true,\n            \"last_will_qos\": 1,\n            \"last_will_retain\": true,\n            \"keep_alive\": 35,\n            \"properties\": {\n                \"session_expiry_interval\": 30,\n                \"receive_maximum\": 1,\n                \"maximum_packet_size\": 20,\n                \"topic_alias_maximum\": 20,\n                \"request_response_information\": true,\n                \"request_problem_information\": true,\n                \"user_properties\": [\n                    [\n                        \"hola\",\n                        \"chau\"\n                    ]\n                ],\n                \"authentication_method\": \"password-based\",\n                \"authentication_data\": [\n                    1,\n                    2,\n                    3\n                ]\n            },\n            \"client_id\": \"kvtr33\",\n            \"will_properties\": {\n                \"last_will_delay_interval\": 1,\n                \"payload_format_indicator\": 1,\n                \"message_expiry_interval\": 1,\n                \"content_type\": \"a\",\n                \"response_topic\": \"a\",\n                \"correlation_data\": [\n                    1,\n                    2,\n                    3\n                ],\n                \"user_properties\": [\n                    [\n                        \"a\",\n                        \"a\"\n                    ]\n                ]\n            },\n            \"last_will_topic\": \"camera system\",\n            \"last_will_message\": \"soy el monitoring y me desconecte\",\n            \"username\": \"a\",\n            \"password\": [97]\n        }\"#;\n        let connect_config = read_json_to_connect_config(json_data).unwrap();\n        let expected_connect_config = Connect::new(\n            true,\n            true,\n            1,\n            true,\n            35,\n            ConnectProperties::new(\n                30,\n                1,\n                20,\n                20,\n                true,\n                true,\n                vec![(\"hola\".to_string(), \"chau\".to_string())],\n                \"password-based\".to_string(),\n                vec![1, 2, 3],\n            ),\n            \"kvtr33\".to_string(),\n            WillProperties::new(\n                1,\n                1,\n                1,\n                \"a\".to_string(),\n                \"a\".to_string(),\n                [1, 2, 3].to_vec(),\n                vec![(\"a\".to_string(), \"a\".to_string())],\n            ),\n            \"camera system\".to_string(),\n            \"soy el monitoring y me desconecte\".to_string(),\n            \"a\".to_string(),\n            \"a\".to_string(),\n        );\n        assert_eq!(connect_config, expected_connect_config);\n    }\n\n    #[test]\n    fn test_parse_message() {\n        let connect_properties = ConnectProperties::new(\n            30,\n            1,\n            20,\n            20,\n            true,\n            true,\n            vec![(\"hola\".to_string(), \"chau\".to_string())],\n            \"auth\".to_string(),\n            vec![1, 2, 3],\n        );\n\n        let will_properties = WillProperties::new(\n            1,\n            1,\n            1,\n            \"a\".to_string(),\n            \"a\".to_string(),\n            [1, 2, 3].to_vec(),\n            vec![(\"a\".to_string(), \"a\".to_string())],\n        );\n\n        let connect_config = Connect::new(\n            true,\n            true,\n            1,\n            true,\n            35,\n            connect_properties.clone(),\n            \"juancito\".to_string(),\n            will_properties.clone(),\n            \"camera system\".to_string(),\n            \"soy el monitoring y me desconecte\".to_string(),\n            \"a\".to_string(),\n            \"a\".to_string(),\n        );\n\n        let connect_message = connect_config.parse_message(1);\n\n        assert_eq!(\n            connect_message,\n            ClientMessage::Connect(connect_config.clone())\n        );\n    }\n\n    #[test]\n    fn test_parse_pingreq() {\n        let pingreq = ClientMessage::Pingreq;\n        let pingreq_message = pingreq.parse_message(1);\n\n        assert_eq!(pingreq_message, ClientMessage::Pingreq);\n    }\n}\n","traces":[{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":91},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":673,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":747,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":751,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":755,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":756,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":764,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":766,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":769,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":788,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":789,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":820,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":825,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":831,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":838,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":840,"address":[],"length":0,"stats":{"Line":135},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":85},"fn_name":null},{"line":843,"address":[],"length":0,"stats":{"Line":85},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":85},"fn_name":null},{"line":846,"address":[],"length":0,"stats":{"Line":85},"fn_name":null},{"line":847,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":848,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":850,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":856,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":858,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":859,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":863,"address":[],"length":0,"stats":{"Line":85},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":875,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":880,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":881,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":883,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":884,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":886,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":887,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":891,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":893,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":895,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":899,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":903,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":904,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":914,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":915,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":920,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":922,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":929,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":930,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":939,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":940,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":941,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":942,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":946,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":947,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":949,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":950,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":951,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":954,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":958,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":959,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":960,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":963,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":965,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":967,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":968,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":969,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":970,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":971,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":974,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":983,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":985,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":986,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":989,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":993,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":994,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":998,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1005,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1006,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1007,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1012,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1013,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1014,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1015,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1017,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1018,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1019,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1021,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1022,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1023,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1025,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1026,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1027,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":274,"coverable":476},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","client_return.rs"],"content":"#[derive(Debug, PartialEq)]\npub enum ClientReturn {\n    ConnackReceived,\n    PubackRecieved,\n    DisconnectRecieved,\n    DisconnectSent,\n    SubackRecieved,\n    PublishDeliveryRecieved,\n    UnsubackRecieved,\n    PingrespRecieved,\n    AuthRecieved,\n    PlaceHolder,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","connack_properties.rs"],"content":"use crate::utils::reader::*;\nuse crate::utils::writer::*;\nuse std::io::{BufWriter, Error, ErrorKind, Read, Write};\n\nuse super::protocol_error::ProtocolError;\n\n#[derive(Debug, PartialEq)]\npub struct ConnackProperties {\n    pub session_expiry_interval: u32,\n    pub receive_maximum: u16,\n    pub maximum_qos: bool,\n    pub retain_available: bool,\n    pub maximum_packet_size: u32,\n    pub assigned_client_identifier: String,\n    pub topic_alias_maximum: u16,\n    pub reason_string: String,\n    pub user_properties: Vec\u003c(String, String)\u003e,\n    pub wildcard_subscription_available: bool,\n    pub subscription_identifier_available: bool,\n    pub shared_subscription_available: bool,\n    pub server_keep_alive: u16,\n    pub response_information: String,\n    pub server_reference: String,\n    pub authentication_method: String,\n    pub authentication_data: Vec\u003cu8\u003e,\n}\n\nimpl ConnackProperties {\n    pub fn write_to(\u0026self, stream: \u0026mut dyn Write) -\u003e Result\u003c(), ProtocolError\u003e {\n        let mut writer = BufWriter::new(stream);\n\n        let session_expiry_interval_id: u8 = 0x11_u8; //17\n        let _ = writer\n            .write_all(\u0026[session_expiry_interval_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_u32(\u0026mut writer, \u0026self.session_expiry_interval)?;\n\n        let assigned_client_identifier_id: u8 = 0x12_u8; //18\n        let _ = writer\n            .write_all(\u0026[assigned_client_identifier_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_string(\u0026mut writer, \u0026self.assigned_client_identifier)?;\n\n        let authentication_method_id: u8 = 0x15_u8; //21\n        let _ = writer\n            .write_all(\u0026[authentication_method_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_string(\u0026mut writer, \u0026self.authentication_method)?;\n\n        let authentication_data_id: u8 = 0x16_u8; //22\n        let _ = writer\n            .write_all(\u0026[authentication_data_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_bin_vec(\u0026mut writer, \u0026self.authentication_data)?;\n\n        let response_information_id: u8 = 0x1A_u8; //26\n        let _ = writer\n            .write_all(\u0026[response_information_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_string(\u0026mut writer, \u0026self.response_information)?;\n\n        let server_reference_id: u8 = 0x1C_u8; //28\n        let _ = writer\n            .write_all(\u0026[server_reference_id])\n            .map_err(|_: Error| ProtocolError::WriteError);\n        write_string(\u0026mut writer, \u0026self.server_reference)?;\n\n        let reason_string_id: u8 = 0x1F_u8; //31\n        let _ = writer\n            .write_all(\u0026[reason_string_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_string(\u0026mut writer, \u0026self.reason_string)?;\n\n        let receive_maximum_id: u8 = 0x21_u8; //33\n        let _ = writer\n            .write_all(\u0026[receive_maximum_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_u16(\u0026mut writer, \u0026self.receive_maximum)?;\n\n        let topic_alias_maximum_id: u8 = 0x22_u8; //34\n        let _ = writer\n            .write_all(\u0026[topic_alias_maximum_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_u16(\u0026mut writer, \u0026self.topic_alias_maximum)?;\n\n        let maximum_qos_id: u8 = 0x24_u8; //36\n        let _ = writer\n            .write_all(\u0026[maximum_qos_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_bool(\u0026mut writer, \u0026self.maximum_qos)?;\n\n        let retain_available_id: u8 = 0x25_u8; //37\n        let _ = writer\n            .write_all(\u0026[retain_available_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_bool(\u0026mut writer, \u0026self.retain_available)?;\n\n        let user_properties_id: u8 = 0x26_u8; //38\n        let _ = writer\n            .write_all(\u0026[user_properties_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_tuple_vec(\u0026mut writer, \u0026self.user_properties)?;\n\n        let maximum_packet_size_id: u8 = 0x27_u8; //39\n        let _ = writer\n            .write_all(\u0026[maximum_packet_size_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_u32(\u0026mut writer, \u0026self.maximum_packet_size)?;\n\n        let wildcard_subscription_available_id: u8 = 0x28_u8; //40\n        let _ = writer\n            .write_all(\u0026[wildcard_subscription_available_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_bool(\u0026mut writer, \u0026self.wildcard_subscription_available)?;\n\n        let subscription_identifier_available_id: u8 = 0x29_u8; //41\n        let _ = writer\n            .write_all(\u0026[subscription_identifier_available_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_bool(\u0026mut writer, \u0026self.subscription_identifier_available)?;\n\n        let shared_subscription_available_id: u8 = 0x2A_u8; //42\n        let _ = writer\n            .write_all(\u0026[shared_subscription_available_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_bool(\u0026mut writer, \u0026self.shared_subscription_available)?;\n\n        let server_keep_alive_id: u8 = 0x2D_u8; //45\n        let _ = writer\n            .write_all(\u0026[server_keep_alive_id])\n            .map_err(|_| ProtocolError::WriteError);\n        write_u16(\u0026mut writer, \u0026self.server_keep_alive)?;\n\n        Ok(())\n    }\n\n    pub fn read_from(stream: \u0026mut dyn Read) -\u003e Result\u003cConnackProperties, Error\u003e {\n        let session_expiry_interval_id = read_u8(stream)?;\n        if session_expiry_interval_id != 0x11 {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid session expiry interval id\",\n            ));\n        }\n        let session_expiry_interval = read_u32(stream)?;\n\n        let assigned_client_identifier_id = read_u8(stream)?;\n        if assigned_client_identifier_id != 0x12 {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid assigned client identifier id\",\n            ));\n        }\n        let assigned_client_identifier = read_string(stream)?;\n\n        let authentication_method_id = read_u8(stream)?;\n        if authentication_method_id != 0x15 {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid authentication method id\",\n            ));\n        }\n        let authentication_method = read_string(stream)?;\n\n        let authentication_data_id = read_u8(stream)?;\n        if authentication_data_id != 0x16 {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid authentication data id\",\n            ));\n        }\n        let authentication_data = read_bin_vec(stream)?;\n\n        let response_information_id = read_u8(stream)?;\n        if response_information_id != 0x1A {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid response information id\",\n            ));\n        }\n        let response_information = read_string(stream)?;\n\n        let server_reference_id = read_u8(stream)?;\n        if server_reference_id != 0x1C {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid server reference id\",\n            ));\n        }\n        let server_reference = read_string(stream)?;\n\n        let reason_string_id = read_u8(stream)?;\n        if reason_string_id != 0x1F {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid reason string id\",\n            ));\n        }\n        let reason_string = read_string(stream)?;\n\n        let receive_maximum_id = read_u8(stream)?;\n        if receive_maximum_id != 0x21 {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid receive maximum id\",\n            ));\n        }\n        let receive_maximum = read_u16(stream)?;\n\n        let topic_alias_maximum_id = read_u8(stream)?;\n        if topic_alias_maximum_id != 0x22 {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid topic alias maximum id\",\n            ));\n        }\n        let topic_alias_maximum = read_u16(stream)?;\n\n        let maximum_qos_id = read_u8(stream)?;\n        if maximum_qos_id != 0x24 {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid maximum qos id\",\n            ));\n        }\n        let maximum_qos = read_bool(stream)?;\n\n        let retain_available_id = read_u8(stream)?;\n        if retain_available_id != 0x25 {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid retain available id\",\n            ));\n        }\n        let retain_available = read_bool(stream)?;\n\n        let user_properties_id = read_u8(stream)?;\n        if user_properties_id != 0x26 {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid user properties id\",\n            ));\n        }\n        let user_properties = read_tuple_vec(stream)?;\n\n        let maximum_packet_size_id = read_u8(stream)?;\n        if maximum_packet_size_id != 0x27 {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid maximum packet size id\",\n            ));\n        }\n        let maximum_packet_size = read_u32(stream)?;\n\n        let wildcard_subscription_available_id = read_u8(stream)?;\n        if wildcard_subscription_available_id != 0x28 {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid wildcard subscription available id\",\n            ));\n        }\n        let wildcard_subscription_available = read_bool(stream)?;\n\n        let subscription_identifier_available_id = read_u8(stream)?;\n        if subscription_identifier_available_id != 0x29 {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid subscription identifier available id\",\n            ));\n        }\n        let subscription_identifier_available = read_bool(stream)?;\n\n        let shared_subscription_available_id = read_u8(stream)?;\n        if shared_subscription_available_id != 0x2A {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid shared subscription available id\",\n            ));\n        }\n        let shared_subscription_available = read_bool(stream)?;\n\n        let server_keep_alive_id = read_u8(stream)?;\n        if server_keep_alive_id != 0x2D {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid server keep alive id\",\n            ));\n        }\n        let server_keep_alive = read_u16(stream)?;\n\n        Ok(ConnackProperties {\n            session_expiry_interval,\n            assigned_client_identifier,\n            authentication_method,\n            authentication_data,\n            response_information,\n            server_reference,\n            reason_string,\n            receive_maximum,\n            topic_alias_maximum,\n            maximum_qos,\n            retain_available,\n            user_properties,\n            maximum_packet_size,\n            wildcard_subscription_available,\n            subscription_identifier_available,\n            shared_subscription_available,\n            server_keep_alive,\n        })\n    }\n}\n\npub struct ConnackPropertiesBuilder {\n    session_expiry_interval: Option\u003cu32\u003e,\n    receive_maximum: Option\u003cu16\u003e,\n    maximum_qos: Option\u003cbool\u003e,\n    retain_available: Option\u003cbool\u003e,\n    maximum_packet_size: Option\u003cu32\u003e,\n    assigned_client_identifier: Option\u003cString\u003e,\n    topic_alias_maximum: Option\u003cu16\u003e,\n    reason_string: Option\u003cString\u003e,\n    user_properties: Option\u003cVec\u003c(String, String)\u003e\u003e,\n    wildcard_subscription_available: Option\u003cbool\u003e,\n    subscription_identifier_available: Option\u003cbool\u003e,\n    shared_subscription_available: Option\u003cbool\u003e,\n    server_keep_alive: Option\u003cu16\u003e,\n    response_information: Option\u003cString\u003e,\n    server_reference: Option\u003cString\u003e,\n    authentication_method: Option\u003cString\u003e,\n    authentication_data: Option\u003cVec\u003cu8\u003e\u003e,\n}\n\nimpl Default for ConnackPropertiesBuilder {\n    fn default() -\u003e Self {\n        ConnackPropertiesBuilder::new()\n    }\n}\n\nimpl ConnackPropertiesBuilder {\n    pub fn new() -\u003e ConnackPropertiesBuilder {\n        ConnackPropertiesBuilder {\n            session_expiry_interval: None,\n            receive_maximum: None,\n            maximum_qos: None,\n            retain_available: None,\n            maximum_packet_size: None,\n            assigned_client_identifier: None,\n            topic_alias_maximum: None,\n            reason_string: None,\n            user_properties: None,\n            wildcard_subscription_available: None,\n            subscription_identifier_available: None,\n            shared_subscription_available: None,\n            server_keep_alive: None,\n            response_information: None,\n            server_reference: None,\n            authentication_method: None,\n            authentication_data: None,\n        }\n    }\n\n    pub fn session_expiry_interval(mut self, value: u32) -\u003e Self {\n        self.session_expiry_interval = Some(value);\n        self\n    }\n\n    pub fn receive_maximum(mut self, value: u16) -\u003e Self {\n        self.receive_maximum = Some(value);\n        self\n    }\n\n    pub fn maximum_qos(mut self, value: bool) -\u003e Self {\n        self.maximum_qos = Some(value);\n        self\n    }\n\n    pub fn retain_available(mut self, value: bool) -\u003e Self {\n        self.retain_available = Some(value);\n        self\n    }\n\n    pub fn maximum_packet_size(mut self, value: u32) -\u003e Self {\n        self.maximum_packet_size = Some(value);\n        self\n    }\n\n    pub fn assigned_client_identifier(mut self, value: String) -\u003e Self {\n        self.assigned_client_identifier = Some(value);\n        self\n    }\n\n    pub fn topic_alias_maximum(mut self, value: u16) -\u003e Self {\n        self.topic_alias_maximum = Some(value);\n        self\n    }\n\n    pub fn reason_string(mut self, value: String) -\u003e Self {\n        self.reason_string = Some(value);\n        self\n    }\n\n    pub fn user_properties(mut self, value: Vec\u003c(String, String)\u003e) -\u003e Self {\n        self.user_properties = Some(value);\n        self\n    }\n\n    pub fn wildcard_subscription_available(mut self, value: bool) -\u003e Self {\n        self.wildcard_subscription_available = Some(value);\n        self\n    }\n\n    pub fn subscription_identifier_available(mut self, value: bool) -\u003e Self {\n        self.subscription_identifier_available = Some(value);\n        self\n    }\n\n    pub fn shared_subscription_available(mut self, value: bool) -\u003e Self {\n        self.shared_subscription_available = Some(value);\n        self\n    }\n\n    pub fn server_keep_alive(mut self, value: u16) -\u003e Self {\n        self.server_keep_alive = Some(value);\n        self\n    }\n\n    pub fn response_information(mut self, value: String) -\u003e Self {\n        self.response_information = Some(value);\n        self\n    }\n\n    pub fn server_reference(mut self, value: String) -\u003e Self {\n        self.server_reference = Some(value);\n        self\n    }\n\n    pub fn authentication_method(mut self, value: String) -\u003e Self {\n        self.authentication_method = Some(value);\n        self\n    }\n\n    pub fn authentication_data(mut self, value: Vec\u003cu8\u003e) -\u003e Self {\n        self.authentication_data = Some(value);\n        self\n    }\n\n    pub fn build(self) -\u003e Result\u003cConnackProperties, Error\u003e {\n        Ok(ConnackProperties {\n            session_expiry_interval: self.session_expiry_interval.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing session_expiry_interval property\",\n            ))?,\n            receive_maximum: self.receive_maximum.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing receive_maximum property\",\n            ))?,\n            maximum_qos: self.maximum_qos.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing maximum_qos property\",\n            ))?,\n            retain_available: self.retain_available.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing retain_available property\",\n            ))?,\n            maximum_packet_size: self.maximum_packet_size.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing maximum_packet_size property\",\n            ))?,\n            assigned_client_identifier: self.assigned_client_identifier.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing assigned_client_identifier property\",\n            ))?,\n            topic_alias_maximum: self.topic_alias_maximum.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing topic_alias_maximum property\",\n            ))?,\n            reason_string: self.reason_string.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing reason_string property\",\n            ))?,\n            user_properties: self.user_properties.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing user_properties property\",\n            ))?,\n            wildcard_subscription_available: self.wildcard_subscription_available.ok_or(\n                Error::new(\n                    ErrorKind::InvalidData,\n                    \"Missing wildcard_subscription_available property\",\n                ),\n            )?,\n            subscription_identifier_available: self.subscription_identifier_available.ok_or(\n                Error::new(\n                    ErrorKind::InvalidData,\n                    \"Missing subscription_identifier_available property\",\n                ),\n            )?,\n            shared_subscription_available: self.shared_subscription_available.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing shared_subscription_available property\",\n            ))?,\n            server_keep_alive: self.server_keep_alive.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing server_keep_alive property\",\n            ))?,\n            response_information: self.response_information.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing response_information property\",\n            ))?,\n            server_reference: self.server_reference.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing server_reference property\",\n            ))?,\n            authentication_method: self.authentication_method.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing authentication_method property\",\n            ))?,\n            authentication_data: self.authentication_data.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing authentication_data property\",\n            ))?,\n        })\n    }\n}\n\n#[cfg(test)]\n#[test]\n\nfn test_read_write() {\n    let mut buffer = vec![];\n    let properties = ConnackPropertiesBuilder::new()\n        .session_expiry_interval(0)\n        .receive_maximum(0)\n        .maximum_qos(false)\n        .retain_available(false)\n        .maximum_packet_size(0)\n        .assigned_client_identifier(\"propiedad\".to_string())\n        .topic_alias_maximum(0)\n        .reason_string(\"propiedad\".to_string())\n        .user_properties(vec![(\"propiedad\".to_string(), \"valor\".to_string())])\n        .wildcard_subscription_available(false)\n        .subscription_identifier_available(false)\n        .shared_subscription_available(false)\n        .server_keep_alive(0)\n        .response_information(\"propiedad\".to_string())\n        .server_reference(\"propiedad\".to_string())\n        .authentication_method(\"propiedad\".to_string())\n        .authentication_data(vec![0, 1, 2, 3])\n        .build()\n        .unwrap();\n    properties.write_to(\u0026mut buffer).unwrap();\n    let mut buffer = buffer.as_slice();\n    let read_properties = ConnackProperties::read_from(\u0026mut buffer).unwrap();\n    assert_eq!(properties, read_properties);\n}\n\n#[test]\nfn test_builder() {\n    let properties = ConnackPropertiesBuilder::new()\n        .session_expiry_interval(0)\n        .receive_maximum(0)\n        .maximum_qos(false)\n        .retain_available(false)\n        .maximum_packet_size(0)\n        .assigned_client_identifier(\"propiedad\".to_string())\n        .topic_alias_maximum(0)\n        .reason_string(\"propiedad\".to_string())\n        .user_properties(vec![(\"propiedad\".to_string(), \"valor\".to_string())])\n        .wildcard_subscription_available(false)\n        .subscription_identifier_available(false)\n        .shared_subscription_available(false)\n        .server_keep_alive(0)\n        .response_information(\"propiedad\".to_string())\n        .server_reference(\"propiedad\".to_string())\n        .authentication_method(\"propiedad\".to_string())\n        .authentication_data(vec![0, 1, 2, 3])\n        .build()\n        .unwrap();\n    assert_eq!(properties.session_expiry_interval, 0);\n    assert_eq!(properties.receive_maximum, 0);\n    assert!(!properties.maximum_qos);\n    assert!(!properties.retain_available);\n    assert_eq!(properties.maximum_packet_size, 0);\n    assert_eq!(\n        properties.assigned_client_identifier,\n        \"propiedad\".to_string()\n    );\n    assert_eq!(properties.topic_alias_maximum, 0);\n    assert_eq!(properties.reason_string, \"propiedad\".to_string());\n    assert_eq!(\n        properties.user_properties,\n        vec![(\"propiedad\".to_string(), \"valor\".to_string())]\n    );\n    assert!(!properties.wildcard_subscription_available);\n    assert!(!properties.subscription_identifier_available);\n    assert!(!properties.shared_subscription_available);\n    assert_eq!(properties.server_keep_alive, 0);\n    assert_eq!(properties.response_information, \"propiedad\".to_string());\n    assert_eq!(properties.server_reference, \"propiedad\".to_string());\n    assert_eq!(properties.authentication_method, \"propiedad\".to_string());\n    assert_eq!(properties.authentication_data, vec![0, 1, 2, 3]);\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":232,"coverable":301},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","connect","connect_properties.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse std::io::{BufReader, BufWriter, Error, ErrorKind, Read, Write};\n\nuse crate::mqtt::protocol_error::ProtocolError;\nuse crate::utils::{reader::*, writer::*};\n\n/// Contiene las propiedades de un Connect packet.\n#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]\npub struct ConnectProperties {\n    pub session_expiry_interval: u32,\n    pub receive_maximum: u16,\n    pub maximum_packet_size: u32,\n    pub topic_alias_maximum: u16,\n    pub request_response_information: bool,\n    pub request_problem_information: bool,\n    pub user_properties: Vec\u003c(String, String)\u003e,\n    pub authentication_method: String,\n    pub authentication_data: Vec\u003cu8\u003e,\n}\n\nimpl ConnectProperties {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        session_expiry_interval: u32,\n        receive_maximum: u16,\n        maximum_packet_size: u32,\n        topic_alias_maximum: u16,\n        request_response_information: bool,\n        request_problem_information: bool,\n        user_properties: Vec\u003c(String, String)\u003e,\n        authentication_method: String,\n        authentication_data: Vec\u003cu8\u003e,\n    ) -\u003e ConnectProperties {\n        ConnectProperties {\n            session_expiry_interval,\n            receive_maximum,\n            maximum_packet_size,\n            topic_alias_maximum,\n            request_response_information,\n            request_problem_information,\n            user_properties,\n            authentication_method,\n            authentication_data,\n        }\n    }\n\n    pub fn write_to(\u0026self, stream: \u0026mut dyn Write) -\u003e Result\u003c(), ProtocolError\u003e {\n        let mut writer = BufWriter::new(stream);\n\n        let session_expiry_interval_id: u8 = 0x11_u8;\n\n        let _ = writer\n            .write_all(\u0026[session_expiry_interval_id])\n            .map_err(|_e| ProtocolError::WriteError);\n        write_u32(\u0026mut writer, \u0026self.session_expiry_interval)?;\n\n        let authentication_method_id: u8 = 0x15_u8;\n        let _ = writer\n            .write_all(\u0026[authentication_method_id])\n            .map_err(|_e| ProtocolError::WriteError);\n        write_string(\u0026mut writer, \u0026self.authentication_method)?;\n\n        let authentication_data_id: u8 = 0x16_u8;\n        let _ = writer\n            .write_all(\u0026[authentication_data_id])\n            .map_err(|_e| ProtocolError::WriteError);\n        write_bin_vec(\u0026mut writer, \u0026self.authentication_data)?;\n\n        let request_problem_information_id: u8 = 0x17_u8;\n        let _ = writer\n            .write_all(\u0026[request_problem_information_id])\n            .map_err(|_e| ProtocolError::WriteError);\n        write_bool(\u0026mut writer, \u0026self.request_problem_information)?;\n\n        let request_response_information_id: u8 = 0x19_u8; // 25\n\n        let _ = writer\n            .write_all(\u0026[request_response_information_id])\n            .map_err(|_e| ProtocolError::WriteError);\n        write_bool(\u0026mut writer, \u0026self.request_response_information)?;\n\n        let receive_maximum_id: u8 = 0x21_u8; // 33\n        let _ = writer\n            .write_all(\u0026[receive_maximum_id])\n            .map_err(|_e| ProtocolError::WriteError);\n        write_u16(\u0026mut writer, \u0026self.receive_maximum)?;\n\n        let topic_alias_maximum_id: u8 = 0x22_u8; // 34\n        let _ = writer\n            .write_all(\u0026[topic_alias_maximum_id])\n            .map_err(|_e| ProtocolError::WriteError);\n        write_u16(\u0026mut writer, \u0026self.topic_alias_maximum)?;\n\n        let user_properties_id: u8 = 0x26_u8; // 38\n        let _ = writer\n            .write_all(\u0026[user_properties_id])\n            .map_err(|_e| ProtocolError::WriteError);\n        write_tuple_vec(\u0026mut writer, \u0026self.user_properties)?;\n\n        let maximum_packet_size_id: u8 = 0x27_u8; // 39\n        let _ = writer\n            .write_all(\u0026[maximum_packet_size_id])\n            .map_err(|_e| ProtocolError::WriteError);\n        write_u32(\u0026mut writer, \u0026self.maximum_packet_size)?;\n\n        Ok(())\n    }\n\n    pub fn read_from(stream: \u0026mut dyn Read) -\u003e Result\u003cConnectProperties, Error\u003e {\n        let mut reader = BufReader::new(stream);\n\n        let mut session_expiry_interval: Option\u003cu32\u003e = None;\n        let mut receive_maximum: Option\u003cu16\u003e = None;\n        let mut maximum_packet_size: Option\u003cu32\u003e = None;\n        let mut topic_alias_maximum: Option\u003cu16\u003e = None;\n        let mut request_response_information: Option\u003cbool\u003e = None;\n        let mut request_problem_information: Option\u003cbool\u003e = None;\n        let mut user_properties: Option\u003cVec\u003c(String, String)\u003e\u003e = None;\n        let mut authentication_method: Option\u003cString\u003e = None;\n        let mut authentication_data: Option\u003cVec\u003cu8\u003e\u003e = None;\n        let mut count = 0;\n        while let Ok(property_id) = read_u8(\u0026mut reader) {\n            match property_id {\n                0x11 =\u003e {\n                    let value = read_u32(\u0026mut reader)?;\n                    session_expiry_interval = Some(value);\n                }\n                0x15 =\u003e {\n                    let value = read_string(\u0026mut reader)?;\n                    authentication_method = Some(value);\n                }\n                0x16 =\u003e {\n                    let value = read_bin_vec(\u0026mut reader)?;\n                    authentication_data = Some(value);\n                }\n                0x17 =\u003e {\n                    let value = read_bool(\u0026mut reader)?;\n                    request_problem_information = Some(value);\n                }\n                0x19 =\u003e {\n                    let value = read_bool(\u0026mut reader)?;\n                    request_response_information = Some(value);\n                }\n                0x21 =\u003e {\n                    let value = read_u16(\u0026mut reader)?;\n                    receive_maximum = Some(value);\n                }\n                0x22 =\u003e {\n                    let value = read_u16(\u0026mut reader)?;\n                    topic_alias_maximum = Some(value);\n                }\n                0x26 =\u003e {\n                    let value = read_tuple_vec(\u0026mut reader)?;\n                    user_properties = Some(value);\n                }\n                0x27 =\u003e {\n                    let value = read_u32(\u0026mut reader)?;\n                    maximum_packet_size = Some(value);\n                }\n                _ =\u003e {\n                    return Err(Error::new(ErrorKind::InvalidData, \"Property ID inválido\"));\n                }\n            }\n            count += 1;\n            if count == 9 {\n                break;\n            }\n        }\n\n        Ok(ConnectProperties {\n            session_expiry_interval: session_expiry_interval.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing session_expiry_interval property\",\n            ))?,\n            receive_maximum: receive_maximum.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing receive_maximum property\",\n            ))?,\n            maximum_packet_size: maximum_packet_size.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing maximum_packet_size property\",\n            ))?,\n            topic_alias_maximum: topic_alias_maximum.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing topic_alias_maximum property\",\n            ))?,\n            request_response_information: request_response_information.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing request_response_information property\",\n            ))?,\n            request_problem_information: request_problem_information.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing request_problem_information property\",\n            ))?,\n            user_properties: user_properties.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing user_properties property\",\n            ))?,\n            authentication_method: authentication_method.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing authentication_method property\",\n            ))?,\n            authentication_data: authentication_data.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing authentication_data property\",\n            ))?,\n        })\n    }\n}\n\n#[derive(Default)]\npub struct ConnectPropertiesBuilder {\n    session_expiry_interval: Option\u003cu32\u003e,\n    receive_maximum: Option\u003cu16\u003e,\n    maximum_packet_size: Option\u003cu32\u003e,\n    topic_alias_maximum: Option\u003cu16\u003e,\n    request_response_information: Option\u003cbool\u003e,\n    request_problem_information: Option\u003cbool\u003e,\n    user_properties: Option\u003cVec\u003c(String, String)\u003e\u003e,\n    authentication_method: Option\u003cString\u003e,\n    authentication_data: Option\u003cVec\u003cu8\u003e\u003e,\n}\n\nimpl ConnectPropertiesBuilder {\n    pub fn create(self) -\u003e Result\u003cConnectProperties, Error\u003e {\n        Ok(ConnectProperties {\n            session_expiry_interval: self.session_expiry_interval.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing session_expiry_interval property\",\n            ))?,\n            receive_maximum: self.receive_maximum.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing receive_maximum property\",\n            ))?,\n            maximum_packet_size: self.maximum_packet_size.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing maximum_packet_size property\",\n            ))?,\n            topic_alias_maximum: self.topic_alias_maximum.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing topic_alias_maximum property\",\n            ))?,\n            request_response_information: self.request_response_information.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing request_response_information property\",\n            ))?,\n            request_problem_information: self.request_problem_information.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing request_problem_information property\",\n            ))?,\n            user_properties: self.user_properties.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing user_properties property\",\n            ))?,\n            authentication_method: self.authentication_method.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing authentication_method property\",\n            ))?,\n            authentication_data: self.authentication_data.ok_or(Error::new(\n                ErrorKind::InvalidData,\n                \"Missing authentication_data property\",\n            ))?,\n        })\n    }\n\n    pub fn session_expiry_interval(mut self, value: u32) -\u003e Self {\n        self.session_expiry_interval = Some(value);\n        self\n    }\n\n    pub fn receive_maximum(mut self, value: u16) -\u003e Self {\n        self.receive_maximum = Some(value);\n        self\n    }\n\n    pub fn maximum_packet_size(mut self, value: u32) -\u003e Self {\n        self.maximum_packet_size = Some(value);\n        self\n    }\n\n    pub fn topic_alias_maximum(mut self, value: u16) -\u003e Self {\n        self.topic_alias_maximum = Some(value);\n        self\n    }\n\n    pub fn request_response_information(mut self, value: bool) -\u003e Self {\n        self.request_response_information = Some(value);\n        self\n    }\n\n    pub fn request_problem_information(mut self, value: bool) -\u003e Self {\n        self.request_problem_information = Some(value);\n        self\n    }\n\n    pub fn user_properties(mut self, value: Vec\u003c(String, String)\u003e) -\u003e Self {\n        self.user_properties = Some(value);\n        self\n    }\n\n    pub fn authentication_method(mut self, value: String) -\u003e Self {\n        self.authentication_method = Some(value);\n        self\n    }\n\n    pub fn authentication_data(mut self, value: Vec\u003cu8\u003e) -\u003e Self {\n        self.authentication_data = Some(value);\n        self\n    }\n}\n#[allow(dead_code)]\n\nfn read_json_to_connect_properties(json_data: \u0026str) -\u003e Result\u003cConnectProperties, Error\u003e {\n    let connect_properties: ConnectProperties = serde_json::from_str(json_data)?;\n    Ok(connect_properties)\n}\n#[cfg(test)]\nmod tests {\n    use core::panic;\n    use std::io::Cursor;\n\n    use super::*;\n\n    #[test]\n    fn test_read_json_to_connect_properties() {\n        let json_data = r#\"{\n            \"session_expiry_interval\": 30,\n            \"receive_maximum\": 1,\n            \"maximum_packet_size\": 20,\n            \"topic_alias_maximum\": 20,\n            \"request_response_information\": true,\n            \"request_problem_information\": true,\n            \"user_properties\": [\n                [\n                    \"hola\",\n                    \"chau\"\n                ]\n            ],\n            \"authentication_method\": \"password-based\",\n            \"authentication_data\": [\n                1,\n                2,\n                3\n            ]\n        }\"#;\n        let connect_properties = read_json_to_connect_properties(json_data).unwrap();\n        let expected_connect_properties = ConnectProperties::new(\n            30,\n            1,\n            20,\n            20,\n            true,\n            true,\n            vec![(\"hola\".to_string(), \"chau\".to_string())],\n            \"password-based\".to_string(),\n            vec![1, 2, 3],\n        );\n        assert_eq!(connect_properties, expected_connect_properties);\n    }\n\n    #[test]\n    fn test_01_connect_properties_ok() {\n        let mut buffer = Cursor::new(Vec::new());\n        let connect_properties = ConnectProperties {\n            session_expiry_interval: 1,\n            receive_maximum: 2,\n            maximum_packet_size: 10,\n            topic_alias_maximum: 99,\n            request_response_information: true,\n            request_problem_information: false,\n            user_properties: vec![\n                (\"Hola\".to_string(), \"Mundo\".to_string()),\n                (\"Chau\".to_string(), \"Mundo\".to_string()),\n            ],\n            authentication_method: \"test\".to_string(),\n            authentication_data: vec![1_u8, 2_u8, 3_u8, 4_u8, 5_u8],\n        };\n\n        match connect_properties.write_to(\u0026mut buffer) {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                println!(\"Error: {:?}\", e);\n                panic!();\n            }\n        }\n        buffer.set_position(0);\n\n        let connect_properties_read = match ConnectProperties::read_from(\u0026mut buffer) {\n            Ok(properties) =\u003e properties,\n            Err(e) =\u003e {\n                println!(\"Error: {:?}\", e);\n\n                panic!();\n            }\n        };\n        assert_eq!(connect_properties, connect_properties_read);\n    }\n\n    #[test]\n    fn connect_properties_builder() {\n        let connect_properties = ConnectPropertiesBuilder::default()\n            .session_expiry_interval(1)\n            .receive_maximum(2)\n            .maximum_packet_size(10)\n            .topic_alias_maximum(99)\n            .request_response_information(true)\n            .request_problem_information(false)\n            .user_properties(vec![\n                (\"Hola\".to_string(), \"Mundo\".to_string()),\n                (\"Chau\".to_string(), \"Mundo\".to_string()),\n            ])\n            .authentication_method(\"test\".to_string())\n            .authentication_data(vec![1_u8, 2_u8, 3_u8, 4_u8, 5_u8])\n            .create()\n            .unwrap();\n\n        assert_eq!(connect_properties.session_expiry_interval, 1);\n        assert_eq!(connect_properties.receive_maximum, 2);\n        assert_eq!(connect_properties.maximum_packet_size, 10);\n        assert_eq!(connect_properties.topic_alias_maximum, 99);\n        assert!(connect_properties.request_response_information);\n        assert!(!connect_properties.request_problem_information);\n        assert_eq!(\n            connect_properties.user_properties,\n            vec![\n                (\"Hola\".to_string(), \"Mundo\".to_string()),\n                (\"Chau\".to_string(), \"Mundo\".to_string()),\n            ]\n        );\n        assert_eq!(connect_properties.authentication_method, \"test\");\n        assert_eq!(\n            connect_properties.authentication_data,\n            vec![1_u8, 2_u8, 3_u8, 4_u8, 5_u8]\n        );\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":918},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":459},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":459},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":160,"coverable":169},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","connect","last_will.rs"],"content":"use super::will_properties::WillProperties;\n\npub struct LastWill {\n    topic: String,\n    message: String,\n    qos: u8,\n    retain: bool,\n    properties: WillProperties,\n}\n\nimpl LastWill {\n    pub fn new(\n        topic: String,\n        message: String,\n        qos: u8,\n        retain: bool,\n        properties: WillProperties,\n    ) -\u003e LastWill {\n        LastWill {\n            topic,\n            message,\n            qos,\n            retain,\n            properties,\n        }\n    }\n\n    pub fn get_topic(\u0026self) -\u003e \u0026String {\n        \u0026self.topic\n    }\n\n    pub fn get_message(\u0026self) -\u003e \u0026String {\n        \u0026self.message\n    }\n\n    pub fn get_qos(\u0026self) -\u003e u8 {\n        self.qos\n    }\n\n    pub fn get_retain(\u0026self) -\u003e bool {\n        self.retain\n    }\n\n    pub fn get_properties(\u0026self) -\u003e \u0026WillProperties {\n        \u0026self.properties\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":11},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","connect","will_properties.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse std::io::BufWriter;\nuse std::io::Error;\nuse std::io::Read;\nuse std::io::Write;\n\nuse crate::mqtt::protocol_error::ProtocolError;\nuse crate::mqtt::publish::publish_properties::PublishProperties;\nuse crate::mqtt::publish::publish_properties::TopicProperties;\nuse crate::utils::{reader::*, writer::*};\n\nconst WILL_DELAY_INTERVAL_ID: u8 = 0x18;\nconst PAYLOAD_FORMAT_INDICATOR_ID: u8 = 0x01;\nconst MESSAGE_EXPIRY_INTERVAL_ID: u8 = 0x02;\nconst CONTENT_TYPE_ID: u8 = 0x03;\nconst RESPONSE_TOPIC_ID: u8 = 0x08;\nconst CORRELATION_DATA_ID: u8 = 0x09;\nconst USER_PROPERTIES_ID: u8 = 0x26;\n\n#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]\n/// last_will_delay_interval especifica el tiempo en segundos que el broker debe esperar antes de publicar el will message.\n///\n/// payload_format_indicator indica si el payload esta encodado en utf-8 o no.\n/// message_expiry_interval especifica el tiempo en segundos que el broker debe esperar antes de descartar el will message.\n/// content_type especifica el tipo de contenido del will message. (ej json, plain text)\n/// el response_topic es el el topic name que debera usar el mensaje de respuesta. Si hay response_topic, el will message se considera un request message.\n///\n/// `The Correlation Data is used by the sender of the Request Message to identify which request the Response Message is for when it is received`\n///\n/// user_property especifica una propiedad del usuario que se envia en el mensaje, se pueden enviar 0, 1 o más propiedades.\npub struct WillProperties {\n    last_will_delay_interval: u32,\n    payload_format_indicator: u8,\n    message_expiry_interval: u16,\n    content_type: String,\n    response_topic: String,\n    correlation_data: Vec\u003cu8\u003e,\n    user_properties: Vec\u003c(String, String)\u003e,\n}\n\nimpl WillProperties {\n    pub fn new(\n        last_will_delay_interval: u32,\n        payload_format_indicator: u8,\n        message_expiry_interval: u16,\n        content_type: String,\n        response_topic: String,\n        correlation_data: Vec\u003cu8\u003e,\n        user_properties: Vec\u003c(String, String)\u003e,\n    ) -\u003e WillProperties {\n        WillProperties {\n            last_will_delay_interval,\n            payload_format_indicator,\n            message_expiry_interval,\n            content_type,\n            response_topic,\n            correlation_data,\n            user_properties,\n        }\n    }\n    pub fn write_to(\u0026self, stream: \u0026mut dyn Write) -\u003e Result\u003c(), ProtocolError\u003e {\n        let mut writer = BufWriter::new(stream);\n        //will properties\n        write_u8(\u0026mut writer, \u0026WILL_DELAY_INTERVAL_ID)?;\n\n        write_u32(\u0026mut writer, \u0026self.last_will_delay_interval)?;\n\n        let payload_format_indicator = 0x01_u8;\n        //siempre 1 porque los strings en rust siempre son utf-8\n        write_u8(\u0026mut writer, \u0026PAYLOAD_FORMAT_INDICATOR_ID)?;\n        write_u8(\u0026mut writer, \u0026payload_format_indicator)?;\n\n        write_u8(\u0026mut writer, \u0026MESSAGE_EXPIRY_INTERVAL_ID)?;\n\n        write_u16(\u0026mut writer, \u0026self.message_expiry_interval)?;\n\n        write_u8(\u0026mut writer, \u0026CONTENT_TYPE_ID)?;\n        write_string(\u0026mut writer, \u0026self.content_type)?;\n\n        write_u8(\u0026mut writer, \u0026RESPONSE_TOPIC_ID)?;\n        write_string(\u0026mut writer, \u0026self.response_topic)?;\n\n        write_u8(\u0026mut writer, \u0026CORRELATION_DATA_ID)?;\n        let correlation_data_length = self.correlation_data.len() as u16;\n        write_u16(\u0026mut writer, \u0026correlation_data_length)?;\n        for byte in \u0026self.correlation_data {\n            write_u8(\u0026mut writer, byte)?;\n        }\n        //user property\n\n        write_u8(\u0026mut writer, \u0026USER_PROPERTIES_ID)?;\n        let user_properties_length = self.user_properties.len() as u16;\n        write_u16(\u0026mut writer, \u0026user_properties_length)?;\n        for (key, value) in \u0026self.user_properties {\n            write_string(\u0026mut writer, key)?;\n            write_string(\u0026mut writer, value)?;\n        }\n\n        Ok(())\n    }\n\n    pub fn read_from(stream: \u0026mut dyn Read) -\u003e Result\u003cWillProperties, Error\u003e {\n        //will properties\n        let will_delay_interval_id = read_u8(stream)?;\n        if will_delay_interval_id != WILL_DELAY_INTERVAL_ID {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid will delay interval id\",\n            ));\n        }\n        let will_delay_interval = read_u32(stream)?;\n\n        let payload_format_indicator_id = read_u8(stream)?;\n        if payload_format_indicator_id != PAYLOAD_FORMAT_INDICATOR_ID {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid payload format indicator id\",\n            ));\n        }\n        let payload_format_indicator = read_u8(stream)?;\n\n        let message_expiry_interval_id = read_u8(stream)?;\n        if message_expiry_interval_id != MESSAGE_EXPIRY_INTERVAL_ID {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid message expiry interval id\",\n            ));\n        }\n        let message_expiry_interval = read_u16(stream)?;\n        let content_type_id = read_u8(stream)?;\n        if content_type_id != CONTENT_TYPE_ID {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid content type id\",\n            ));\n        }\n        let content_type = read_string(stream)?;\n\n        let response_topic_id = read_u8(stream)?;\n        if response_topic_id != RESPONSE_TOPIC_ID {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid response topic id\",\n            ));\n        }\n        let response_topic = read_string(stream)?;\n\n        let correlation_data_id = read_u8(stream)?;\n        if correlation_data_id != CORRELATION_DATA_ID {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid correlation data id\",\n            ));\n        }\n        let correlation_data_length = read_u16(stream)?;\n        let mut correlation_data = vec![0; correlation_data_length as usize];\n        stream.read_exact(\u0026mut correlation_data)?;\n\n        //user property\n        let user_properties_id = read_u8(stream)?;\n        if user_properties_id != USER_PROPERTIES_ID {\n            return Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Invalid user properties id\",\n            ));\n        }\n        let mut user_properties = Vec::new();\n        let user_properties_lenght = read_u16(stream)?;\n        for _ in 0..user_properties_lenght {\n            let user_properties_key = read_string(stream)?;\n            let user_properties_value = read_string(stream)?;\n            user_properties.push((user_properties_key, user_properties_value));\n        }\n\n        Ok(WillProperties {\n            last_will_delay_interval: will_delay_interval,\n            payload_format_indicator,\n            message_expiry_interval,\n            content_type,\n            response_topic,\n            correlation_data,\n            user_properties,\n        })\n    }\n\n    pub fn get_last_will_delay_interval(\u0026self) -\u003e u32 {\n        self.last_will_delay_interval\n    }\n    /// Convierte las will properties en publish properties\n    pub fn to_publish_properties(\u0026self) -\u003e PublishProperties {\n        let topic_properties = TopicProperties {\n            topic_alias: 10,\n            response_topic: \"String\".to_string(),\n        };\n        let binding = (\"\".to_string(), \"\".to_string());\n        let first_property = match self.user_properties.first() {\n            Some(property) =\u003e property,\n            None =\u003e \u0026binding,\n        };\n        PublishProperties::new(\n            self.payload_format_indicator,\n            self.message_expiry_interval as u32,\n            topic_properties,\n            self.correlation_data.clone(),\n            first_property.0.clone(),\n            3,\n            self.response_topic.clone(),\n        )\n    }\n}\n#[allow(dead_code)]\nfn read_json_to_will_properties(json_data: \u0026str) -\u003e Result\u003cWillProperties, Error\u003e {\n    let will_properties: WillProperties = serde_json::from_str(json_data)?;\n    Ok(will_properties)\n}\n#[cfg(test)]\nmod tests {\n    use std::io::Cursor;\n\n    use super::*;\n\n    #[test]\n    fn test_read_json_to_will_properties() {\n        let json_data = r#\"{\n            \"last_will_delay_interval\": 1,\n            \"payload_format_indicator\": 1,\n            \"message_expiry_interval\": 1,\n            \"content_type\": \"a\",\n            \"response_topic\": \"a\",\n            \"correlation_data\": [\n                1,\n                2,\n                3\n            ],\n            \"user_properties\": [\n                [\n                    \"a\",\n                    \"a\"\n                ]\n            ]\n        }\"#;\n        let will_properties = read_json_to_will_properties(json_data).unwrap();\n        let expected_will_properties = WillProperties::new(\n            1,\n            1,\n            1,\n            \"a\".to_string(),\n            \"a\".to_string(),\n            vec![1, 2, 3],\n            vec![(\"a\".to_string(), \"a\".to_string())],\n        );\n        assert_eq!(will_properties, expected_will_properties);\n    }\n    #[test]\n    fn test_01_will_properties_ok() {\n        let will_properties = WillProperties::new(\n            120,\n            1,\n            30,\n            \"plain\".to_string(),\n            \"topic\".to_string(),\n            vec![1, 2, 3, 4, 5],\n            vec![(\"propiedad\".to_string(), \"valor\".to_string())],\n        );\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        match will_properties.write_to(\u0026mut cursor) {\n            Ok(_) =\u003e (),\n            Err(err) =\u003e panic!(\"Error writing will properties: {:?}\", err),\n        };\n        cursor.set_position(0);\n\n        let read_will_properties = match WillProperties::read_from(\u0026mut cursor) {\n            Ok(properties) =\u003e properties,\n            Err(err) =\u003e panic!(\"Error reading will properties: {:?}\", err),\n        };\n\n        assert_eq!(will_properties, read_will_properties);\n    }\n\n    #[test]\n    fn test_to_publish_properties() {\n        let will_properties = WillProperties::new(\n            120,\n            1,\n            30,\n            \"plain\".to_string(),\n            \"topic\".to_string(),\n            vec![1, 2, 3, 4, 5],\n            vec![(\"propiedad\".to_string(), \"valor\".to_string())],\n        );\n        let publish_properties = will_properties.to_publish_properties();\n        let expected_publish_properties = PublishProperties::new(\n            1,\n            30,\n            TopicProperties {\n                topic_alias: 10,\n                response_topic: \"String\".to_string(),\n            },\n            vec![1, 2, 3, 4, 5],\n            \"propiedad\".to_string(),\n            3,\n            \"topic\".to_string(),\n        );\n        assert_eq!(publish_properties, expected_publish_properties);\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":404},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":57,"coverable":84},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","connect_config.rs"],"content":"use crate::mqtt::{connect_properties::ConnectProperties, will_properties::WillProperties};\n\nuse super::{client_message::ClientMessage, messages_config::MessagesConfig};\n#[derive(Clone)]\npub struct ConnectConfig {\n    pub(crate) clean_start: bool,\n    pub(crate) last_will_flag: bool,\n    pub(crate) last_will_qos: u8,\n    pub(crate) last_will_retain: bool,\n    pub(crate) keep_alive: u16,\n    pub(crate) properties: ConnectProperties,\n    pub(crate) client_id: String,\n    pub(crate) will_properties: WillProperties,\n    pub(crate) last_will_topic: String,\n    pub(crate) last_will_message: String,\n    pub(crate) username: String,\n    pub(crate) password: String,\n}\n\nimpl MessagesConfig for ConnectConfig {\n    fn parse_message(\u0026self, _packet_id: u16) -\u003e ClientMessage {\n        ClientMessage::Connect {\n            clean_start: self.clean_start,\n            last_will_flag: self.last_will_flag,\n            last_will_qos: self.last_will_qos,\n            last_will_retain: self.last_will_retain,\n            keep_alive: self.keep_alive,\n            properties: self.properties.clone(),\n            client_id: self.client_id.clone(),\n            will_properties: self.will_properties.clone(),\n            last_will_topic: self.last_will_topic.clone(),\n            last_will_message: self.last_will_message.clone(),\n            username: self.username.clone(),\n            password: self.password.clone(),\n        }\n    }\n}\n\nimpl ConnectConfig {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        clean_start: bool,\n        last_will_flag: bool,\n        last_will_qos: u8,\n        last_will_retain: bool,\n        keep_alive: u16,\n        properties: ConnectProperties,\n        client_id: String,\n        will_properties: WillProperties,\n        last_will_topic: String,\n        last_will_message: String,\n        username: String,\n        password: String,\n    ) -\u003e ConnectConfig {\n        ConnectConfig {\n            clean_start,\n            last_will_flag,\n            last_will_qos,\n            last_will_retain,\n            keep_alive,\n            properties,\n            client_id,\n            will_properties,\n            last_will_topic,\n            last_will_message,\n            username,\n            password,\n        }\n    }\n}\n\n#[cfg(test)]\n#[test]\n\nfn test_parse_message() {\n    let connect_properties = ConnectProperties::new(\n        30,\n        1,\n        20,\n        20,\n        true,\n        true,\n        vec![(\"hola\".to_string(), \"chau\".to_string())],\n        \"auth\".to_string(),\n        vec![1, 2, 3],\n    );\n\n    let will_properties = WillProperties::new(\n        1,\n        1,\n        1,\n        \"a\".to_string(),\n        \"a\".to_string(),\n        [1, 2, 3].to_vec(),\n        vec![(\"a\".to_string(), \"a\".to_string())],\n    );\n\n    let connect_config = ConnectConfig::new(\n        true,\n        true,\n        1,\n        true,\n        35,\n        connect_properties.clone(),\n        \"juancito\".to_string(),\n        will_properties.clone(),\n        \"camera system\".to_string(),\n        \"soy el monitoring y me desconecte\".to_string(),\n        \"a\".to_string(),\n        \"a\".to_string(),\n    );\n\n    let connect_message = connect_config.parse_message(1);\n\n    assert_eq!(\n        connect_message,\n        ClientMessage::Connect {\n            clean_start: true,\n            last_will_flag: true,\n            last_will_qos: 1,\n            last_will_retain: true,\n            keep_alive: 35,\n            properties: connect_properties,\n            client_id: \"juancito\".to_string(),\n            will_properties,\n            last_will_topic: \"camera system\".to_string(),\n            last_will_message: \"soy el monitoring y me desconecte\".to_string(),\n            username: \"a\".to_string(),\n            password: \"a\".to_string(),\n        }\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","error.rs"],"content":"#[derive(Debug)]\npub struct ClientError {\n    message: String,\n}\n\nimpl ClientError {\n    pub fn new(message: \u0026str) -\u003e Self {\n        Self {\n            message: message.to_string(),\n        }\n    }\n}\n\nimpl std::fmt::Display for ClientError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.message)\n    }\n}\n\nimpl std::error::Error for ClientError {}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_new_client_error() {\n        let error = ClientError::new(\"error message\");\n        assert_eq!(error.to_string(), \"error message\");\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","messages_config.rs"],"content":"use crate::mqtt::client_message::ClientMessage;\n\npub trait MessagesConfig {\n    fn parse_message(\u0026self, packet_id: u16) -\u003e ClientMessage;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","payload.rs"],"content":"use std::{any::Any, fmt, io::Write};\n\nuse super::protocol_error::ProtocolError;\n\n/// La API del cliente le permite a sus usuarios enviar packets del tipo Publish.\n/// Dentro de este tipo de packets, hay un campo llamado Payload, que contiene el\n/// application message que el usuario de la API quiere enviar.\n///\n/// La idea es que el usuario haga uso de este trait, de forma tal que el que implemente\n/// este trait sea capaz de escribir y leer instancias de si mismo en un stream.\npub trait Payload {\n    fn write_to(\u0026self, stream: \u0026mut dyn Write) -\u003e Result\u003c(), ProtocolError\u003e;\n    fn as_any(\u0026self) -\u003e \u0026dyn Any;\n}\n\nimpl fmt::Debug for dyn Payload {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"Payload trait object\")\n    }\n}\n\nimpl dyn Payload {\n    pub fn is\u003cT: Any\u003e(\u0026self) -\u003e bool {\n        self.as_any().is::\u003cT\u003e()\n    }\n\n    pub fn downcast_ref\u003cT: Any\u003e(\u0026self) -\u003e Option\u003c\u0026T\u003e {\n        self.as_any().downcast_ref::\u003cT\u003e()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n\n    struct TestPayload {\n        pub value: u32,\n    }\n\n    impl Payload for TestPayload {\n        fn write_to(\u0026self, stream: \u0026mut dyn Write) -\u003e Result\u003c(), ProtocolError\u003e {\n            let value_string = self.value.to_string();\n            let _ = stream\n                .write_all(value_string.as_bytes())\n                .map_err(|_e| ProtocolError::WriteError);\n            Ok(())\n        }\n\n        fn as_any(\u0026self) -\u003e \u0026dyn Any {\n            self\n        }\n    }\n\n    #[test]\n    fn test_payload_trait() {\n        let payload = TestPayload { value: 42 };\n        let mut cursor = Cursor::new(Vec::new());\n\n        payload.write_to(\u0026mut cursor).unwrap();\n\n        let payload: \u0026dyn Payload = \u0026TestPayload { value: 42 };\n        assert!(payload.is::\u003cTestPayload\u003e());\n        assert_eq!(payload.downcast_ref::\u003cTestPayload\u003e().unwrap().value, 42);\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":6},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","protocol_error.rs"],"content":"use std::fmt;\n\n///Here are detailed all the errors that the protocol is capable of throwing.\n/// Unspecified se usa de placeholder para los results de los tests\n#[derive(Debug, PartialEq)]\npub enum ProtocolError {\n    ConectionError,\n    InvalidQOS,\n    InvalidNumberOfArguments,\n    StreamError,\n    ReadingTopicConfigFileError,\n    LockError,\n    PublishError,\n    SubscribeError,\n    UnsubscribeError,\n    UnspecifiedError,\n    PubackWithoutPendingID,\n    WriteError,\n    ReadingConfigFileError,\n    MissingWillMessageProperties,\n    ChanellError(String),\n    ReadingClientsFileError,\n    NotReceivedMessageError,\n    ExpectedConnack,\n    AuthError,\n    AbnormalDisconnection,\n    DroneError(String),\n    CameraError(String),\n    SendError(String),\n}\n\nimpl fmt::Display for ProtocolError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match *self {\n            ProtocolError::ConectionError =\u003e write!(f, \"Error al conectar al broker.\"),\n            ProtocolError::ReadingConfigFileError =\u003e {\n                write!(f, \"Error al leer el archivo de configuracion del connect.\")\n            }\n            ProtocolError::NotReceivedMessageError =\u003e {\n                write!(f, \"Error: no ha llegado ningun mensaje.\")\n            }\n            ProtocolError::AuthError =\u003e {\n                write!(f, \"Error al autenticar al cliente\")\n            }\n            ProtocolError::ExpectedConnack =\u003e {\n                write!(f, \"Error: no ha llegado un mensaje del tipo connack.\")\n            }\n            ProtocolError::ReadingClientsFileError =\u003e {\n                write!(f, \"Error al leer el archivo de clientes.\")\n            }\n            ProtocolError::MissingWillMessageProperties =\u003e {\n                write!(f, \"Error: faltan propiedades del will message.\")\n            }\n            ProtocolError::WriteError =\u003e write!(f, \"Error escribir el mensaje.\"),\n            ProtocolError::InvalidQOS =\u003e write!(f, \"Error: Valor de QoS inválido. Debe ser 0 o 1.\"),\n            ProtocolError::InvalidNumberOfArguments =\u003e {\n                write!(f, \"Error: número de argumentos inválido\")\n            }\n            ProtocolError::StreamError =\u003e write!(f, \"Error: Error en la creación de un stream.\"),\n            ProtocolError::LockError =\u003e write!(f, \"Error en Lock.\"),\n            ProtocolError::PublishError =\u003e write!(f, \"Error al realizar un publish.\"),\n            ProtocolError::SubscribeError =\u003e write!(f, \"Error al realizar la subscripcion.\"),\n            ProtocolError::UnsubscribeError =\u003e write!(f, \"Error al desuscribirse.\"),\n\n            ProtocolError::ReadingTopicConfigFileError =\u003e {\n                write!(f, \"Error al leer el archivo de configuración de tópicos\")\n            }\n            ProtocolError::PubackWithoutPendingID =\u003e {\n                write!(\n                    f,\n                    \"Error: Se recibió un Puback sin un ID en la lista de pending message\"\n                )\n            }\n            ProtocolError::UnspecifiedError =\u003e {\n                write!(f, \"Error no especificado\")\n            }\n            ProtocolError::ChanellError(ref err) =\u003e {\n                write!(\n                    f,\n                    \"Error al enviar o recibir mensajes por el canal: {}\",\n                    err\n                )\n            }\n            ProtocolError::AbnormalDisconnection =\u003e {\n                write!(f, \"Error: desconexión anormal.\")\n            }\n            ProtocolError::DroneError(ref err) =\u003e {\n                write!(f, \"Error de protocolo: {}\", err)\n            }\n            ProtocolError::CameraError(ref err) =\u003e {\n                write!(f, \"Error de protocolo: {}\", err)\n            }\n            ProtocolError::SendError(ref err) =\u003e {\n                write!(f, \"Error al enviar mensaje: {}\", err)\n            }\n        }\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_display_protocol_error() {\n    assert_eq!(\n        ProtocolError::ConectionError.to_string(),\n        \"Error al conectar al broker.\"\n    );\n    assert_eq!(\n        ProtocolError::InvalidQOS.to_string(),\n        \"Error: Valor de QoS inválido. Debe ser 0 o 1.\"\n    );\n    assert_eq!(\n        ProtocolError::InvalidNumberOfArguments.to_string(),\n        \"Error: número de argumentos inválido\"\n    );\n    assert_eq!(\n        ProtocolError::StreamError.to_string(),\n        \"Error: Error en la creación de un stream.\"\n    );\n    assert_eq!(ProtocolError::LockError.to_string(), \"Error en Lock.\");\n    assert_eq!(\n        ProtocolError::PublishError.to_string(),\n        \"Error al realizar un publish.\"\n    );\n    assert_eq!(\n        ProtocolError::SubscribeError.to_string(),\n        \"Error al realizar la subscripcion.\"\n    );\n    assert_eq!(\n        ProtocolError::UnsubscribeError.to_string(),\n        \"Error al desuscribirse.\"\n    );\n    assert_eq!(\n        ProtocolError::ReadingTopicConfigFileError.to_string(),\n        \"Error al leer el archivo de configuración de tópicos\"\n    );\n    assert_eq!(\n        ProtocolError::PubackWithoutPendingID.to_string(),\n        \"Error: Se recibió un Puback sin un ID en la lista de pending message\"\n    );\n    assert_eq!(\n        ProtocolError::UnspecifiedError.to_string(),\n        \"Error no especificado\"\n    );\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":15,"coverable":32},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","protocol_return.rs"],"content":"use std::fmt;\n\n#[derive(Debug, PartialEq)]\npub enum ProtocolReturn {\n    ConnackSent,\n    SubackSent,\n    PubackSent,\n    PingrespSent,\n    UnsubackSent,\n    DisconnectRecieved,\n    PlaceHolder,\n    DisconnectSent,\n    AuthRecieved,\n    NoAckSent,\n}\n\nimpl fmt::Display for ProtocolReturn {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match *self {\n            ProtocolReturn::ConnackSent =\u003e write!(f, \"Connack Enviado.\"),\n            ProtocolReturn::SubackSent =\u003e write!(f, \"Suback Enviado.\"),\n            ProtocolReturn::PubackSent =\u003e write!(f, \"Puback Enviado.\"),\n            ProtocolReturn::PingrespSent =\u003e write!(f, \"Pingresp Enviado.\"),\n            ProtocolReturn::UnsubackSent =\u003e write!(f, \"Unsuback Enviado.\"),\n            ProtocolReturn::DisconnectRecieved =\u003e write!(f, \"Disconnect Recibido.\"),\n            ProtocolReturn::PlaceHolder =\u003e write!(f, \"Placeholder.\"),\n            ProtocolReturn::DisconnectSent =\u003e write!(f, \"Disconnect Enviado.\"),\n            ProtocolReturn::AuthRecieved =\u003e write!(f, \"Auth Recibido.\"),\n            ProtocolReturn::NoAckSent =\u003e write!(f, \"No Ack Enviado.\"),\n        }\n    }\n}\n\n#[cfg(test)]\n\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display_protocol_return() {\n        assert_eq!(ProtocolReturn::ConnackSent.to_string(), \"Connack Enviado.\");\n        assert_eq!(ProtocolReturn::SubackSent.to_string(), \"Suback Enviado.\");\n        assert_eq!(ProtocolReturn::PubackSent.to_string(), \"Puback Enviado.\");\n        assert_eq!(\n            ProtocolReturn::PingrespSent.to_string(),\n            \"Pingresp Enviado.\"\n        );\n        assert_eq!(\n            ProtocolReturn::UnsubackSent.to_string(),\n            \"Unsuback Enviado.\"\n        );\n        assert_eq!(\n            ProtocolReturn::DisconnectRecieved.to_string(),\n            \"Disconnect Recibido.\"\n        );\n        assert_eq!(ProtocolReturn::PlaceHolder.to_string(), \"Placeholder.\");\n        assert_eq!(\n            ProtocolReturn::DisconnectSent.to_string(),\n            \"Disconnect Enviado.\"\n        );\n        assert_eq!(ProtocolReturn::AuthRecieved.to_string(), \"Auth Recibido.\");\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":11,"coverable":12},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","publish","publish_config.rs"],"content":"use std::{fs::File, io::BufReader};\n\nuse serde::Deserialize;\n\nuse crate::{\n    mqtt::{\n        client_message::ClientMessage, messages_config::MessagesConfig,\n        protocol_error::ProtocolError, publish::publish_properties::PublishProperties,\n    },\n    utils::payload_types::PayloadTypes,\n};\n\n#[derive(Deserialize, Debug, Clone, PartialEq)]\npub struct PublishConfig {\n    pub(crate) dup_flag: usize,\n    pub(crate) qos: usize,\n    pub(crate) retain_flag: usize,\n    pub(crate) topic_name: String,\n    pub(crate) payload: PayloadTypes,\n    pub(crate) publish_properties: PublishProperties,\n}\n\nimpl MessagesConfig for PublishConfig {\n    fn parse_message(\u0026self, packet_id: u16) -\u003e ClientMessage {\n        ClientMessage::Publish {\n            packet_id,\n            topic_name: self.topic_name.clone(),\n            qos: self.qos,\n            retain_flag: self.retain_flag,\n            payload: self.payload.clone(),\n            dup_flag: self.dup_flag,\n            properties: self.publish_properties.clone(),\n        }\n    }\n}\nimpl PublishConfig {\n    pub fn new(\n        dup_flag: usize,\n        qos: usize,\n        retain_flag: usize,\n        topic_name: String,\n        payload: PayloadTypes,\n        publish_properties: PublishProperties,\n    ) -\u003e PublishConfig {\n        PublishConfig {\n            dup_flag,\n            qos,\n            retain_flag,\n            topic_name,\n            payload,\n            publish_properties,\n        }\n    }\n\n    pub fn read_json_to_publish_config(payload: PayloadTypes, json_data: \u0026str) -\u003e PublishConfig {\n        let config: PublishConfig = match serde_json::from_str(json_data) {\n            Ok(config) =\u003e config,\n            Err(e) =\u003e panic!(\"Error reading json to PublishConfig: {}\", e),\n        };\n\n        PublishConfig {\n            dup_flag: config.dup_flag,\n            qos: config.qos,\n            retain_flag: config.retain_flag,\n            topic_name: config.topic_name,\n            payload,\n            publish_properties: config.publish_properties,\n        }\n    }\n    /// Abre un archivo de configuracion con propiedades y guarda sus lecturas.\n    pub fn read_config(\n        file_path: \u0026str,\n        payload: PayloadTypes,\n    ) -\u003e Result\u003cPublishConfig, ProtocolError\u003e {\n        let config_file = match File::open(file_path) {\n            Ok(file) =\u003e file,\n            Err(_) =\u003e return Err(ProtocolError::ReadingConfigFileError),\n        };\n\n        let reader: BufReader\u003cFile\u003e = BufReader::new(config_file);\n        let config: PublishConfig = match serde_json::from_reader(reader) {\n            Ok(c) =\u003e c,\n            Err(_) =\u003e return Err(ProtocolError::ReadingConfigFileError),\n        };\n        Ok(PublishConfig {\n            dup_flag: config.dup_flag,\n            qos: config.qos,\n            retain_flag: config.retain_flag,\n            topic_name: config.topic_name,\n            payload,\n            publish_properties: config.publish_properties,\n        })\n    }\n}\n\n#[cfg(test)]\n\nmod tests {\n    use super::*;\n    use crate::{\n        monitoring::incident::Incident,\n        mqtt::{client_message::ClientMessage, publish::publish_properties::TopicProperties},\n        utils::{incident_payload, location::Location},\n    };\n\n    #[test]\n    fn test_parse_message() {\n        let topic_properties = TopicProperties {\n            topic_alias: 10,\n            response_topic: \"String\".to_string(),\n        };\n        let location = Location::new(12.1, 25.0);\n        let incident = Incident::new(location);\n        let incident_payload = incident_payload::IncidentPayload::new(incident);\n        let publish_prop = PublishProperties::new(\n            1,\n            10,\n            topic_properties,\n            [1, 2, 3].to_vec(),\n            \"a\".to_string(),\n            1,\n            \"a\".to_string(),\n        );\n        let publish_config = PublishConfig::new(\n            1,\n            1,\n            1,\n            \"topic\".to_string(),\n            PayloadTypes::IncidentLocation(incident_payload.clone()).clone(),\n            publish_prop.clone(),\n        );\n        let client_message = publish_config.parse_message(1);\n        assert_eq!(\n            client_message,\n            ClientMessage::Publish {\n                packet_id: 1,\n                topic_name: \"topic\".to_string(),\n                qos: 1,\n                retain_flag: 1,\n                payload: PayloadTypes::IncidentLocation(incident_payload),\n                dup_flag: 1,\n                properties: publish_prop\n            }\n        );\n    }\n\n    // #[test]\n    // fn test_read_json_to_publish_config() {\n    //     let topic_properties = TopicProperties {\n    //         topic_alias: 10,\n    //         response_topic: \"String\".to_string(),\n    //     };\n    //     let location = Location::new(12.1, 25.0);\n    //     let incident = Incident::new(location);\n    //     let incident_payload = incident_payload::IncidentPayload::new(incident);\n    //     let publish_prop = PublishProperties::new(\n    //         1,\n    //         10,\n    //         topic_properties,\n    //         [1, 2, 3].to_vec(),\n    //         \"a\".to_string(),\n    //         1,\n    //         \"a\".to_string(),\n    //     );\n    //     let publish_config = PublishConfig::new(\n    //         1,\n    //         1,\n    //         1,\n    //         \"topic\".to_string(),\n    //         PayloadTypes::IncidentLocation(incident_payload.clone()).clone(),\n    //         publish_prop.clone(),\n    //     );\n    //     let json_data = r#\"{\n    //         \"dup_flag\": 1,\n    //         \"qos\": 1,\n    //         \"retain_flag\": 1,\n    //         \"topic_name\": \"topic\",\n    //         \"payload\": {\n    //             \"IncidentLocation\": {\n    //                 \"id\": 1,\n    //                 \"incident\": {\n    //                     \"location\": {\n    //                         \"lat\": 12.1,\n    //                         \"long\": 25.0\n    //                     }\n    //                 }\n    //             }\n    //         },\n    //         \"publish_properties\": {\n    //             \"payload_format_indicator\": 1,\n    //             \"message_expiry_interval\": 10,\n    //             \"topic_alias\": 10,\n    //             \"topic_properties\": {\n    //                 \"topic_alias\": 10,\n    //                 \"response_topic\": \"String\"\n    //             },\n    //             \"correlation_data\": [1, 2, 3],\n    //             \"user_property\": \"a\",\n    //             \"subscription_identifier\": 1,\n    //             \"content_type\": \"a\"\n    //         }\n    //     }\"#;\n    //     let client_message = PublishConfig::read_config(\n    //         json_data,\n    //         PayloadTypes::IncidentLocation(incident_payload.clone()).clone(),\n    //     )\n    //     .unwrap();\n    //     assert_eq!(client_message, publish_config);\n    // }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":27},"fn_name":null}],"covered":19,"coverable":24},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","publish","publish_properties.rs"],"content":"use std::io::{Error, Read, Write};\n\nuse serde::Deserialize;\n\nuse crate::utils::{reader::*, writer::*};\n\nuse crate::mqtt::protocol_error::ProtocolError;\n\n//PROPERTIES IDs\nconst PAYLOAD_FORMAT_INDICATOR_ID: u8 = 0x01;\nconst MESSAGE_EXPIRY_INTERVAL_ID: u8 = 0x02;\nconst TOPIC_ALIAS_ID: u8 = 0x23;\nconst RESPONSE_TOPIC_ID: u8 = 0x08;\nconst CORRELATION_DATA_ID: u8 = 0x09;\nconst USER_PROPERTY_ID: u8 = 0x26;\nconst SUBSCRIPTION_IDENTIFIER_ID: u8 = 0x0B;\nconst CONTENT_TYPE_ID: u8 = 0x03;\n\n#[derive(Debug, PartialEq, Clone, Deserialize)]\npub struct PublishProperties {\n    /// Si vale 0, indica que el payload tiene bytes unspecified -\u003e es equivalente a no enviar un payload format indicator.\n    /// Si vale 1 indica que el payload esta encodeado en UTF-8\n    pub payload_format_indicator: u8,\n\n    ///Indica el lifetime del application message en segundos.\n    ///Si este intervalo expira y el servidor no ha hecho el delivery, se debe eliminar la copia del mensaje para ese subscriptor.\n    pub message_expiry_interval: u32,\n    pub topic_properties: TopicProperties,\n    pub correlation_data: Vec\u003cu8\u003e,\n    pub user_property: String,\n    pub subscription_identifier: u32,\n    pub content_type: String,\n}\n\n#[derive(Debug, PartialEq, Clone, Deserialize)]\n\npub struct TopicProperties {\n    pub topic_alias: u16,\n    pub response_topic: String,\n}\n\nimpl PublishProperties {\n    pub fn new(\n        payload_format_indicator: u8,\n        message_expiry_interval: u32,\n        topic_properties: TopicProperties,\n        correlation_data: Vec\u003cu8\u003e,\n        user_property: String,\n        subscription_identifier: u32,\n        content_type: String,\n    ) -\u003e PublishProperties {\n        PublishProperties {\n            payload_format_indicator,\n            message_expiry_interval,\n            topic_properties,\n            correlation_data,\n            user_property,\n            subscription_identifier,\n            content_type,\n        }\n    }\n\n    pub fn write_properties(\u0026self, stream: \u0026mut dyn Write) -\u003e Result\u003c(), ProtocolError\u003e {\n        //payload format indicator\n        write_u8(stream, \u0026PAYLOAD_FORMAT_INDICATOR_ID)?;\n        write_u8(stream, \u0026self.payload_format_indicator)?;\n\n        //message expiry interval\n        write_u8(stream, \u0026MESSAGE_EXPIRY_INTERVAL_ID)?;\n        write_u32(stream, \u0026self.message_expiry_interval)?;\n\n        //topic alias\n        write_u8(stream, \u0026TOPIC_ALIAS_ID)?;\n        write_u16(stream, \u0026self.topic_properties.topic_alias)?;\n\n        //response topic\n        write_u8(stream, \u0026RESPONSE_TOPIC_ID)?;\n        write_string(stream, \u0026self.topic_properties.response_topic)?;\n\n        //correlation data\n        write_u8(stream, \u0026CORRELATION_DATA_ID)?;\n        write_bin_vec(stream, \u0026self.correlation_data)?;\n\n        //user property\n        write_u8(stream, \u0026USER_PROPERTY_ID)?;\n        write_string(stream, \u0026self.user_property)?;\n\n        //subscription identifier\n        write_u8(stream, \u0026SUBSCRIPTION_IDENTIFIER_ID)?;\n        write_u32(stream, \u0026self.subscription_identifier)?;\n\n        //content type\n        write_u8(stream, \u0026CONTENT_TYPE_ID)?;\n        write_string(stream, \u0026self.content_type)?;\n\n        Ok(())\n    }\n    #[allow(dead_code)]\n    pub fn read_from(stream: \u0026mut dyn Read) -\u003e Result\u003cPublishProperties, Error\u003e {\n        //payload format indicator\n        let _payload_format_indicator_id = read_u8(stream)?;\n        let payload_format_indicator = read_u8(stream)?;\n\n        //message expiry interval\n        let _message_expiry_interval_id = read_u8(stream)?;\n        let message_expiry_interval = read_u32(stream)?;\n\n        //topic alias\n        let _topic_alias_id = read_u8(stream)?;\n        let topic_alias = read_u16(stream)?;\n\n        //response topic\n        let _response_topic_id = read_u8(stream)?;\n        let response_topic = read_string(stream)?;\n\n        let topic_properties = TopicProperties {\n            topic_alias,\n            response_topic,\n        };\n\n        //correlation data\n        let _correlation_data_id = read_u8(stream)?;\n        let correlation_data = read_bin_vec(stream)?;\n\n        //user property\n        let _user_property_id = read_u8(stream)?;\n        let user_property = read_string(stream)?;\n\n        //subscription identifier\n        let _subscription_identifier_id = read_u8(stream)?;\n        let subscription_identifier = read_u32(stream)?;\n\n        //content type\n        let _content_type_id = read_u8(stream)?;\n        let content_type = read_string(stream)?;\n\n        Ok(PublishProperties {\n            payload_format_indicator,\n            message_expiry_interval,\n            topic_properties,\n            correlation_data,\n            user_property,\n            subscription_identifier,\n            content_type,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::io::Cursor;\n\n    use super::*;\n\n    #[test]\n    fn test_01_publish_properties_ok() {\n        let mut buffer = Cursor::new(Vec::new());\n\n        let topic_properties = TopicProperties {\n            topic_alias: 10,\n            response_topic: \"String\".to_string(),\n        };\n\n        let properties = PublishProperties::new(\n            1,\n            10,\n            topic_properties,\n            [1, 2, 3].to_vec(),\n            \"a\".to_string(),\n            1,\n            \"a\".to_string(),\n        );\n\n        match properties.write_properties(\u0026mut buffer) {\n            Ok(_) =\u003e (),\n            Err(err) =\u003e panic!(\"Error writing properties: {:?}\", err),\n        }\n        buffer.set_position(0);\n\n        let publish_properties_read = match PublishProperties::read_from(\u0026mut buffer) {\n            Ok(properties) =\u003e properties,\n            Err(err) =\u003e panic!(\"Error reading properties: {:?}\", err),\n        };\n        assert_eq!(properties, publish_properties_read);\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":11},"fn_name":null}],"covered":44,"coverable":44},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","reason_code.rs"],"content":"use std::io::Error;\n\n///  reason codes in HEX\npub const SUCCESS_HEX: u8 = 0x00;\npub const NO_MATCHING_SUBSCRIBERS_HEX: u8 = 0x10;\npub const UNSPECIFIED_ERROR_HEX: u8 = 0x80;\npub const IMPLEMENTATION_SPECIFIC_ERROR_HEX: u8 = 0x83;\npub const NOT_AUTHORIZED_HEX: u8 = 0x87;\npub const TOPIC_NAME_INVALID_HEX: u8 = 0x90;\npub const PACKET_ID_IN_USE_HEX: u8 = 0x91;\npub const QUOTA_EXCEEDED_HEX: u8 = 0x97;\npub const PAYLOAD_FORMAT_INVALID_HEX: u8 = 0x99;\npub const SUB_ID_DUP_HEX: u8 = 0x85;\npub const NO_MATCHING_USER_HEX: u8 = 0x11;\n\n#[derive(Debug, PartialEq)]\npub enum ReasonCode {\n    Success { reason_code: u8 },\n    NoMatchingSubscribers { reason_code: u8 },\n    UnspecifiedError { reason_code: u8 },\n    ImplementationSpecificError { reason_code: u8 },\n    NotAuthorized { reason_code: u8 },\n    TopicNameInvalid { reason_code: u8 },\n    PacketIdentifierInUse { reason_code: u8 },\n    QuotaExceeded { reason_code: u8 },\n    PayloadFormatInvalid { reason_code: u8 },\n    SubIdDup { reason_code: u8 },\n}\n\nimpl ReasonCode {\n    pub fn new(reason_code: u8) -\u003e Result\u003cReasonCode, Error\u003e {\n        match reason_code {\n            SUCCESS_HEX =\u003e Ok(ReasonCode::Success { reason_code }),\n            NO_MATCHING_SUBSCRIBERS_HEX =\u003e Ok(ReasonCode::NoMatchingSubscribers { reason_code }),\n            UNSPECIFIED_ERROR_HEX =\u003e Ok(ReasonCode::UnspecifiedError { reason_code }),\n            IMPLEMENTATION_SPECIFIC_ERROR_HEX =\u003e {\n                Ok(ReasonCode::ImplementationSpecificError { reason_code })\n            }\n            NOT_AUTHORIZED_HEX =\u003e Ok(ReasonCode::NotAuthorized { reason_code }),\n            TOPIC_NAME_INVALID_HEX =\u003e Ok(ReasonCode::TopicNameInvalid { reason_code }),\n            PACKET_ID_IN_USE_HEX =\u003e Ok(ReasonCode::PacketIdentifierInUse { reason_code }),\n            QUOTA_EXCEEDED_HEX =\u003e Ok(ReasonCode::QuotaExceeded { reason_code }),\n            PAYLOAD_FORMAT_INVALID_HEX =\u003e Ok(ReasonCode::PayloadFormatInvalid { reason_code }),\n            SUB_ID_DUP_HEX =\u003e Ok(ReasonCode::SubIdDup { reason_code }),\n            _ =\u003e Err(Error::new(\n                std::io::ErrorKind::Other,\n                \"Reason code inválido\",\n            )),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_new_reason_code() {\n        let reason_code = ReasonCode::new(SUCCESS_HEX);\n        assert_eq!(\n            reason_code.unwrap(),\n            ReasonCode::Success { reason_code: 0x00 }\n        );\n    }\n\n    #[test]\n    fn test_new_reason_code_invalid() {\n        let reason_code = ReasonCode::new(0x01);\n        assert_eq!(\n            reason_code.unwrap_err().to_string(),\n            \"Reason code inválido\".to_string()\n        );\n    }\n\n    #[test]\n    fn test_new_reason_code_no_matching_subscribers() {\n        let reason_code = ReasonCode::new(NO_MATCHING_SUBSCRIBERS_HEX);\n        assert_eq!(\n            reason_code.unwrap(),\n            ReasonCode::NoMatchingSubscribers { reason_code: 0x10 }\n        );\n    }\n\n    #[test]\n    fn test_new_reason_code_unspecified_error() {\n        let reason_code = ReasonCode::new(UNSPECIFIED_ERROR_HEX);\n        assert_eq!(\n            reason_code.unwrap(),\n            ReasonCode::UnspecifiedError { reason_code: 0x80 }\n        );\n    }\n\n    #[test]\n    fn test_new_reason_code_implementation_specific_error() {\n        let reason_code = ReasonCode::new(IMPLEMENTATION_SPECIFIC_ERROR_HEX);\n        assert_eq!(\n            reason_code.unwrap(),\n            ReasonCode::ImplementationSpecificError { reason_code: 0x83 }\n        );\n    }\n\n    #[test]\n    fn test_new_reason_code_not_authorized() {\n        let reason_code = ReasonCode::new(NOT_AUTHORIZED_HEX);\n        assert_eq!(\n            reason_code.unwrap(),\n            ReasonCode::NotAuthorized { reason_code: 0x87 }\n        );\n    }\n\n    #[test]\n    fn test_new_reason_code_topic_name_invalid() {\n        let reason_code = ReasonCode::new(TOPIC_NAME_INVALID_HEX);\n        assert_eq!(\n            reason_code.unwrap(),\n            ReasonCode::TopicNameInvalid { reason_code: 0x90 }\n        );\n    }\n\n    #[test]\n    fn test_new_reason_code_packet_identifier_in_use() {\n        let reason_code = ReasonCode::new(PACKET_ID_IN_USE_HEX);\n        assert_eq!(\n            reason_code.unwrap(),\n            ReasonCode::PacketIdentifierInUse { reason_code: 0x91 }\n        );\n    }\n\n    #[test]\n    fn test_new_reason_code_quota_exceeded() {\n        let reason_code = ReasonCode::new(QUOTA_EXCEEDED_HEX);\n        assert_eq!(\n            reason_code.unwrap(),\n            ReasonCode::QuotaExceeded { reason_code: 0x97 }\n        );\n    }\n\n    #[test]\n    fn test_new_reason_code_payload_format_invalid() {\n        let reason_code = ReasonCode::new(PAYLOAD_FORMAT_INVALID_HEX);\n        assert_eq!(\n            reason_code.unwrap(),\n            ReasonCode::PayloadFormatInvalid { reason_code: 0x99 }\n        );\n    }\n\n    #[test]\n\n    fn test_new_reason_code_sub_id_dup() {\n        let reason_code = ReasonCode::new(SUB_ID_DUP_HEX);\n        assert_eq!(\n            reason_code.unwrap(),\n            ReasonCode::SubIdDup { reason_code: 0x85 }\n        );\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":15,"coverable":15},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","run_broker.rs"],"content":"use std::env::args;\n\nuse rustic_city_eye::mqtt::{broker::Broker, protocol_error::ProtocolError};\n\nfn main() -\u003e Result\u003c(), ProtocolError\u003e {\n    let argv = args().collect::\u003cVec\u003cString\u003e\u003e();\n    let mut broker = Broker::new(argv)?;\n    let _ = broker.server_run();\n    Ok(())\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","subscribe_config.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse crate::mqtt::subscribe_properties::SubscribeProperties;\n\nuse super::{\n    client_message::ClientMessage, messages_config::MessagesConfig, subscription::Subscription,\n};\n\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct SubscribeConfig {\n    pub(crate) topic_name: String,\n    pub(crate) qos: u8,\n    pub(crate) properties: SubscribeProperties,\n    pub(crate) client_id: String,\n}\n\nimpl MessagesConfig for SubscribeConfig {\n    fn parse_message(\u0026self, packet_id: u16) -\u003e ClientMessage {\n        let subscription =\n            Subscription::new(self.topic_name.clone(), self.client_id.clone(), self.qos);\n        //creo un vector cno la subscription\n        let subscriptions = vec![subscription];\n\n        ClientMessage::Subscribe {\n            packet_id,\n            properties: self.properties.clone(),\n            payload: subscriptions,\n        }\n    }\n}\n\nimpl SubscribeConfig {\n    pub fn new(\n        topic_name: String,\n        qos: u8,\n        properties: SubscribeProperties,\n        client_id: String,\n    ) -\u003e SubscribeConfig {\n        SubscribeConfig {\n            topic_name,\n            qos,\n            properties,\n            client_id,\n        }\n    }\n\n    pub fn json_to_publish_config(path: \u0026str) -\u003e SubscribeConfig {\n        let config: SubscribeConfig = match serde_json::from_str(path) {\n            Ok(config) =\u003e config,\n            Err(e) =\u003e panic!(\"Error reading json to PublishConfig: {}\", e),\n        };\n\n        SubscribeConfig {\n            topic_name: config.topic_name,\n            qos: config.qos,\n            properties: config.properties,\n            client_id: config.client_id,\n        }\n    }\n    pub fn write_config_to_json_file(\u0026self, path: \u0026str) {\n        let json = match serde_json::to_string(\u0026self) {\n            Ok(json) =\u003e json,\n            Err(e) =\u003e panic!(\"Error converting PublishConfig to json: {}\", e),\n        };\n        match std::fs::write(path, json) {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e panic!(\"Error writing PublishConfig to json file: {}\", e),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_new_subscribe_config() {\n        let topic_name = \"topic\".to_string();\n        let properties =\n            SubscribeProperties::new(1, vec![(\"key\".to_string(), \"value\".to_string())]);\n        let qos = 1;\n        let subscribe_config = SubscribeConfig::new(\n            topic_name.clone(),\n            qos,\n            properties.clone(),\n            \"client\".to_string(),\n        );\n        assert_eq!(subscribe_config.topic_name, topic_name);\n        assert_eq!(subscribe_config.qos, qos);\n        assert_eq!(subscribe_config.properties, properties);\n    }\n\n    #[test]\n    fn test_parse_message() {\n        let topic_name = \"topic\".to_string();\n        let properties =\n            SubscribeProperties::new(1, vec![(\"key\".to_string(), \"value\".to_string())]);\n\n        let qos = 1;\n        let subscribe_config = SubscribeConfig::new(\n            topic_name.clone(),\n            qos,\n            properties.clone(),\n            \"client\".to_string(),\n        );\n        let packet_id = 1;\n        let message = subscribe_config.parse_message(packet_id);\n        match message {\n            ClientMessage::Subscribe {\n                packet_id: message_packet_id,\n                properties: message_properties,\n                payload,\n            } =\u003e {\n                assert_eq!(message_packet_id, packet_id);\n                assert_eq!(message_properties, properties);\n                assert_eq!(payload.len(), 1);\n                assert_eq!(payload[0].topic, topic_name);\n                assert_eq!(payload[0].qos, qos);\n            }\n            _ =\u003e panic!(\"Wrong message type\"),\n        }\n    }\n\n    // #[test]\n    // fn test_write_config_to_json_file() {\n    //     let topic_name = \"topic\".to_string();\n    //     let properties =\n    //         SubscribeProperties::new(1, vec![(\"key\".to_string(), \"value\".to_string())]);\n    //     let qos = 1;\n    //     let subscribe_config = SubscribeConfig::new(\n    //         topic_name.clone(),\n    //         qos,\n    //         properties.clone(),\n    //         \"client\".to_string(),\n    //     );\n    //     let path = \"test.json\";\n    //     subscribe_config.write_config_to_json_file(path);\n    //     let read_config = SubscribeConfig::json_to_publish_config(path);\n    //     assert_eq!(read_config, subscribe_config);\n    // }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":6,"coverable":14},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","subscribe_properties.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse crate::utils::{reader::*, writer::*};\nuse std::io::{Error, Read, Write};\n\nuse super::protocol_error::ProtocolError;\n\n#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]\n\npub struct SubscribeProperties {\n    pub sub_id: u8,\n    user_properties: Vec\u003c(String, String)\u003e,\n}\n\nimpl SubscribeProperties {\n    pub fn new(sub_id: u8, user_properties: Vec\u003c(String, String)\u003e) -\u003e SubscribeProperties {\n        SubscribeProperties {\n            sub_id,\n            user_properties,\n        }\n    }\n\n    pub fn write_properties(\u0026self, stream: \u0026mut dyn Write) -\u003e Result\u003c(), ProtocolError\u003e {\n        write_u8(stream, \u0026self.sub_id)?;\n        write_string_pairs(stream, \u0026self.user_properties)?;\n        Ok(())\n    }\n\n    pub fn read_properties(stream: \u0026mut dyn Read) -\u003e Result\u003cSubscribeProperties, Error\u003e {\n        let sub_id = read_u8(stream)?;\n        let user_properties = read_string_pairs(stream)?;\n        Ok(SubscribeProperties::new(sub_id, user_properties))\n    }\n}\n\n#[cfg(test)]\n\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n\n    #[test]\n    fn test_new_subscribe_properties() {\n        let user_properties = vec![(\"key\".to_string(), \"value\".to_string())];\n        let subscribe_properties = SubscribeProperties::new(1, user_properties.clone());\n        assert_eq!(subscribe_properties.sub_id, 1);\n        assert_eq!(subscribe_properties.user_properties, user_properties);\n    }\n\n    #[test]\n    fn test_read_properties() {\n        let user_properties = vec![(\"key\".to_string(), \"value\".to_string())];\n        let subscribe_properties = SubscribeProperties::new(1, user_properties.clone());\n        let mut cursor = Cursor::new(Vec::new());\n        subscribe_properties.write_properties(\u0026mut cursor).unwrap();\n        cursor.set_position(0);\n        let read_subscribe_properties = SubscribeProperties::read_properties(\u0026mut cursor).unwrap();\n        assert_eq!(read_subscribe_properties, subscribe_properties);\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":15},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","subscription.rs"],"content":"#[derive(Debug, Eq, Hash, PartialEq, Clone)]\npub struct Subscription {\n    pub topic: String,\n    pub client_id: String,\n    pub qos: u8,\n}\n\nimpl Subscription {\n    pub fn new(topic: String, client_id: String, qos: u8) -\u003e Subscription {\n        Subscription {\n            topic,\n            client_id,\n            qos,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_new_subscription() {\n        let topic = \"topic\".to_string();\n        let qos = 0x01;\n        let client_id = \"client\".to_string();\n        let subscription = Subscription::new(topic.clone(), client_id.clone(), qos);\n        assert_eq!(subscription.topic, topic);\n        assert_eq!(subscription.qos, qos);\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":22},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","mqtt","topic.rs"],"content":"use std::fmt::Debug;\nuse std::sync::{Arc, RwLock};\n\nuse super::subscription::Subscription;\n\nuse super::reason_code;\n\n/// Estructura que representa un topic.\n#[derive(Debug, Clone)]\npub struct Topic {\n    /// Hashmap de subscriptores.\n    users: Arc\u003cRwLock\u003cVec\u003cSubscription\u003e\u003e\u003e,\n    // vector de hijos\n    // hijos: Vec\u003cTopic\u003e,\n}\n\nimpl Default for Topic {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Topic {\n    /// Crea un nuevo topic sin subscriptores\n    pub fn new() -\u003e Self {\n        Self {\n            users: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    /// Agrega un usuario a un topic\n    /// Si el usuario no existe en el tópic, lo agrega\n    /// Si el usuario ya existe en el tópic, no lo agrega pero la operacion es exitosa de todas maneras ya que el objetivo era concretar la subscription\n    /// Retorna el reason code de la operación\n    pub fn add_user_to_topic(\u0026mut self, subscription: Subscription) -\u003e u8 {\n        println!(\"Adding user to topic: {:?}\", subscription);\n        //verificar si el user_id ya existe en topic users\n        let mut existe = false;\n        match self.users.read() {\n            Ok(guard) =\u003e {\n                if guard.contains(\u0026subscription) {\n                    existe = true;\n                }\n            }\n            Err(_) =\u003e return reason_code::UNSPECIFIED_ERROR_HEX,\n        }\n\n        let mut lock = match self.users.write() {\n            Ok(guard) =\u003e guard,\n            Err(_) =\u003e return reason_code::UNSPECIFIED_ERROR_HEX,\n        };\n\n        if !existe {\n            lock.push(subscription);\n        }\n\n        reason_code::SUCCESS_HEX\n    }\n\n    /// Elimina un usuario de un topic\n    /// Si el usuario no existe en el topic, no hace nada\n    /// Retorna el reason code de la operación\n    pub fn remove_user_from_topic(\u0026mut self, subscription: Subscription) -\u003e u8 {\n        let mut lock = match self.users.write() {\n            Ok(guard) =\u003e guard,\n            Err(_) =\u003e return reason_code::UNSPECIFIED_ERROR_HEX,\n        };\n\n        if lock.contains(\u0026subscription) {\n            lock.retain(|x| x != \u0026subscription);\n        }\n\n        reason_code::SUCCESS_HEX\n    }\n\n    pub fn get_topic_users(\u0026self) -\u003e Vec\u003cSubscription\u003e {\n        let lock = match self.users.read() {\n            Ok(guard) =\u003e guard,\n            Err(_) =\u003e return Vec::new(),\n        };\n\n        let mut users = Vec::new();\n        for user in lock.iter() {\n            users.push(user.clone());\n        }\n\n        users\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn test_new_topic() {\n        let topic = Topic::new();\n        assert_eq!(topic.users.read().unwrap().len(), 0);\n    }\n\n    #[test]\n    fn test_add_subscriber() {\n        let mut topic = Topic::new();\n        let user_id = \"user\".to_string();\n        let qos = 1;\n        let subscription = Subscription::new(\"topic\".to_string(), user_id, qos);\n        let result = topic.add_user_to_topic(subscription);\n        assert_eq!(result, 0x00);\n    }\n\n    #[test]\n    fn test_add_subscriber_duplicate() {\n        let mut topic = Topic::new();\n        let user_id = \"user\".to_string();\n        let subscription = Subscription::new(\"topic\".to_string(), user_id, 1);\n        let result = topic.add_user_to_topic(subscription.clone());\n        assert_eq!(result, 0x00);\n        let result = topic.add_user_to_topic(subscription);\n        assert_eq!(result, 0x00);\n    }\n\n    #[test]\n    fn test_remove_subscriber() {\n        let mut topic = Topic::new();\n        let user_id = \"user\".to_string();\n        let subscription = Subscription::new(\"topic\".to_string(), user_id, 1);\n        let result = topic.add_user_to_topic(subscription.clone());\n        assert_eq!(result, 0x00);\n        let result = topic.remove_user_from_topic(subscription);\n        assert_eq!(result, 0x00);\n    }\n\n    #[test]\n    fn test_remove_subscriber_no_matching() {\n        let mut topic = Topic::new();\n        let user_id = \"user\".to_string();\n        let subscription = Subscription::new(\"topic\".to_string(), user_id, 1);\n        let result = topic.add_user_to_topic(subscription.clone());\n        assert_eq!(result, 0x00);\n        let result = topic.remove_user_from_topic(subscription);\n        assert_eq!(result, 0x00);\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":353},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":353},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":18,"coverable":29},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","surveilling","camera.rs"],"content":"use std::io::{Error, Read, Write};\n\nuse serde::Deserialize;\n\nuse crate::utils::{\n    location::Location,\n    reader::{read_bool, read_string, read_u32},\n};\n\nuse super::camera_error::CameraError;\n\nuse crate::utils::writer::{write_bool, write_string, write_u32};\n\n#[derive(Debug, Clone, PartialEq, Deserialize)]\n#[allow(dead_code)]\npub struct Camera {\n    location: Location,\n    id: u32,\n    sleep_mode: bool,\n}\n\nimpl Camera {\n    pub fn new(location: Location, id: u32) -\u003e Camera {\n        Self {\n            location,\n            id,\n            sleep_mode: true,\n        }\n    }\n\n    pub fn get_location(\u0026self) -\u003e Location {\n        self.location\n    }\n    pub fn get_id(\u0026self) -\u003e u32 {\n        self.id\n    }\n    pub fn get_sleep_mode(\u0026self) -\u003e bool {\n        self.sleep_mode\n    }\n    pub fn set_sleep_mode(\u0026mut self, sleep_mode: bool) {\n        self.sleep_mode = sleep_mode;\n    }\n    pub fn write_to(\u0026mut self, stream: \u0026mut dyn Write) -\u003e Result\u003c(), CameraError\u003e {\n        let _ = write_u32(stream, \u0026self.id).map_err(|_| CameraError::WriteError);\n        let _ = write_string(stream, \u0026self.location.get_latitude().to_string())\n            .map_err(|_| CameraError::WriteError);\n        let _ = write_string(stream, \u0026self.location.get_longitude().to_string())\n            .map_err(|_| CameraError::WriteError);\n        let _ = write_bool(stream, \u0026self.sleep_mode).map_err(|_| CameraError::WriteError);\n\n        Ok(())\n    }\n\n    pub fn read_from(stream: \u0026mut dyn Read) -\u003e Result\u003cCamera, Error\u003e {\n        let id = read_u32(stream)?;\n        let latitude = read_string(stream)?;\n        let longitude = read_string(stream)?;\n        let sleep_mode = read_bool(stream)?;\n\n        let lat = match latitude.parse::\u003cf64\u003e() {\n            Ok(lat) =\u003e lat,\n            Err(_) =\u003e {\n                return Err(Error::new(\n                    std::io::ErrorKind::InvalidData,\n                    \"Invalid latitude\",\n                ))\n            }\n        };\n        let long = match longitude.parse::\u003cf64\u003e() {\n            Ok(long) =\u003e long,\n            Err(_) =\u003e {\n                return Err(Error::new(\n                    std::io::ErrorKind::InvalidData,\n                    \"Invalid longitude\",\n                ))\n            }\n        };\n        Ok(Camera {\n            location: Location::new(lat, long),\n            id,\n            sleep_mode,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_new_camera() {\n        let location = Location::new(1.0, 2.0);\n        let camera = Camera::new(location.clone(), 1);\n        assert_eq!(camera.get_location(), location);\n        assert_eq!(camera.get_id(), 1);\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":106},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":106},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":9,"coverable":35},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","surveilling","camera_error.rs"],"content":"use std::fmt;\n\n///Here are detailed all the errors that the protocol is capable of throwing.\n/// Unspecified se usa de placeholder para los results de los tests\n#[derive(PartialEq, Debug)]\npub enum CameraError {\n    SendError,\n    WriteError,\n    ArcMutexError(String),\n}\n\nimpl fmt::Display for CameraError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            CameraError::SendError =\u003e {\n                write!(f, \"Error sending message via channel\")\n            }\n            CameraError::WriteError =\u003e {\n                write!(f, \"Error writing to stream\")\n            }\n            CameraError::ArcMutexError(e) =\u003e {\n                write!(f, \"Error with Arc Mutex: {}\", e)\n            }\n        }\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","surveilling","camera_system.rs"],"content":"use std::{\n    collections::HashMap,\n    sync::{\n        mpsc::{self, Receiver, Sender},\n        Arc, Mutex,\n    },\n    thread,\n};\n\nuse rand::Rng;\n\nuse crate::{\n    mqtt::{\n        client::{Client, ClientTrait},\n        client_message::{self, ClientMessage},\n        messages_config::MessagesConfig,\n        protocol_error::ProtocolError,\n        publish::publish_config::PublishConfig,\n        subscribe_config::SubscribeConfig,\n        subscribe_properties::SubscribeProperties,\n    },\n    surveilling::camera::Camera,\n    utils::{location::Location, payload_types::PayloadTypes},\n};\n\nconst AREA_DE_ALCANCE: f64 = 0.0025;\nconst NIVEL_DE_PROXIMIDAD_MAXIMO: f64 = AREA_DE_ALCANCE;\n\nuse super::camera_error::CameraError;\n#[derive(Debug)]\n\n/// Entidad encargada de gestionar todas las camaras. Tiene como parametro a su instancia de cliente, utiliza un hash `\u003cID, Camera\u003e` como estructura principal y diferentes channels para comunicarse con su cliente.\n/// Los mensajes recibidos le llegan mediante el channel `reciev_from_client` y envia una config con los mensajes que quiere enviar mediante `send_to_client_channel``\npub struct CameraSystem\u003cT: ClientTrait + Clone\u003e {\n    pub send_to_client_channel: Arc\u003cMutex\u003cSender\u003cBox\u003cdyn MessagesConfig + Send\u003e\u003e\u003e\u003e,\n    camera_system_client: T,\n    cameras: Arc\u003cMutex\u003cHashMap\u003cu32, Camera\u003e\u003e\u003e,\n    reciev_from_client: Arc\u003cMutex\u003cReceiver\u003cclient_message::ClientMessage\u003e\u003e\u003e,\n    snapshot: Vec\u003cCamera\u003e,\n}\n\nimpl\u003cT: ClientTrait + Clone\u003e Clone for CameraSystem\u003cT\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        CameraSystem {\n            send_to_client_channel: Arc::clone(\u0026self.send_to_client_channel),\n            camera_system_client: self.camera_system_client.clone(),\n            cameras: self.cameras.clone(),\n            reciev_from_client: Arc::clone(\u0026self.reciev_from_client),\n            snapshot: self.snapshot.clone(),\n        }\n    }\n}\n\nimpl\u003cT: ClientTrait + Clone + Send + 'static\u003e CameraSystem\u003cT\u003e {\n    /// Crea un nuevo camera system con un cliente de mqtt\n    ///\n    /// Envia un connect segun la configuracion del archivo connect_config.json\n    ///\n    /// Se subscribe a los mensajes de tipo \"incidente\" e \"incidente_resuelto\"\n    ///\n    pub fn new\u003cF\u003e(address: String, client_factory: F) -\u003e Result\u003cCameraSystem\u003cT\u003e, ProtocolError\u003e\n    where\n        F: FnOnce(\n            mpsc::Receiver\u003cBox\u003cdyn MessagesConfig + Send\u003e\u003e,\n            String,\n            client_message::Connect,\n            Sender\u003cclient_message::ClientMessage\u003e,\n        ) -\u003e Result\u003cT, ProtocolError\u003e,\n    {\n        let connect_config =\n            client_message::Connect::read_connect_config(\"./src/surveilling/connect_config.json\")?;\n\n        let (tx, rx) = mpsc::channel();\n        let (tx2, rx2) = mpsc::channel();\n        let camera_system_client = client_factory(rx, address, connect_config, tx2)?;\n        let client_id = camera_system_client.get_client_id();\n        let subscribe_config = SubscribeConfig::new(\n            \"incidente\".to_string(),\n            1,\n            SubscribeProperties::new(1, vec![]),\n            client_id.clone(),\n        );\n\n        let _ = tx.send(Box::new(subscribe_config));\n\n        let subscribe_config = SubscribeConfig::new(\n            \"incidente_resuelto\".to_string(),\n            1,\n            SubscribeProperties::new(1, vec![]),\n            client_id,\n        );\n\n        let _ = tx.send(Box::new(subscribe_config));\n\n        Ok(CameraSystem {\n            send_to_client_channel: Arc::new(Mutex::new(tx)),\n            camera_system_client,\n            cameras: Arc::new(Mutex::new(HashMap::new())),\n            reciev_from_client: Arc::new(Mutex::new(rx2)),\n            snapshot: Vec::new(),\n        })\n    }\n\n    pub fn add_camera(\u0026mut self, location: Location) -\u003e Result\u003cu32, CameraError\u003e {\n        let mut rng = rand::thread_rng();\n\n        let mut id = rng.gen();\n\n        let mut cameras = match self.cameras.lock() {\n            Ok(guard) =\u003e guard,\n            Err(_) =\u003e {\n                return Err(CameraError::ArcMutexError(\n                    \"Error locking cameras mutex\".to_string(),\n                ));\n            }\n        };\n        while cameras.contains_key(\u0026id) {\n            id = rng.gen();\n        }\n\n        let camera = Camera::new(location, id);\n        println!(\"CameraSys: creo la camara con id: {:?}\", id);\n        cameras.insert(id, camera);\n        print!(\"cameras: {:?}\", self.cameras);\n        println!(\"CameraSys: añadiendo camara: {:?}\", self.cameras);\n\n        Ok(id)\n    }\n\n    pub fn get_cameras(\u0026self) -\u003e Arc\u003cMutex\u003cHashMap\u003cu32, Camera\u003e\u003e\u003e {\n        self.cameras.clone()\n    }\n\n    pub fn get_camera_by_id(\u0026mut self, id: u32) -\u003e Option\u003cCamera\u003e {\n        let cameras = match self.cameras.lock() {\n            Ok(guard) =\u003e guard,\n            Err(_) =\u003e {\n                return None;\n            }\n        };\n        let camera = cameras.get(\u0026id).cloned();\n        camera\n    }\n\n    pub fn get_camera(\u0026mut self) -\u003e Option\u003cCamera\u003e {\n        let cameras = match self.cameras.lock() {\n            Ok(guard) =\u003e guard,\n            Err(_) =\u003e return None,\n        };\n        let keys: Vec\u003c\u0026u32\u003e = cameras.keys().collect();\n        if keys.is_empty() {\n            None\n        } else {\n            let idx = rand::thread_rng().gen_range(0..keys.len());\n            cameras.get(keys[idx]).cloned()\n        }\n    }\n\n    /// recibe los diferentes mensajes reenviados por el cliente.\n    ///\n    /// Si el mensaje es un publish con topic accidente, activa las camaras cercanas a la location del incidente.\n    ///\n    /// Si el mensaje es un publish con topic accidenteresuelto, desactiva las camaras cercanas a la location del incidente.\n    ///\n    /// Recibe un reciever opcional para poder testear la funcion, si este es None, utiliza el propio del broker\n    pub fn run_client(\n        parameter_reciever: Option\u003cArc\u003cMutex\u003cReceiver\u003cClientMessage\u003e\u003e\u003e\u003e,\n        system: Arc\u003cMutex\u003cCameraSystem\u003cClient\u003e\u003e\u003e,\n    ) -\u003e Result\u003c(), ProtocolError\u003e {\n        let system_clone_one = Arc::clone(\u0026system);\n        let system_clone_two = Arc::clone(\u0026system);\n\n        thread::spawn(move || {\n            let mut lock = match system_clone_one.lock() {\n                Ok(guard) =\u003e guard,\n                Err(_) =\u003e {\n                    return;\n                }\n            };\n            match lock.camera_system_client.client_run() {\n                Ok(_) =\u003e {}\n                Err(e) =\u003e {\n                    println!(\"CameraSys: Error running client: {:?}\", e);\n                }\n            }\n        });\n\n        thread::spawn(move || {\n            let mut incident_location: Option\u003cLocation\u003e = None;\n            let mut solved_incident_location: Option\u003cLocation\u003e = None;\n            let reciever: Arc\u003cMutex\u003cReceiver\u003cClientMessage\u003e\u003e\u003e;\n            match parameter_reciever {\n                Some(paramter_reciever) =\u003e {\n                    reciever = paramter_reciever;\n                }\n                None =\u003e {\n                    reciever = match system_clone_two.lock() {\n                        Ok(guard) =\u003e guard.reciev_from_client.clone(),\n                        Err(_) =\u003e {\n                            return;\n                        }\n                    }\n                }\n            };\n            loop {\n                let self_clone_two = Arc::clone(\u0026system_clone_two);\n\n                let mut lock = match self_clone_two.lock() {\n                    Ok(guard) =\u003e guard.clone(),\n                    Err(_) =\u003e {\n                        return;\n                    }\n                };\n\n                match incident_location {\n                    Some(location) =\u003e {\n                        match lock\n                            .activate_cameras(location)\n                            .map_err(|e| ProtocolError::CameraError(e.to_string()))\n                        {\n                            Ok(_) =\u003e {}\n                            Err(e) =\u003e {\n                                println!(\"CameraSys: Error activating cameras: {:?}\", e);\n                            }\n                        }\n                        incident_location = None;\n                    }\n                    None =\u003e {}\n                }\n                match solved_incident_location {\n                    Some(location) =\u003e {\n                        match lock\n                            .deactivate_cameras(location)\n                            .map_err(|e| ProtocolError::CameraError(e.to_string()))\n                        {\n                            Ok(_) =\u003e {}\n                            Err(e) =\u003e {\n                                println!(\"CameraSys: Error activating cameras: {:?}\", e);\n                            }\n                        }\n                        solved_incident_location = None;\n                    }\n                    None =\u003e {}\n                }\n\n                let reciever = match reciever.lock() {\n                    Ok(guard) =\u003e guard,\n                    Err(_) =\u003e {\n                        return;\n                    }\n                };\n\n                match reciever.recv() {\n                    Ok(client_message::ClientMessage::Publish {\n                        topic_name,\n                        payload: PayloadTypes::IncidentLocation(payload),\n                        ..\n                    }) =\u003e {\n                        println!(\n                            \"SOT EL CAMERA Y RECIBVI UN PUBLISH DE TOPIC: {:?}\",\n                            topic_name\n                        );\n                        if topic_name == \"incidente\" {\n                            incident_location = Some(payload.get_incident().get_location());\n                            drop(reciever); // Release the lock here\n\n                            continue;\n                        } else if topic_name == \"incidente_resuelto\" {\n                            println!(\"ASI ES COÑO LO HE RECIBIDO\");\n                            solved_incident_location = Some(payload.get_incident().get_location());\n                            drop(reciever); // Release the lock here\n\n                            continue;\n                        }\n                    }\n                    Ok(_) =\u003e {\n                        continue;\n                    }\n                    Err(_) =\u003e {\n                        continue;\n                    }\n                }\n            }\n        });\n        Ok(())\n    }\n\n    /// Recibe una location y activas todas las camaras que esten a menos de AREA_DE_ALCANCE de esta.\n    ///\n    /// Al activarlas se las pasa de modo ahorro de energia a modo activo\n    ///\n    /// Adicionalmente, cada camara activada despues avisa a las camaras colindantes para que,\n    /// si estan a la distancia requerida, tambien se activen.\n    pub fn activate_cameras(\u0026mut self, location: Location) -\u003e Result\u003c(), CameraError\u003e {\n        println!(\n            \"CameraSys: Camaras antes de ser activadas: {:?}\",\n            self.cameras\n        );\n        let locations_to_activate: Vec\u003cLocation\u003e = {\n            let mut cameras = match self.cameras.lock() {\n                Ok(guard) =\u003e guard,\n                Err(_) =\u003e {\n                    return Err(CameraError::ArcMutexError(\n                        \"Error locking cameras mutex\".to_string(),\n                    ));\n                }\n            };\n\n            cameras\n                .values_mut()\n                .filter_map(|camera| {\n                    let distancia = camera.get_location().distance(location);\n                    if distancia \u003c= AREA_DE_ALCANCE {\n                        camera.set_sleep_mode(false);\n                        Some(camera.get_location())\n                    } else {\n                        None\n                    }\n                })\n                .collect()\n        };\n        println!(\n            \"CameraSys: Camaras despues de ser activadas: {:?}\",\n            self.cameras\n        );\n        for loc in locations_to_activate {\n            self.activate_cameras_by_camera_location(loc)?;\n        }\n\n        self.publish_cameras_update()?;\n\n        Ok(())\n    }\n\n    /// Recibe una location y activas todas las camaras que esten a menos de NIVEL_DE_PROXIMIDAD_MAXIMO de esta.\n    ///\n    /// Al activaralas se las pasa de modo ahorro de energia a modo activo\n    ///\n    /// Adicionalmente, cada camara activada despues avisa a las camaras colindantes para que,\n    /// si estan a la distancia requerida, tambien se activen.\n    fn activate_cameras_by_camera_location(\n        \u0026mut self,\n        location: Location,\n    ) -\u003e Result\u003c(), CameraError\u003e {\n        let mut locations_to_activate = Vec::new();\n        {\n            let mut cameras = match self.cameras.lock() {\n                Ok(guard) =\u003e guard,\n                Err(_) =\u003e {\n                    return Err(CameraError::ArcMutexError(\n                        \"Error locking cameras mutex\".to_string(),\n                    ));\n                }\n            };\n            for camera in cameras.values_mut() {\n                let distancia = camera.get_location().distance(location);\n                if distancia \u003c= NIVEL_DE_PROXIMIDAD_MAXIMO \u0026\u0026 camera.get_sleep_mode() {\n                    camera.set_sleep_mode(false);\n                    locations_to_activate.push(camera.get_location());\n                }\n            }\n        }\n\n        for loc in locations_to_activate {\n            self.activate_cameras_by_camera_location(loc)?;\n        }\n\n        Ok(())\n    }\n\n    /// Recibe una location y desactiva todas las camaras que esten a menos de AREA_DE_ALCANCE de esta.\n    ///\n    /// Al desactivarlas se las pasa de modo activo a modo ahorro de energia\n    ///\n    /// Adicionalmente, cada camara desactivada despues avisa a las camaras colindantes para que,\n    /// si estan a la distancia requerida, tambien se desactiven.\n    pub fn deactivate_cameras(\u0026mut self, location: Location) -\u003e Result\u003c(), CameraError\u003e {\n        let locations_to_activate: Vec\u003cLocation\u003e = {\n            let mut cameras = match self.cameras.lock() {\n                Ok(guard) =\u003e guard,\n                Err(_) =\u003e {\n                    return Err(CameraError::ArcMutexError(\n                        \"Error locking cameras mutex\".to_string(),\n                    ));\n                }\n            };\n            cameras\n                .values_mut()\n                .filter_map(|camera| {\n                    let distancia = camera.get_location().distance(location);\n                    if distancia \u003c= AREA_DE_ALCANCE {\n                        camera.set_sleep_mode(true);\n                        Some(camera.get_location())\n                    } else {\n                        None\n                    }\n                })\n                .collect()\n        };\n        for loc in locations_to_activate {\n            self.deactivate_cameras_by_camera_location(loc)?;\n        }\n\n        self.publish_cameras_update()?;\n\n        Ok(())\n    }\n\n    /// Recibe una location y desactiva todas las camaras que esten a menos de NIVEL_DE_PROXIMIDAD_MAXIMO de esta.\n    ///\n    /// Al desactivarlas se las pasa de modo activo a modo ahorro de energia\n    ///\n    /// Adicionalmente, cada camara desactivada despues avisa a las camaras colindantes para que,\n    /// si estan a la distancia requerida, tambien se desactiven.\n    fn deactivate_cameras_by_camera_location(\n        \u0026mut self,\n        location: Location,\n    ) -\u003e Result\u003c(), CameraError\u003e {\n        let mut locations_to_activate = Vec::new();\n        {\n            let mut cameras = match self.cameras.lock() {\n                Ok(guard) =\u003e guard,\n                Err(_) =\u003e {\n                    return Err(CameraError::ArcMutexError(\n                        \"Error locking cameras mutex\".to_string(),\n                    ));\n                }\n            };\n            for camera in cameras.values_mut() {\n                let distancia = camera.get_location().distance(location);\n                if distancia \u003c= NIVEL_DE_PROXIMIDAD_MAXIMO \u0026\u0026 !camera.get_sleep_mode() {\n                    camera.set_sleep_mode(true);\n                    locations_to_activate.push(camera.get_location());\n                }\n            }\n        }\n\n        for loc in locations_to_activate {\n            self.deactivate_cameras_by_camera_location(loc)?;\n        }\n\n        Ok(())\n    }\n\n    /// Envia un mensaje mediante el channel para que el cliente lo envie al broker\n    pub fn send_message(\n        \u0026mut self,\n        message: Box\u003cdyn MessagesConfig + Send\u003e,\n    ) -\u003e Result\u003c(), CameraError\u003e {\n        let packet_id = self.camera_system_client.assign_packet_id();\n        let message = message.parse_message(packet_id);\n        let lock = match self.send_to_client_channel.lock() {\n            Ok(lock) =\u003e lock,\n            Err(_) =\u003e {\n                return Err(CameraError::SendError);\n            }\n        };\n        match lock.send(Box::new(message)) {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                println!(\"CameraSys: Error sending message: {:?}\", e);\n                return Err(CameraError::SendError);\n            }\n        };\n        Ok(())\n    }\n\n    /// Compara la snapshot anterior que tiene almacenada con la actual, envia mediante un pub\n    /// Las camaras que hayan cambiado de estado entre el ultimo publish y este.\n    /// En un vector de camaras.\n    /// Si no hay cambios, no envia nada\n    /// Almacena la nueva snapshot para la proxima comparacion\n    pub fn publish_cameras_update(\u0026mut self) -\u003e Result\u003c(), CameraError\u003e {\n        let mut new_snapshot: Vec\u003cCamera\u003e = Vec::new();\n        let cameras = match self.cameras.lock() {\n            Ok(guard) =\u003e guard,\n            Err(_) =\u003e {\n                return Err(CameraError::ArcMutexError(\n                    \"Error locking cameras mutex\".to_string(),\n                ));\n            }\n        };\n        for camera in cameras.values() {\n            new_snapshot.push(camera.clone());\n        }\n        print!(\"SNAPSHOT ANTERIOR: {:?}\", self.snapshot);\n        println!(\"SNAPSHOT ACTUAL: {:?}\", new_snapshot);\n\n        let mut updated_cameras = Vec::new();\n        for camera in new_snapshot.iter() {\n            let camera_vieja = self.snapshot.iter().find(|\u0026x| x == camera).cloned();\n\n            if (!self.snapshot.contains(\u0026camera.clone()))\n                || (self.snapshot.contains(\u0026camera.clone())\n                    \u0026\u0026 camera.get_sleep_mode()\n                        != match self.snapshot.iter().find(|\u0026x| x == camera) {\n                            Some(camera) =\u003e camera.get_sleep_mode(),\n                            None =\u003e false,\n                        })\n            {\n                println!(\"CameraSys: camera: {:?}\", camera.clone());\n                if camera_vieja.is_some() {\n                    println!(\"CameraSys: camera vieja: {:?}\", camera_vieja.unwrap());\n                }\n                updated_cameras.push(camera.clone());\n            }\n        }\n        if updated_cameras.is_empty() {\n            return Ok(());\n        }\n        println!(\"CameraSys: publicando el estado de las camaras a el broker\");\n\n        let publish_config = match PublishConfig::read_config(\n            \"./src/surveilling/publish_config_update.json\",\n            PayloadTypes::CamerasUpdatePayload(updated_cameras),\n        ) {\n            Ok(config) =\u003e config,\n            Err(_) =\u003e {\n                return Err(CameraError::SendError);\n            }\n        };\n\n        let lock = match self.send_to_client_channel.lock() {\n            Ok(guard) =\u003e guard,\n            Err(_) =\u003e {\n                return Err(CameraError::SendError);\n            }\n        };\n\n        let _ = lock.send(Box::new(publish_config));\n\n        self.snapshot = new_snapshot;\n\n        Ok(())\n    }\n}\n\nimpl CameraSystem\u003cClient\u003e {\n    pub fn with_real_client(address: String) -\u003e Result\u003cCameraSystem\u003cClient\u003e, ProtocolError\u003e {\n        CameraSystem::new(address, |rx, addr, config, tx| {\n            Client::new(rx, addr, config, tx)\n        })\n    }\n}\n\n#[cfg(test)]\n\nmod tests {\n    use std::sync::{Arc, Condvar, Mutex};\n    use std::thread;\n\n    use crate::monitoring::incident::Incident;\n    use crate::mqtt::broker::Broker;\n    use crate::mqtt::client_message::ClientMessage;\n    use crate::utils::incident_payload::IncidentPayload;\n\n    use super::*;\n    impl CameraSystem\u003cClient\u003e {\n        fn get_client_publish_end_channel(\n            \u0026self,\n        ) -\u003e Arc\u003c\n            std::sync::Mutex\u003cstd::sync::mpsc::Receiver\u003cBox\u003c(dyn MessagesConfig + Send + 'static)\u003e\u003e\u003e,\n        \u003e {\n            self.camera_system_client.get_publish_end_channel()\n        }\n    }\n    #[test]\n    fn test01_new_camera_system_vacio() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5000\".to_string()];\n        let addr = \"127.0.0.1:5000\";\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e {\n                panic!(\"Error creating broker: {:?}\", e)\n            }\n        };\n        thread::spawn(move || {\n            _ = broker.server_run();\n        });\n\n        thread::spawn(\n            move || match CameraSystem::\u003cClient\u003e::with_real_client(addr.to_string()) {\n                Ok(mut camera_system) =\u003e {\n                    assert_eq!(camera_system.get_cameras().lock().unwrap().len(), 0);\n                    assert_eq!(camera_system.get_camera_by_id(1), None);\n                    assert_eq!(camera_system.get_camera(), None);\n                }\n                Err(e) =\u003e {\n                    panic!(\"Error creating camera system: {:?}\", e);\n                }\n            },\n        );\n    }\n\n    #[test]\n    fn test02_add_camera() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5000\".to_string()];\n        let addr = \"127.0.0.1:5000\";\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e {\n                panic!(\"Error creating broker: {:?}\", e)\n            }\n        };\n        thread::spawn(move || {\n            _ = broker.server_run();\n        });\n\n        thread::spawn(move || {\n            let mut camera_system =\n                CameraSystem::\u003cClient\u003e::with_real_client(addr.to_string()).unwrap();\n            let location = Location::new(1.0, 2.0);\n            let id = camera_system.add_camera(location.clone()).unwrap();\n            assert_eq!(camera_system.get_cameras().lock().unwrap().len(), 1);\n            assert_eq!(\n                camera_system.get_camera_by_id(id).unwrap().get_location(),\n                location\n            );\n        });\n    }\n\n    #[test]\n    fn test03_get_camera() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5000\".to_string()];\n        let addr = \"127.0.0.1:5000\";\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e {\n                panic!(\"Error creating broker: {:?}\", e)\n            }\n        };\n        thread::spawn(move || {\n            _ = broker.server_run();\n        });\n\n        thread::spawn(move || {\n            let mut camera_system =\n                CameraSystem::\u003cClient\u003e::with_real_client(addr.to_string()).unwrap();\n            let location = Location::new(1.0, 2.0);\n            let id = camera_system.add_camera(location.clone()).unwrap();\n            assert_eq!(camera_system.get_cameras().lock().unwrap().len(), 1);\n            assert_eq!(\n                camera_system.get_camera_by_id(id).unwrap().get_location(),\n                location\n            );\n            assert_eq!(camera_system.get_camera().unwrap().get_location(), location);\n        });\n    }\n\n    #[test]\n    fn test04_run_client() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5000\".to_string()];\n        let addr = \"127.0.0.1:5000\";\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e {\n                panic!(\"Error creating broker: {:?}\", e)\n            }\n        };\n        thread::spawn(move || {\n            _ = broker.server_run();\n        });\n\n        thread::spawn(move || {\n            let camera_system: CameraSystem\u003cClient\u003e =\n                CameraSystem::\u003cClient\u003e::with_real_client(addr.to_string()).unwrap();\n            let arc_system = Arc::new(Mutex::new(camera_system));\n            assert!(CameraSystem::\u003cClient\u003e::run_client(None, arc_system).is_ok());\n        });\n    }\n\n    #[test]\n\n    fn test05_envio_de_mensaje() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5000\".to_string()];\n        let addr = \"127.0.0.1:5000\";\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e {\n                panic!(\"Error creating broker: {:?}\", e)\n            }\n        };\n        thread::spawn(move || {\n            _ = broker.server_run();\n        });\n\n        thread::spawn(move || {\n            let mut camera_system =\n                CameraSystem::\u003cClient\u003e::with_real_client(addr.to_string()).unwrap();\n            let pingreq = ClientMessage::Pingreq;\n\n            match camera_system.send_message(Box::new(pingreq)) {\n                Ok(_) =\u003e {}\n                Err(e) =\u003e {\n                    panic!(\"Error sending message: {:?}\", e);\n                }\n            }\n        });\n    }\n\n    #[test]\n    fn test06_activar_camara() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5000\".to_string()];\n        let addr = \"127.0.0.1:5000\";\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e {\n                panic!(\"Error creating broker: {:?}\", e)\n            }\n        };\n        thread::spawn(move || {\n            _ = broker.server_run();\n        });\n\n        thread::spawn(move || {\n            let mut camera_system =\n                CameraSystem::\u003cClient\u003e::with_real_client(addr.to_string()).unwrap();\n            let location = Location::new(1.0, 2.0);\n            let id = camera_system.add_camera(location.clone()).unwrap();\n            assert_eq!(camera_system.get_cameras().lock().unwrap().len(), 1);\n            assert_eq!(\n                camera_system.get_camera_by_id(id).unwrap().get_location(),\n                location\n            );\n            assert_eq!(camera_system.get_camera().unwrap().get_location(), location);\n            let incident_location = Location::new(1.0, 2.0);\n            camera_system.activate_cameras(incident_location).unwrap();\n            for camera in camera_system.get_cameras().lock().unwrap().values() {\n                assert!(!camera.get_sleep_mode());\n            }\n        });\n    }\n\n    #[test]\n    fn test07_activar_multiples_camaras() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5005\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n        let addr = \"127.0.0.1:5005\";\n        let handle = thread::spawn(move || {\n            let mut camera_system =\n                CameraSystem::\u003cClient\u003e::with_real_client(addr.to_string()).unwrap();\n            let location = Location::new(5.0, 20.0);\n            let id = camera_system.add_camera(location.clone()).unwrap();\n            let location2 = Location::new(0.0001, 0.0002);\n            let id2 = camera_system.add_camera(location2.clone()).unwrap();\n            let location3 = Location::new(0.0003, 0.0001);\n            let id3: u32 = camera_system.add_camera(location3.clone()).unwrap();\n            let location4 = Location::new(10.0, 20.0);\n            let id4 = camera_system.add_camera(location4.clone()).unwrap();\n            let location5 = Location::new(0.0001, 0.0002);\n            let id5 = camera_system.add_camera(location5.clone()).unwrap();\n            assert_eq!(camera_system.get_cameras().lock().unwrap().len(), 5);\n            assert_eq!(\n                camera_system.get_camera_by_id(id).unwrap().get_location(),\n                location\n            );\n            let incident_location = Location::new(0.0, 0.0);\n            camera_system.activate_cameras(incident_location).unwrap();\n            assert!(camera_system.get_camera_by_id(id).unwrap().get_sleep_mode());\n            assert!(!camera_system\n                .get_camera_by_id(id2)\n                .unwrap()\n                .get_sleep_mode());\n            assert!(!camera_system\n                .get_camera_by_id(id3)\n                .unwrap()\n                .get_sleep_mode());\n            assert!(camera_system\n                .get_camera_by_id(id4)\n                .unwrap()\n                .get_sleep_mode());\n            assert!(!camera_system\n                .get_camera_by_id(id5)\n                .unwrap()\n                .get_sleep_mode());\n        });\n        match handle.join() {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                panic!(\"Error joining thread: {:?}\", e);\n            }\n        }\n    }\n\n    #[test]\n\n    fn test08_camara_lejana_se_activa_por_reaccion_en_cadena() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5020\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n        let addr = \"127.0.0.1:5020\";\n        let handle = thread::spawn(move || {\n            let mut camera_system =\n                CameraSystem::\u003cClient\u003e::with_real_client(addr.to_string()).unwrap();\n            let location = Location::new(10.0 / 10000.0, 0.0);\n            let id = camera_system.add_camera(location.clone()).unwrap();\n            let location2 = Location::new(11.0 / 10000.0, 0.0);\n            let id2 = camera_system.add_camera(location2.clone()).unwrap();\n\n            assert_eq!(camera_system.get_cameras().lock().unwrap().len(), 2);\n\n            let incident_location = Location::new(0.0, 0.0);\n            camera_system.activate_cameras(incident_location).unwrap();\n            assert!(!camera_system.get_camera_by_id(id).unwrap().get_sleep_mode());\n            assert!(!camera_system\n                .get_camera_by_id(id2)\n                .unwrap()\n                .get_sleep_mode());\n        });\n        handle.join().unwrap();\n    }\n\n    #[test]\n    fn test09_desactivar_camara() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5037\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n        let addr = \"127.0.0.1:5037\";\n        let handle = thread::spawn(move || {\n            let mut camera_system =\n                CameraSystem::\u003cClient\u003e::with_real_client(addr.to_string()).unwrap();\n            let location = Location::new(1.0, 2.0);\n            let id = camera_system.add_camera(location.clone()).unwrap();\n            assert_eq!(camera_system.get_cameras().lock().unwrap().len(), 1);\n            assert_eq!(\n                camera_system.get_camera_by_id(id).unwrap().get_location(),\n                location\n            );\n            let incident_location = Location::new(1.0, 2.0);\n            camera_system\n                .activate_cameras(incident_location.clone())\n                .unwrap();\n            for camera in camera_system.get_cameras().lock().unwrap().values() {\n                assert!(!camera.get_sleep_mode());\n            }\n            camera_system.deactivate_cameras(incident_location).unwrap();\n            for camera in camera_system.get_cameras().lock().unwrap().values() {\n                assert!(camera.get_sleep_mode());\n            }\n        });\n        handle.join().unwrap();\n    }\n\n    #[test]\n    fn test_10_deactivate_multiple_cameras() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5040\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n        let addr = \"127.0.0.1:5040\";\n        let handle = thread::spawn(move || {\n            let mut camera_system =\n                CameraSystem::\u003cClient\u003e::with_real_client(addr.to_string()).unwrap();\n            let location = Location::new(5.0 / 1000.0, 20.0 / 1000.0);\n            let id = camera_system.add_camera(location.clone()).unwrap();\n            let location2 = Location::new(5.0 / 10000.0, 2.0 / 10000.0);\n            let id2 = camera_system.add_camera(location2.clone()).unwrap();\n            let location3 = Location::new(10.0 / 10000.0, 2.0 / 10000.0);\n            let id3 = camera_system.add_camera(location3.clone()).unwrap();\n            let location4 = Location::new(10.0 / 1000.0, 20.0 / 1000.0);\n            let id4 = camera_system.add_camera(location4.clone()).unwrap();\n            let location5 = Location::new(1.0 / 10000.0, 2.0 / 10000.0);\n            let id5 = camera_system.add_camera(location5.clone()).unwrap();\n            assert_eq!(camera_system.get_cameras().lock().unwrap().len(), 5);\n            assert_eq!(\n                camera_system.get_camera_by_id(id).unwrap().get_location(),\n                location\n            );\n            let incident_location = Location::new(0.0, 0.0);\n            camera_system\n                .activate_cameras(incident_location.clone())\n                .unwrap();\n            assert!(camera_system.get_camera_by_id(id).unwrap().get_sleep_mode());\n            assert!(!camera_system\n                .get_camera_by_id(id2)\n                .unwrap()\n                .get_sleep_mode());\n            assert!(!camera_system\n                .get_camera_by_id(id3)\n                .unwrap()\n                .get_sleep_mode());\n            assert!(camera_system\n                .get_camera_by_id(id4)\n                .unwrap()\n                .get_sleep_mode());\n            assert!(!camera_system\n                .get_camera_by_id(id5)\n                .unwrap()\n                .get_sleep_mode());\n\n            camera_system.deactivate_cameras(incident_location).unwrap();\n            assert!(camera_system.get_camera_by_id(id).unwrap().get_sleep_mode());\n            assert!(camera_system\n                .get_camera_by_id(id2)\n                .unwrap()\n                .get_sleep_mode());\n            assert!(camera_system\n                .get_camera_by_id(id3)\n                .unwrap()\n                .get_sleep_mode());\n            assert!(camera_system\n                .get_camera_by_id(id4)\n                .unwrap()\n                .get_sleep_mode());\n            assert!(camera_system\n                .get_camera_by_id(id5)\n                .unwrap()\n                .get_sleep_mode());\n        });\n        handle.join().unwrap();\n    }\n\n    #[test]\n    fn test_11_desactivar_camara_por_proximidad() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5017\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n        let addr = \"127.0.0.1:5017\";\n        let handle = thread::spawn(move || {\n            let mut camera_system =\n                CameraSystem::\u003cClient\u003e::with_real_client(addr.to_string()).unwrap();\n            let location = Location::new(10.0 / 10000.0, 0.0);\n            let id = camera_system.add_camera(location.clone()).unwrap();\n            let location2 = Location::new(11.0 / 10000.0, 0.0);\n            let id2 = camera_system.add_camera(location2.clone()).unwrap();\n\n            assert_eq!(camera_system.get_cameras().lock().unwrap().len(), 2);\n\n            let incident_location = Location::new(0.0, 0.0);\n            camera_system.activate_cameras(incident_location).unwrap();\n            assert!(!camera_system.get_camera_by_id(id).unwrap().get_sleep_mode());\n            assert!(!camera_system\n                .get_camera_by_id(id2)\n                .unwrap()\n                .get_sleep_mode());\n\n            let incident_location = Location::new(0.0, 0.0);\n            camera_system.deactivate_cameras(incident_location).unwrap();\n            assert!(camera_system.get_camera_by_id(id).unwrap().get_sleep_mode());\n            assert!(camera_system\n                .get_camera_by_id(id2)\n                .unwrap()\n                .get_sleep_mode());\n        });\n        handle.join().unwrap();\n    }\n\n    #[test]\n    fn test_12_multiples_incidentes() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5066\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n        let addr = \"127.0.0.1:5066\";\n        let handle = thread::spawn(move || {\n            let mut cameras = HashMap::new();\n            let mut camera_system =\n                CameraSystem::\u003cClient\u003e::with_real_client(addr.to_string()).unwrap();\n            let channel = camera_system.get_client_publish_end_channel();\n            let location = Location::new(10.0 / 10000.0, 0.0);\n            let id = camera_system.add_camera(location.clone()).unwrap();\n            let location2 = Location::new(11.0 / 10000.0, 0.0);\n            let id2 = camera_system.add_camera(location2.clone()).unwrap();\n\n            assert_eq!(camera_system.get_cameras().lock().unwrap().len(), 2);\n\n            let incident_location = Location::new(0.0, 0.0);\n            camera_system.activate_cameras(incident_location).unwrap();\n            assert!(!camera_system.get_camera_by_id(id).unwrap().get_sleep_mode());\n            assert!(!camera_system\n                .get_camera_by_id(id2)\n                .unwrap()\n                .get_sleep_mode());\n\n            let incident_location = Location::new(0.0, 0.0);\n            camera_system.activate_cameras(incident_location).unwrap();\n            assert!(!camera_system.get_camera_by_id(id).unwrap().get_sleep_mode());\n            assert!(!camera_system\n                .get_camera_by_id(id2)\n                .unwrap()\n                .get_sleep_mode());\n\n            let incident_location = Location::new(2.00001, 2.00001);\n            let id3 = camera_system.add_camera(incident_location.clone()).unwrap();\n            let id4 = camera_system.add_camera(incident_location.clone()).unwrap();\n            camera_system.activate_cameras(incident_location).unwrap();\n            assert!(!camera_system.get_camera_by_id(id).unwrap().get_sleep_mode());\n            assert!(!camera_system\n                .get_camera_by_id(id2)\n                .unwrap()\n                .get_sleep_mode());\n            assert!(!camera_system\n                .get_camera_by_id(id3)\n                .unwrap()\n                .get_sleep_mode());\n            assert!(!camera_system\n                .get_camera_by_id(id4)\n                .unwrap()\n                .get_sleep_mode());\n            let message_config = channel.lock().unwrap().recv().unwrap();\n            let message = message_config.parse_message(0);\n            println!(\"mensaje 1{:?}\", message);\n            let message_config = channel.lock().unwrap().recv().unwrap();\n            let message = message_config.parse_message(1);\n            println!(\"mensaje 2{:?}\", message);\n            let message_config = channel.lock().unwrap().recv().unwrap();\n            let message = message_config.parse_message(2);\n            println!(\"mensaje 3{:?}\", message);\n            match message {\n                ClientMessage::Publish {\n                    packet_id: _,\n                    topic_name: _,\n                    qos: _,\n                    retain_flag: _,\n                    payload,\n                    dup_flag: _,\n                    properties: _,\n                } =\u003e {\n                    if let PayloadTypes::CamerasUpdatePayload(updated_cameras) = payload {\n                        for camera in updated_cameras {\n                            cameras.insert(camera.get_id(), camera);\n                        }\n                    }\n                }\n                _ =\u003e {\n                    panic!(\"Unexpected message type\");\n                }\n            }\n            let message_config = channel.lock().unwrap().recv().unwrap();\n            let message = message_config.parse_message(3);\n            println!(\"mensaje 4{:?}\", message);\n            match message {\n                ClientMessage::Publish {\n                    packet_id: _,\n                    topic_name: _,\n                    qos: _,\n                    retain_flag: _,\n                    payload,\n                    dup_flag: _,\n                    properties: _,\n                } =\u003e {\n                    if let PayloadTypes::CamerasUpdatePayload(updated_cameras) = payload {\n                        for camera in updated_cameras {\n                            cameras.insert(camera.get_id(), camera);\n                        }\n                    }\n                }\n                _ =\u003e {\n                    panic!(\"Unexpected message type\");\n                }\n            }\n            assert_eq!(cameras.len(), 4);\n            for camera in cameras.values() {\n                assert!(!camera.get_sleep_mode());\n            }\n        });\n        handle.join().unwrap();\n    }\n    #[test]\n\n    fn test_update_cameras() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5033\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n        let addr = \"127.0.0.1:5033\";\n        let handle = thread::spawn(move || {\n            let mut camera_system =\n                CameraSystem::\u003cClient\u003e::with_real_client(addr.to_string()).unwrap();\n            let reciever = camera_system.camera_system_client.get_publish_end_channel();\n            let reciever = reciever.lock().unwrap();\n            let message = reciever.recv().unwrap();\n            //conver message to a ClientMessage\n            let packet_id = camera_system.camera_system_client.assign_packet_id();\n            let message = message.parse_message(packet_id);\n            // Recibe el sub que hace el camera_system cuando se crea por primera vez\n            match message {\n                ClientMessage::Subscribe {\n                    packet_id: _,\n                    payload,\n                    properties: _,\n                } =\u003e {\n                    for topic in payload {\n                        assert_eq!(topic.topic, \"incidente\");\n                    }\n                }\n                _ =\u003e {\n                    panic!(\"Unexpected message type\");\n                }\n            }\n            let message = reciever.recv().unwrap();\n            //conver message to a ClientMessage\n            let packet_id = camera_system.camera_system_client.assign_packet_id();\n            let message = message.parse_message(packet_id);\n            // Recibe el sub que hace el camera_system cuando se crea por primera vez\n            match message {\n                ClientMessage::Subscribe {\n                    packet_id: _,\n                    payload,\n                    properties: _,\n                } =\u003e {\n                    for topic in payload {\n                        assert_eq!(topic.topic, \"incidente_resuelto\");\n                    }\n                }\n                _ =\u003e {\n                    panic!(\"Unexpected message type\");\n                }\n            }\n            let location = Location::new(1.0, 2.0);\n            let id = camera_system.add_camera(location.clone()).unwrap();\n            assert_eq!(camera_system.get_cameras().lock().unwrap().len(), 1);\n            assert_eq!(\n                camera_system.get_camera_by_id(id).unwrap().get_location(),\n                location\n            );\n            let incident_location = Location::new(1.0, 2.0);\n            camera_system\n                .activate_cameras(incident_location.clone())\n                .unwrap();\n            for camera in camera_system.get_cameras().lock().unwrap().values() {\n                assert!(!camera.get_sleep_mode());\n            }\n\n            let message = reciever.recv().unwrap();\n            //conver message to a ClientMessage\n            let packet_id = camera_system.camera_system_client.assign_packet_id();\n            let message = message.parse_message(packet_id);\n\n            match message {\n                ClientMessage::Publish {\n                    topic_name,\n                    payload: PayloadTypes::CamerasUpdatePayload(cameras),\n                    ..\n                } =\u003e {\n                    assert_eq!(topic_name, \"camera_update\");\n                    assert_eq!(cameras.len(), 1);\n                    assert_eq!(cameras[0].get_location(), location);\n                    assert!(!cameras[0].get_sleep_mode());\n                }\n                _ =\u003e {\n                    panic!(\"Unexpected message type: {:?}\", message);\n                }\n            }\n\n            camera_system.deactivate_cameras(incident_location).unwrap();\n            for camera in camera_system.get_cameras().lock().unwrap().values() {\n                assert!(camera.get_sleep_mode());\n            }\n\n            let message = reciever.recv().unwrap();\n            //conver message to a ClientMessage\n            let packet_id = camera_system.camera_system_client.assign_packet_id();\n            let message = message.parse_message(packet_id);\n            print!(\"AAAAAAAAAAAAa{:?}\", message);\n\n            match message {\n                ClientMessage::Publish {\n                    topic_name,\n                    payload: PayloadTypes::CamerasUpdatePayload(cameras),\n                    ..\n                } =\u003e {\n                    assert_eq!(topic_name, \"camera_update\");\n                    assert_eq!(cameras.len(), 1);\n                    assert_eq!(cameras[0].get_location(), location);\n                    assert!(cameras[0].get_sleep_mode());\n                }\n                _ =\u003e {\n                    panic!(\"Unexpected message type\");\n                }\n            }\n        });\n\n        handle.join().unwrap();\n    }\n\n    #[test]\n    fn test_run_client() {\n        #[derive(Debug, Clone)]\n        pub struct MockClient {\n            messages: Vec\u003cclient_message::ClientMessage\u003e,\n        }\n\n        impl ClientTrait for MockClient {\n            fn client_run(\u0026mut self) -\u003e Result\u003c(), ProtocolError\u003e {\n                Ok(())\n            }\n\n            fn clone_box(\u0026self) -\u003e Box\u003cdyn ClientTrait\u003e {\n                Box::new(self.clone())\n            }\n            fn assign_packet_id(\u0026self) -\u003e u16 {\n                0\n            }\n            fn get_publish_end_channel(\n                \u0026self,\n            ) -\u003e Arc\u003c\n                std::sync::Mutex\u003c\n                    std::sync::mpsc::Receiver\u003cBox\u003c(dyn MessagesConfig + Send + 'static)\u003e\u003e,\n                \u003e,\n            \u003e {\n                Arc::new(std::sync::Mutex::new(std::sync::mpsc::channel().1))\n            }\n\n            fn get_client_id(\u0026self) -\u003e String {\n                \"mock\".to_string()\n            }\n        }\n\n        impl MockClient {\n            pub fn new(messages: Vec\u003cclient_message::ClientMessage\u003e) -\u003e MockClient {\n                MockClient { messages }\n            }\n\n            pub fn send_messages(\u0026self, sender: \u0026Sender\u003cclient_message::ClientMessage\u003e) {\n                for message in \u0026self.messages {\n                    sender.send(message.clone()).unwrap();\n                }\n            }\n        }\n\n        let args = vec![\"127.0.0.1\".to_string(), \"5006\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n        let address = \"127.0.0.1:5006\".to_string();\n\n        let publish_config = PublishConfig::read_config(\n            \"./src/surveilling/publish_config_test.json\",\n            PayloadTypes::IncidentLocation(IncidentPayload::new(Incident::new(Location::new(\n                1.0, 2.0,\n            )))),\n        )\n        .unwrap();\n        let publish = publish_config.parse_message(3);\n\n        let messages = vec![publish];\n        let mock_client = MockClient::new(messages.clone());\n\n        let (tx2, rx2) = mpsc::channel();\n\n        let mut camera_system =\n            CameraSystem::\u003cMockClient\u003e::new(address.clone(), |_rx, _addr, _configg, _tx| {\n                Ok(MockClient { messages })\n            })\n            .unwrap();\n\n        //add cameras\n        let location = Location::new(1.0, 1.0);\n        let _ = camera_system.add_camera(location.clone());\n        let location2 = Location::new(1.0, 2.0);\n        let _ = camera_system.add_camera(location2.clone());\n        let location3 = Location::new(1.0, 3.0);\n        let _ = camera_system.add_camera(location3.clone());\n        let location4 = Location::new(2.0, 5.0);\n        let _ = camera_system.add_camera(location4.clone());\n\n        let handle = thread::spawn(move || {\n            mock_client.send_messages(\u0026tx2);\n            println!(\"CameraSys: meu deus\");\n            let arc_system: Arc\u003cMutex\u003cCameraSystem\u003cClient\u003e\u003e\u003e = Arc::new(Mutex::new(\n                CameraSystem::\u003cClient\u003e::with_real_client(address.to_string()).unwrap(),\n            ));\n            let arc_sys_clone = Arc::clone(\u0026arc_system);\n            let arc_rx2 = Arc::new(Mutex::new(rx2));\n            match CameraSystem::\u003cClient\u003e::run_client(Some(arc_rx2), arc_sys_clone) {\n                Ok(_) =\u003e {}\n                Err(e) =\u003e {\n                    println!(\"CameraSys: Error running client: {:?}\", e);\n                }\n            }\n            let camera_system = arc_system.lock().unwrap();\n            // Verify that cameras were activated as expected\n            for camera in camera_system.get_cameras().lock().unwrap().values() {\n                println!(\n                    \"camer: location {:?}, sleep: {:?}\",\n                    camera.get_location(),\n                    camera.get_sleep_mode()\n                );\n\n                assert!(!camera.get_sleep_mode());\n            }\n        });\n\n        handle.join().unwrap();\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":57075},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":57075},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":57075},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":57075},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":57075},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":57075},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":57075},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":57075},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":57075},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":57075},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":57075},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":57075},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":114150},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":57073},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":17},"fn_name":null}],"covered":147,"coverable":266},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","surveilling","mod.rs"],"content":"pub mod camera;\n\npub mod camera_system;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","surveilling","run_camera_system.rs"],"content":"use std::{\n    env::args,\n    io::{stdin, Read},\n};\n\nuse rustic_city_eye::{\n    mqtt::protocol_error::ProtocolError, surveilling::camera_system::CameraSystem,\n};\n\nfn main() -\u003e Result\u003c(), ProtocolError\u003e {\n    let argv = args().collect::\u003cVec\u003cString\u003e\u003e();\n\n    let mut _camera_system = CameraSystem::new(argv)?;\n    let _stream: Box\u003cdyn Read + Send\u003e = Box::new(stdin());\n\n    // let _ = camera_system.app_run(stream);\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","utils","incident_payload.rs"],"content":"use serde::Deserialize;\n\nuse crate::{monitoring::incident::Incident, mqtt::protocol_error::ProtocolError};\n\n#[derive(Clone, Debug, PartialEq, Deserialize)]\npub struct IncidentPayload {\n    id: u8,\n    incident: Incident,\n}\n\n/// Aqui se define el payload para los packets del tipo publish\n/// que notifiquen de incidentes.\n/// El IncidentPayload se identifica con un id = 1: este id sirve para\n/// diferenciar los distintos tipos de payloads que va a tener la aplicacion.\nimpl IncidentPayload {\n    pub fn new(incident: Incident) -\u003e IncidentPayload {\n        IncidentPayload { id: 1, incident }\n    }\n\n    ///Se sabe escribir sobre un stream dado.\n    pub fn write_to(\u0026self, stream: \u0026mut dyn std::io::prelude::Write) -\u003e Result\u003c(), ProtocolError\u003e {\n        self.incident.write_to(stream)?;\n        Ok(())\n    }\n\n    pub fn get_incident(\u0026self) -\u003e Incident {\n        self.incident.clone()\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":4,"coverable":6},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","utils","json_readers.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","utils","location.rs"],"content":"use serde::Deserialize;\n/// Contiene una localizacion especifica en el mapa.\n///\n/// La idea es que implemente el trait de Payload que nos provee la API del cliente,\n/// de forma tal que al ingresar un incidente en la aplicacion, se envie un packet\n/// del tipo Publish con la localizacion del incidente como Payload,\n/// para que las distintas unidades de la aplicacion sepan donde se encuentran\n/// los incidentes a resolver.\n#[derive(Debug, Clone, PartialEq, Deserialize, Copy)]\npub struct Location {\n    pub long: f64,\n    pub lat: f64,\n}\n\nimpl Location {\n    pub fn new(lat: f64, long: f64) -\u003e Location {\n        Location { lat, long }\n    }\n\n    pub fn get_latitude(\u0026self) -\u003e f64 {\n        self.lat\n    }\n\n    pub fn get_longitude(\u0026self) -\u003e f64 {\n        self.long\n    }\n\n    /// Recive una ubicacion y calcula la distancia euclideana entre esta y la ubicacion de la propia location\n    pub fn distance(\u0026self, location: Location) -\u003e f64 {\n        ((location.get_latitude() - self.get_latitude()).powi(2)\n            + (location.get_longitude() - self.get_longitude()).powi(2))\n        .sqrt()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::f64::consts::SQRT_2;\n\n    use super::*;\n\n    #[test]\n    fn test_location_new() {\n        let location = Location::new(1.0, 2.0);\n        assert_eq!(location.lat, 1.0);\n        assert_eq!(location.long, 2.0);\n    }\n\n    #[test]\n    fn test_distance() {\n        let location = Location::new(1.0, 2.0);\n        let location2 = Location::new(2.0, 3.0);\n        assert_eq!(location.distance(location2), SQRT_2);\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":222},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":111},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":111},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":111},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","utils","mod.rs"],"content":"pub mod incident_payload;\npub mod location;\npub mod payload_types;\npub mod reader;\npub mod threadpool;\npub mod writer;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","utils","payload_types.rs"],"content":"use std::{\n    any::Any,\n    io::{Error, ErrorKind, Read},\n};\n\nuse serde::Deserialize;\n\nuse crate::{\n    monitoring::incident::Incident,\n    mqtt::{payload::Payload, protocol_error::ProtocolError},\n    surveilling::camera::Camera,\n    utils::{\n        incident_payload::IncidentPayload,\n        location::Location,\n        reader::{read_string, read_u8},\n    },\n};\n\nuse super::writer::{write_string, write_u8};\n\n/// Aqui se definen los distintos tipos de payload que va a soportar nuestra aplicacion.\n/// La idea es que implemente el trait de Payload, de forma tal que sepa escribirse sobre un stream dado.\n#[derive(Clone, Debug, PartialEq, Deserialize)]\npub enum PayloadTypes {\n    IncidentLocation(IncidentPayload),\n    AttendingIncident(IncidentPayload),\n    WillPayload(String),\n    LocationPayload(Location),\n    CamerasUpdatePayload(Vec\u003cCamera\u003e),\n    DroneLocation(u32, Location),\n}\n\nimpl Payload for PayloadTypes {\n    fn write_to(\u0026self, stream: \u0026mut dyn std::io::prelude::Write) -\u003e Result\u003c(), ProtocolError\u003e {\n        match self {\n            PayloadTypes::IncidentLocation(payload) =\u003e {\n                write_u8(stream, \u00261)?;\n                payload.write_to(stream)?;\n\n                Ok(())\n            }\n            PayloadTypes::WillPayload(payload) =\u003e {\n                write_u8(stream, \u00262)?;\n                write_string(stream, payload)?;\n\n                Ok(())\n            }\n            PayloadTypes::LocationPayload(payload) =\u003e {\n                write_u8(stream, \u00263)?;\n                write_string(stream, \u0026payload.get_latitude().to_string())?;\n                write_string(stream, \u0026payload.get_longitude().to_string())?;\n\n                Ok(())\n            }\n            PayloadTypes::CamerasUpdatePayload(payload) =\u003e {\n                write_u8(stream, \u00264)?;\n                write_u8(stream, \u0026(payload.len() as u8))?;\n\n                for camera in payload {\n                    let mut camera_clone = camera.clone();\n                    match camera_clone.write_to(stream) {\n                        Ok(_) =\u003e {}\n                        Err(_) =\u003e return Err(ProtocolError::WriteError),\n                    }\n                }\n\n                Ok(())\n            }\n            PayloadTypes::DroneLocation(drone_id, location) =\u003e {\n                write_u8(stream, \u00265)?;\n                write_string(stream, \u0026drone_id.to_string())?;\n                write_string(stream, \u0026location.get_latitude().to_string())?;\n                write_string(stream, \u0026location.get_longitude().to_string())?;\n\n                Ok(())\n            }\n            PayloadTypes::AttendingIncident(payload) =\u003e {\n                write_u8(stream, \u00266)?;\n                payload.write_to(stream)?;\n\n                Ok(())\n            }\n        }\n    }\n\n    fn as_any(\u0026self) -\u003e \u0026dyn Any {\n        self\n    }\n}\n\nimpl PayloadTypes {\n    /// Dependiendo del id del payload que se lea, se va a reconstruir el payload a partir de lo\n    /// leido efectivamente del stream.\n    pub fn read_from(stream: \u0026mut dyn Read) -\u003e Result\u003cPayloadTypes, std::io::Error\u003e {\n        let payload_type_id = read_u8(stream)?;\n\n        let payload_type = match payload_type_id {\n            1 =\u003e {\n                let longitude_string = read_string(stream)?;\n                let long = match longitude_string.parse::\u003cf64\u003e() {\n                    Ok(long) =\u003e long,\n                    Err(_) =\u003e {\n                        return Err(Error::new(\n                            ErrorKind::InvalidData,\n                            \"Error while reading payload\".to_string(),\n                        ))\n                    }\n                };\n\n                let latitude_string = read_string(stream)?;\n\n                let lat = match latitude_string.parse::\u003cf64\u003e() {\n                    Ok(lat) =\u003e lat,\n                    Err(_) =\u003e {\n                        return Err(Error::new(\n                            ErrorKind::InvalidData,\n                            \"Error while reading payload\".to_string(),\n                        ))\n                    }\n                };\n\n                let location = Location::new(lat, long);\n                let incident = Incident::new(location);\n\n                PayloadTypes::IncidentLocation(IncidentPayload::new(incident))\n            }\n            4 =\u003e {\n                let lenght = read_u8(stream)?;\n                let mut cameras = Vec::new();\n                for _ in 0..lenght {\n                    let camera = Camera::read_from(stream)?;\n                    cameras.push(camera);\n                }\n\n                PayloadTypes::CamerasUpdatePayload(cameras)\n            }\n            5 =\u003e {\n                let drone_id_string = read_string(stream)?;\n                let drone_id = match drone_id_string.parse::\u003cu32\u003e() {\n                    Ok(drone_id) =\u003e drone_id,\n                    Err(_) =\u003e {\n                        return Err(Error::new(\n                            ErrorKind::InvalidData,\n                            \"Error while reading payload\".to_string(),\n                        ))\n                    }\n                };\n\n                let longitude_string = read_string(stream)?;\n                let long = match longitude_string.parse::\u003cf64\u003e() {\n                    Ok(long) =\u003e long,\n                    Err(_) =\u003e {\n                        return Err(Error::new(\n                            ErrorKind::InvalidData,\n                            \"Error while reading payload\".to_string(),\n                        ))\n                    }\n                };\n\n                let latitude_string = read_string(stream)?;\n                let lat = match latitude_string.parse::\u003cf64\u003e() {\n                    Ok(lat) =\u003e lat,\n                    Err(_) =\u003e {\n                        return Err(Error::new(\n                            ErrorKind::InvalidData,\n                            \"Error while reading payload\".to_string(),\n                        ))\n                    }\n                };\n\n                let location = Location::new(lat, long);\n\n                PayloadTypes::DroneLocation(drone_id, location)\n            }\n            6 =\u003e {\n                let longitude_string = read_string(stream)?;\n                let long = match longitude_string.parse::\u003cf64\u003e() {\n                    Ok(long) =\u003e long,\n                    Err(_) =\u003e {\n                        return Err(Error::new(\n                            ErrorKind::InvalidData,\n                            \"Error while reading payload\".to_string(),\n                        ))\n                    }\n                };\n\n                let latitude_string = read_string(stream)?;\n\n                let lat = match latitude_string.parse::\u003cf64\u003e() {\n                    Ok(lat) =\u003e lat,\n                    Err(_) =\u003e {\n                        return Err(Error::new(\n                            ErrorKind::InvalidData,\n                            \"Error while reading payload\".to_string(),\n                        ))\n                    }\n                };\n\n                let location = Location::new(lat, long);\n                let incident = Incident::new(location);\n                PayloadTypes::AttendingIncident(IncidentPayload::new(incident))\n            }\n            _ =\u003e {\n                return Err(Error::new(\n                    ErrorKind::InvalidData,\n                    \"Error while reading payload\".to_string(),\n                ))\n            }\n        };\n        Ok(payload_type)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::{Cursor, Read};\n\n    #[test]\n    fn test_read_from() {\n        let location = Location::new(1.0, 2.0);\n        let incident = Incident::new(location.clone());\n        let incident_payload = IncidentPayload::new(incident.clone());\n        let payload = PayloadTypes::IncidentLocation(incident_payload.clone());\n\n        let mut cursor = Cursor::new(Vec::new());\n        payload.write_to(\u0026mut cursor).unwrap();\n        cursor.set_position(0);\n\n        let read_payload = PayloadTypes::read_from(\u0026mut cursor).unwrap();\n        assert_eq!(read_payload, payload);\n    }\n\n    #[test]\n    fn test_write_to() {\n        let location = Location::new(1.0, 2.0);\n        let incident = Incident::new(location.clone());\n        let incident_payload = IncidentPayload::new(incident.clone());\n        let payload = PayloadTypes::IncidentLocation(incident_payload.clone());\n\n        let mut cursor = Cursor::new(Vec::new());\n        payload.write_to(\u0026mut cursor).unwrap();\n        cursor.set_position(0);\n\n        let mut buf = [0u8; 1];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(buf[0], 1);\n    }\n\n    #[test]\n    fn test_as_any() {\n        let location = Location::new(1.0, 2.0);\n        let incident = Incident::new(location.clone());\n        let incident_payload = IncidentPayload::new(incident.clone());\n        let payload = PayloadTypes::IncidentLocation(incident_payload.clone());\n\n        assert!(payload.as_any().is::\u003cPayloadTypes\u003e());\n    }\n\n    #[test]\n    fn test_clone() {\n        let location = Location::new(1.0, 2.0);\n        let incident = Incident::new(location.clone());\n        let incident_payload = IncidentPayload::new(incident.clone());\n        let payload = PayloadTypes::IncidentLocation(incident_payload.clone());\n\n        assert_eq!(payload.clone(), payload);\n    }\n\n    #[test]\n    fn test_eq() {\n        let location = Location::new(1.0, 2.0);\n        let incident = Incident::new(location.clone());\n        let incident_payload = IncidentPayload::new(incident.clone());\n        let payload = PayloadTypes::IncidentLocation(incident_payload.clone());\n\n        assert_eq!(payload, payload);\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":19,"coverable":90},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","utils","reader.rs"],"content":"use std::io::{Error, Read};\n\npub fn read_string(stream: \u0026mut dyn Read) -\u003e Result\u003cString, Error\u003e {\n    let string_length = read_u16(stream)?;\n    let mut string_buf = vec![0; string_length as usize];\n    stream.read_exact(\u0026mut string_buf)?;\n\n    let protocol_name = std::str::from_utf8(\u0026string_buf).expect(\"Error al leer protocol_name\");\n    Ok(protocol_name.to_string())\n}\n\npub fn read_u8(stream: \u0026mut dyn Read) -\u003e Result\u003cu8, Error\u003e {\n    let mut buf = [0u8; 1];\n    stream.read_exact(\u0026mut buf)?;\n    Ok(u8::from_be_bytes(buf))\n}\n\npub fn read_u16(stream: \u0026mut dyn Read) -\u003e Result\u003cu16, Error\u003e {\n    let mut buf = [0u8; 2];\n    stream.read_exact(\u0026mut buf)?;\n    Ok(u16::from_be_bytes(buf))\n}\n\npub fn read_u32(stream: \u0026mut dyn Read) -\u003e Result\u003cu32, Error\u003e {\n    let mut buf = [0u8; 4];\n    stream.read_exact(\u0026mut buf)?;\n    Ok(u32::from_be_bytes(buf))\n}\n\npub fn read_string_pairs(stream: \u0026mut dyn Read) -\u003e Result\u003cVec\u003c(String, String)\u003e, Error\u003e {\n    let length = read_u16(stream)?;\n    let mut pairs = Vec::with_capacity(length as usize);\n    for _ in 0..length {\n        let key = read_string(stream)?;\n        let value = read_string(stream)?;\n        pairs.push((key, value));\n    }\n    Ok(pairs)\n}\n\npub fn read_bin_vec(reader: \u0026mut dyn Read) -\u003e Result\u003cVec\u003cu8\u003e, Error\u003e {\n    let length = read_u16(reader)?;\n    let mut buffer = vec![0; length as usize];\n    reader.read_exact(\u0026mut buffer)?;\n    Ok(buffer)\n}\n\npub fn read_tuple_vec(reader: \u0026mut dyn Read) -\u003e Result\u003cVec\u003c(String, String)\u003e, Error\u003e {\n    let length = read_u16(reader)?;\n    let mut vec = Vec::with_capacity(length as usize);\n    for _ in 0..length {\n        let key = read_string(reader)?;\n        let value = read_string(reader)?;\n        vec.push((key, value));\n    }\n    Ok(vec)\n}\npub fn read_bool(stream: \u0026mut dyn Read) -\u003e Result\u003cbool, Error\u003e {\n    let mut buf = [0u8; 1];\n    stream.read_exact(\u0026mut buf)?;\n    Ok(buf[0] != 0)\n}\n\n#[cfg(test)]\n\nmod tests {\n    use super::*;\n    use std::io::Cursor;\n\n    #[test]\n    fn test_read_string() {\n        let mut cursor = Cursor::new(vec![0, 4, 116, 101, 115, 116]);\n        assert_eq!(read_string(\u0026mut cursor).unwrap(), \"test\".to_string());\n    }\n\n    #[test]\n    fn test_read_u8() {\n        let mut cursor = Cursor::new(vec![1]);\n        assert_eq!(read_u8(\u0026mut cursor).unwrap(), 1);\n    }\n\n    #[test]\n    fn test_read_u16() {\n        let mut cursor = Cursor::new(vec![123, 128, 129]);\n        assert_eq!(read_u16(\u0026mut cursor).unwrap(), 31616);\n    }\n\n    #[test]\n    fn test_read_u32() {\n        let mut cursor = Cursor::new(vec![0, 1, 0, 0, 0, 2]);\n        assert_eq!(read_u32(\u0026mut cursor).unwrap(), 65536);\n    }\n\n    #[test]\n    fn test_read_bin_vec() {\n        let mut cursor = Cursor::new(vec![0, 1, 1]);\n        assert_eq!(read_bin_vec(\u0026mut cursor).unwrap(), vec![1]);\n    }\n\n    #[test]\n    fn test_read_tuple_vec() {\n        let mut cursor = Cursor::new(vec![\n            0, 1, 0, 4, 116, 101, 115, 116, 0, 1, 0, 4, 116, 101, 115, 116, 0, 1, 0, 4, 116, 101,\n            115, 116,\n        ]);\n        assert_eq!(\n            read_tuple_vec(\u0026mut cursor).unwrap(),\n            vec![(\"test\".to_string(), \"\\0\".to_string())]\n        );\n    }\n\n    #[test]\n    fn test_read_bool() {\n        let mut cursor = Cursor::new(vec![1]);\n        assert!(read_bool(\u0026mut cursor).unwrap());\n    }\n}\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":916},"fn_name":null},{"line":4,"address":[],"length":0,"stats":{"Line":1832},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":916},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":916},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":1717},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":1717},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1717},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":1717},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1572},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1572},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1572},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1572},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":260},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":260},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":260},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":260},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":133},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":266},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":133},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":162},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":132},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":258},"fn_name":null}],"covered":33,"coverable":35},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","utils","threadpool.rs"],"content":"use std::{\n    sync::{\n        mpsc::{self, channel, Receiver},\n        Arc, Mutex,\n    },\n    thread,\n};\n/// El codigo que estan por ver es un poco falopa, pasa que tiene que ser una interfaz muy generalista\n/// Los workers tienen un thread y un ID, se crean segun el valor que se le pase por parametro al constructor.\n/// Si se ejecuta new(4), se crearan 4 workers.\n/// el sender es el encargado de recibir el nuevo job a ejecutar.\n#[allow(dead_code)]\npub struct ThreadPool {\n    workers: Vec\u003cWorker\u003e,\n    sender: mpsc::Sender\u003cJob\u003e,\n}\n#[allow(dead_code)]\nstruct Worker {\n    id: usize,\n    thread: thread::JoinHandle\u003c()\u003e,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc\u003cMutex\u003cmpsc::Receiver\u003cJob\u003e\u003e\u003e) -\u003e Worker {\n        let thread = thread::spawn(move || loop {\n            let job = match receiver.lock() {\n                Ok(lock) =\u003e match lock.recv() {\n                    Ok(job) =\u003e job,\n                    Err(_) =\u003e {\n                        return;\n                    }\n                },\n                Err(err) =\u003e {\n                    println!(\"Failed to acquire lock: {:?}\", err);\n                    continue;\n                }\n            };\n\n            job();\n        });\n\n        Worker { id, thread }\n    }\n}\n\ntype Job = Box\u003cdyn FnOnce() + Send + 'static\u003e;\n\nimpl ThreadPool {\n    pub fn new(size: usize) -\u003e ThreadPool {\n        assert!(size \u003e 0);\n\n        let (sender, receiver) = mpsc::channel();\n\n        let receiver = Arc::new(Mutex::new(receiver));\n\n        let mut workers = Vec::with_capacity(size);\n\n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(\u0026receiver)));\n        }\n\n        ThreadPool { workers, sender }\n    }\n\n    /// Esta funcion recibe una funncion F y devuelve un reciever con el resultado de la misma.\n    /// el channel creado internamente es para ejecutar la funcion F y luego retornar el resultado de su ejecución\n    /// Se le pide entonces al job que ejecute F y mande su resultado por el channel.\n    /// Luego se le pasa ese job a un worker disponible mediante el self.sender.\n    /// Es en ese momento que la funcion F se ejecuta.\n    pub fn execute\u003cF, R\u003e(\u0026self, f: F) -\u003e Receiver\u003cR\u003e\n    where\n        F: FnOnce() -\u003e R + Send + 'static,\n        R: Send + 'static,\n    {\n        let (tx, rx) = channel();\n        let senderr = self.sender.clone();\n\n        let job = Box::new(move || {\n            let result = f();\n            if let Err(err) = tx.send(result) {\n                println!(\"Failed to send result: {:?}\", err);\n            }\n        });\n\n        if let Err(err) = senderr.send(job) {\n            println!(\"Failed to send job: {:?}\", err);\n        }\n\n        rx\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_threadpool() {\n        let pool = ThreadPool::new(4);\n\n        let result = pool.execute(|| 1 + 2).recv().unwrap();\n        assert_eq!(result, 3);\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":529},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1129},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":671},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":600},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":529},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1089},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":529},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":141},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":71},"fn_name":null}],"covered":22,"coverable":27},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","src","utils","writer.rs"],"content":"use std::io::Write;\n\nuse crate::mqtt::protocol_error::ProtocolError;\n\n///Recibe un string y el stream al que escribir ese stream\n///\n/// Calcula su largo y luego escribe el largo y el string en el stream\npub fn write_string(stream: \u0026mut dyn Write, string: \u0026str) -\u003e Result\u003c(), ProtocolError\u003e {\n    let length = string.len() as u16;\n    let length_bytes = length.to_be_bytes();\n    let _ = stream\n        .write_all(\u0026length_bytes)\n        .map_err(|_e| ProtocolError::WriteError);\n    let _ = stream\n        .write_all(string.as_bytes())\n        .map_err(|_e| ProtocolError::WriteError);\n    Ok(())\n}\n\npub fn write_tuple_vec(\n    stream: \u0026mut dyn Write,\n    vec: \u0026Vec\u003c(String, String)\u003e,\n) -\u003e Result\u003c(), ProtocolError\u003e {\n    let length = vec.len() as u16;\n    let length_bytes = length.to_be_bytes();\n    let _ = stream\n        .write_all(\u0026length_bytes)\n        .map_err(|_e| ProtocolError::WriteError);\n    for item in vec {\n        let _ = write_string_tuple(stream, item).map_err(|_e| ProtocolError::WriteError);\n    }\n    Ok(())\n}\n\npub fn write_bin_vec(stream: \u0026mut dyn Write, vec: \u0026Vec\u003cu8\u003e) -\u003e Result\u003c(), ProtocolError\u003e {\n    let length = vec.len() as u16;\n    let length_bytes = length.to_be_bytes();\n    let _ = stream\n        .write_all(\u0026length_bytes)\n        .map_err(|_e| ProtocolError::WriteError);\n    for byte in vec {\n        let _ = stream\n            .write_all(\u0026[*byte])\n            .map_err(|_e| ProtocolError::WriteError);\n    }\n    Ok(())\n}\n\npub fn write_string_tuple(\n    stream: \u0026mut dyn Write,\n    value: \u0026(String, String),\n) -\u003e Result\u003c(), ProtocolError\u003e {\n    let _ = write_string(stream, \u0026value.0).map_err(|_e| ProtocolError::WriteError);\n    let _ = write_string(stream, \u0026value.1).map_err(|_| ProtocolError::WriteError);\n    Ok(())\n}\n\npub fn write_u8(stream: \u0026mut dyn Write, value: \u0026u8) -\u003e Result\u003c(), ProtocolError\u003e {\n    let _ = stream\n        .write_all(\u0026[*value])\n        .map_err(|_| ProtocolError::WriteError);\n    Ok(())\n}\n\npub fn write_u16(stream: \u0026mut dyn Write, value: \u0026u16) -\u003e Result\u003c(), ProtocolError\u003e {\n    let value_bytes = value.to_be_bytes();\n    let _ = stream\n        .write_all(\u0026value_bytes)\n        .map_err(|_| ProtocolError::WriteError);\n    Ok(())\n}\n\npub fn write_u32(stream: \u0026mut dyn Write, value: \u0026u32) -\u003e Result\u003c(), ProtocolError\u003e {\n    let value_bytes = value.to_be_bytes();\n    let _ = stream\n        .write_all(\u0026value_bytes)\n        .map_err(|_e| ProtocolError::WriteError);\n    Ok(())\n}\n\npub fn write_bool(stream: \u0026mut dyn Write, value: \u0026bool) -\u003e Result\u003c(), ProtocolError\u003e {\n    let value_bytes = if *value { 1u8 } else { 0u8 };\n    let _ = stream\n        .write_all(\u0026[value_bytes])\n        .map_err(|_e| ProtocolError::WriteError);\n    Ok(())\n}\n\npub fn write_string_pairs(\n    stream: \u0026mut dyn Write,\n    vec: \u0026Vec\u003c(String, String)\u003e,\n) -\u003e Result\u003c(), ProtocolError\u003e {\n    let length = vec.len() as u16;\n    let length_bytes = length.to_be_bytes();\n    let _ = stream\n        .write_all(\u0026length_bytes)\n        .map_err(|_e| ProtocolError::WriteError);\n    for pair in vec {\n        let _ = write_string(stream, \u0026pair.0).map_err(|_| ProtocolError::WriteError);\n        let _ = write_string(stream, \u0026pair.1).map_err(|_e| ProtocolError::WriteError);\n    }\n    Ok(())\n}\n\n#[cfg(test)]\n\nmod tests {\n    use super::*;\n    use std::io::{Cursor, Read};\n\n    #[test]\n    fn test_write_string() {\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        write_string(\u0026mut cursor, \"Hola\").unwrap();\n        cursor.set_position(0);\n        let mut buf = [0u8; 2];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(u16::from_be_bytes(buf), 4);\n        let mut buf = [0u8; 4];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(String::from_utf8(buf.to_vec()).unwrap(), \"Hola\");\n    }\n\n    #[test]\n    fn test_write_tuple_vec() {\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        let vec = vec![(\"Hola\".to_string(), \"Chau\".to_string())];\n        write_tuple_vec(\u0026mut cursor, \u0026vec).unwrap();\n        cursor.set_position(0);\n        let mut buf = [0u8; 2];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(u16::from_be_bytes(buf), 1);\n        let mut buf = [0u8; 2];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(u16::from_be_bytes(buf), 4);\n        let mut buf = [0u8; 4];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(String::from_utf8(buf.to_vec()).unwrap(), \"Hola\");\n        let mut buf = [0u8; 2];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(u16::from_be_bytes(buf), 4);\n        let mut buf = [0u8; 4];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(String::from_utf8(buf.to_vec()).unwrap(), \"Chau\");\n    }\n\n    #[test]\n    fn test_write_bin_vec() {\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        let vec = vec![1, 2, 3, 4];\n        write_bin_vec(\u0026mut cursor, \u0026vec).unwrap();\n        cursor.set_position(0);\n        let mut buf = [0u8; 2];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(u16::from_be_bytes(buf), 4);\n        let mut buf = [0u8; 4];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(buf.to_vec(), vec![1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn test_write_string_tuple() {\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        write_string_tuple(\u0026mut cursor, \u0026(\"Hola\".to_string(), \"Chau\".to_string())).unwrap();\n        cursor.set_position(0);\n        let mut buf = [0u8; 2];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(u16::from_be_bytes(buf), 4);\n        let mut buf = [0u8; 4];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(String::from_utf8(buf.to_vec()).unwrap(), \"Hola\");\n        let mut buf = [0u8; 2];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(u16::from_be_bytes(buf), 4);\n        let mut buf = [0u8; 4];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(String::from_utf8(buf.to_vec()).unwrap(), \"Chau\");\n    }\n\n    #[test]\n    fn test_write_u8() {\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        write_u8(\u0026mut cursor, \u00261).unwrap();\n        cursor.set_position(0);\n        let mut buf = [0u8; 1];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(buf[0], 1);\n    }\n\n    #[test]\n    fn test_write_u16() {\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        write_u16(\u0026mut cursor, \u00261).unwrap();\n        cursor.set_position(0);\n        let mut buf = [0u8; 2];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(u16::from_be_bytes(buf), 1);\n    }\n\n    #[test]\n    fn test_write_u32() {\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        write_u32(\u0026mut cursor, \u00261).unwrap();\n        cursor.set_position(0);\n        let mut buf = [0u8; 4];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(u32::from_be_bytes(buf), 1);\n    }\n\n    #[test]\n    fn test_write_bool() {\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        write_bool(\u0026mut cursor, \u0026true).unwrap();\n        cursor.set_position(0);\n        let mut buf = [0u8; 1];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(buf[0], 1);\n    }\n\n    #[test]\n    fn test_write_string_pairs() {\n        let mut cursor = Cursor::new(Vec::\u003cu8\u003e::new());\n        let vec = vec![(\"Hola\".to_string(), \"Chau\".to_string())];\n        write_string_pairs(\u0026mut cursor, \u0026vec).unwrap();\n        cursor.set_position(0);\n        let mut buf = [0u8; 2];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(u16::from_be_bytes(buf), 1);\n        let mut buf = [0u8; 2];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(u16::from_be_bytes(buf), 4);\n        let mut buf = [0u8; 4];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(String::from_utf8(buf.to_vec()).unwrap(), \"Hola\");\n        let mut buf = [0u8; 2];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(u16::from_be_bytes(buf), 4);\n        let mut buf = [0u8; 4];\n        cursor.read_exact(\u0026mut buf).unwrap();\n        assert_eq!(String::from_utf8(buf.to_vec()).unwrap(), \"Chau\");\n    }\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":1012},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":1012},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":1012},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":1012},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":1012},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2024},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":1012},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":1012},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":2024},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1012},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":97},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":97},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":97},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":97},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":97},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":194},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":298},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":134},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":97},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":150},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":150},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":150},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":150},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":150},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":300},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3600},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1150},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1150},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2300},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":150},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":136},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":136},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":964},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":964},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":964},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1928},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":964},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":467},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":467},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":467},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":467},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":934},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":467},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":296},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":296},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":296},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":296},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":592},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":296},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":350},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1050},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":30},"fn_name":null}],"covered":63,"coverable":64},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","tests","broker_tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use rustic_city_eye::monitoring::incident::Incident;\n    use rustic_city_eye::mqtt::broker::Broker;\n    use rustic_city_eye::mqtt::client_message::{self, Connect};\n    use rustic_city_eye::mqtt::connect::connect_properties::ConnectProperties;\n    use rustic_city_eye::mqtt::connect::last_will::LastWill;\n    use rustic_city_eye::mqtt::connect::will_properties::WillProperties;\n    use rustic_city_eye::mqtt::publish::publish_properties::{PublishProperties, TopicProperties};\n    use rustic_city_eye::mqtt::subscribe_properties::SubscribeProperties;\n    use rustic_city_eye::mqtt::subscription::Subscription;\n    use rustic_city_eye::mqtt::topic::Topic;\n    use rustic_city_eye::mqtt::{\n        client_message::ClientMessage, protocol_error::ProtocolError,\n        protocol_return::ProtocolReturn,\n    };\n    use rustic_city_eye::utils::incident_payload;\n    use rustic_city_eye::utils::{location::Location, payload_types::PayloadTypes};\n\n    use std::collections::HashMap;\n    use std::io::Write;\n    use std::net::{TcpListener, TcpStream};\n    use std::sync::{mpsc, Arc, RwLock};\n    use std::thread;\n\n    #[test]\n    fn test_mensaje_invalido_da_error() {\n        // Set up a listener on a local port.\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n\n            stream.write_all(\"Hola\".as_bytes()).unwrap();\n        });\n\n        let topics = HashMap::new();\n        let packets = Arc::new(RwLock::new(HashMap::new()));\n        let clients_ids = Arc::new(RwLock::new(HashMap::new()));\n        let clients_auth_info = HashMap::new();\n\n        let mut result: Result\u003cProtocolReturn, ProtocolError\u003e =\n            Err(ProtocolError::UnspecifiedError);\n        let (id_sender, _) = mpsc::channel();\n\n        let broker = Broker::new(vec![\"127.0.0.1\".to_string(), \"5000\".to_string()]).unwrap();\n        if let Ok((stream, _)) = listener.accept() {\n            result = broker.handle_messages(\n                stream,\n                topics,\n                packets,\n                clients_ids,\n                clients_auth_info,\n                id_sender,\n            );\n        }\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_connect() -\u003e Result\u003c(), ProtocolError\u003e {\n        // Set up a listener on a local port.\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        let connect_config =\n            client_message::Connect::read_connect_config(\"./src/monitoring/connect_config.json\")\n                .unwrap();\n\n        let connect = ClientMessage::Connect(connect_config.clone());\n\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            connect.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let topics = HashMap::new();\n        let packets = Arc::new(RwLock::new(HashMap::new()));\n        let clients_ids = Arc::new(RwLock::new(HashMap::new()));\n        let clients_auth_info = HashMap::new();\n        let mut result: Result\u003cProtocolReturn, ProtocolError\u003e =\n            Err(ProtocolError::UnspecifiedError);\n        let (id_sender, reciever) = mpsc::channel();\n\n        thread::spawn(move || loop {\n            if reciever.try_recv().is_ok() {\n                break;\n            }\n        });\n        let broker = Broker::new(vec![\"127.0.0.1\".to_string(), \"5000\".to_string()]).unwrap();\n        if let Ok((stream, _)) = listener.accept() {\n            result = match broker.handle_messages(\n                stream,\n                topics,\n                packets,\n                clients_ids,\n                clients_auth_info,\n                id_sender,\n            ) {\n                Ok(r) =\u003e Ok(r),\n                Err(e) =\u003e return Err(e),\n            };\n        }\n\n        assert_eq!(result, Ok(ProtocolReturn::ConnackSent));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_envio_connect_con_id_repetido_y_desconecta() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        let connect_config =\n            client_message::Connect::read_connect_config(\"./src/monitoring/connect_config.json\")\n                .unwrap();\n\n        let connect = ClientMessage::Connect(connect_config.clone());\n\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            connect.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let topics = HashMap::new();\n        let packets = Arc::new(RwLock::new(HashMap::new()));\n        #[allow(clippy::type_complexity)]\n        let clients_ids: Arc\u003cRwLock\u003cHashMap\u003c_, (Option\u003cTcpStream\u003e, Option\u003cLastWill\u003e)\u003e\u003e\u003e =\n            Arc::new(RwLock::new(HashMap::new()));\n        //add an id to the clients_ids\n        clients_ids\n            .write()\n            .unwrap()\n            .insert(\"monitoring_app\".to_string(), (None, None));\n        let clients_auth_info = HashMap::new();\n        let broker = Broker::new(vec![\"127.0.0.1\".to_string(), \"5000\".to_string()]).unwrap();\n\n        let mut result: Result\u003cProtocolReturn, ProtocolError\u003e =\n            Err(ProtocolError::UnspecifiedError);\n        let (id_sender, _) = mpsc::channel();\n        if let Ok((stream, _)) = listener.accept() {\n            result = broker.handle_messages(\n                stream,\n                topics,\n                packets,\n                clients_ids,\n                clients_auth_info,\n                id_sender.clone(),\n            );\n        }\n\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), ProtocolReturn::ConnackSent);\n\n        // obtengo la lista de clientes\n        let clients_ids = broker.get_clients_ids();\n        assert!(clients_ids.contains(\u0026\"monitoring_app\".to_string()));\n\n        // vuelvo a enviar el connect con el mismo id\n        let connect_propierties = ConnectProperties {\n            session_expiry_interval: 1,\n            receive_maximum: 2,\n            maximum_packet_size: 10,\n            topic_alias_maximum: 99,\n            request_response_information: true,\n            request_problem_information: false,\n            user_properties: vec![\n                (\"Hola\".to_string(), \"Mundo\".to_string()),\n                (\"Chau\".to_string(), \"Mundo\".to_string()),\n            ],\n            authentication_method: \"test\".to_string(),\n            authentication_data: vec![1_u8, 2_u8, 3_u8, 4_u8, 5_u8],\n        };\n        let will_properties = WillProperties::new(\n            120,\n            1,\n            30,\n            \"plain\".to_string(),\n            \"topic\".to_string(),\n            vec![1, 2, 3, 4, 5],\n            vec![(\"propiedad\".to_string(), \"valor\".to_string())],\n        );\n\n        let connect = Connect::new(\n            true,\n            true,\n            1,\n            true,\n            35,\n            connect_propierties,\n            \"monitoring_app\".to_string(),\n            will_properties,\n            \"topic\".to_string(),\n            \"chauchis\".to_string(),\n            \"prueba\".to_string(),\n            \"\".to_string(),\n        );\n\n        let connect = ClientMessage::Connect(connect);\n\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            connect.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let topics = HashMap::new();\n        let packets = Arc::new(RwLock::new(HashMap::new()));\n        let clients_ids = Arc::new(RwLock::new(HashMap::new()));\n        let clients_auth_info = HashMap::new();\n\n        let mut result: Result\u003cProtocolReturn, ProtocolError\u003e =\n            Err(ProtocolError::UnspecifiedError);\n        if let Ok((stream_clone, _)) = listener.accept() {\n            result = broker.handle_messages(\n                stream_clone,\n                topics,\n                packets,\n                clients_ids,\n                clients_auth_info,\n                id_sender,\n            );\n        }\n\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), ProtocolReturn::DisconnectSent);\n\n        //assert_eq!(result.unwrap(), ProtocolReturn::DisconnectSent);\n    }\n\n    #[test]\n    fn test_subscribe() {\n        // Set up a listener on a local port.\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        let properties =\n            SubscribeProperties::new(1, vec![(\"propiedad\".to_string(), \"valor\".to_string())]);\n\n        let subscription =\n            Subscription::new(\"mensajes para juan\".to_string(), \"kvtr33\".to_string(), 1);\n\n        let payload = vec![subscription];\n\n        let sub = ClientMessage::Subscribe {\n            packet_id: 1,\n            properties,\n            payload,\n        };\n\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            sub.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let topics = HashMap::new();\n        let packets = Arc::new(RwLock::new(HashMap::new()));\n        let clients_ids = Arc::new(RwLock::new(HashMap::new()));\n        let clients_auth_info = HashMap::new();\n\n        let mut result: Result\u003cProtocolReturn, ProtocolError\u003e =\n            Err(ProtocolError::UnspecifiedError);\n        let broker = Broker::new(vec![\"127.0.0.1\".to_string(), \"5000\".to_string()]).unwrap();\n\n        let (id_sender, _) = mpsc::channel();\n        if let Ok((stream, _)) = listener.accept() {\n            result = broker.handle_messages(\n                stream,\n                topics,\n                packets,\n                clients_ids,\n                clients_auth_info,\n                id_sender,\n            );\n        }\n\n        assert_eq!(result.unwrap(), ProtocolReturn::SubackSent);\n    }\n    #[test]\n    fn test_publish() {\n        // Set up a listener on a local port.\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n        let topic_properties = TopicProperties {\n            topic_alias: 10,\n            response_topic: \"String\".to_string(),\n        };\n\n        let properties = PublishProperties::new(\n            1,\n            10,\n            topic_properties,\n            [1, 2, 3].to_vec(),\n            \"a\".to_string(),\n            1,\n            \"a\".to_string(),\n        );\n        let location = Location::new(1.1, 1.12);\n        let new = Incident::new(location);\n        let incident_payload = incident_payload::IncidentPayload::new(new);\n        let publish = ClientMessage::Publish {\n            packet_id: 1,\n            topic_name: \"mensajes para juan\".to_string(),\n            qos: 1,\n            retain_flag: 1,\n            payload: PayloadTypes::IncidentLocation(incident_payload),\n            dup_flag: 0,\n            properties,\n        };\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            publish.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let topics = HashMap::new();\n        let packets = Arc::new(RwLock::new(HashMap::new()));\n        let clients_ids = Arc::new(RwLock::new(HashMap::new()));\n        let clients_auth_info = HashMap::new();\n\n        let mut result: Result\u003cProtocolReturn, ProtocolError\u003e =\n            Err(ProtocolError::UnspecifiedError);\n\n        let (id_sender, _) = mpsc::channel();\n        let broker = Broker::new(vec![\"127.0.0.1\".to_string(), \"5000\".to_string()]).unwrap();\n        if let Ok((stream, _)) = listener.accept() {\n            result = broker.handle_messages(\n                stream,\n                topics,\n                packets,\n                clients_ids,\n                clients_auth_info,\n                id_sender,\n            );\n        }\n\n        assert_eq!(result.unwrap(), ProtocolReturn::PubackSent);\n    }\n\n    #[test]\n    fn test_publish_qos0() {\n        // Set up a listener on a local port.\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n        let topic_properties = TopicProperties {\n            topic_alias: 10,\n            response_topic: \"String\".to_string(),\n        };\n\n        let properties = PublishProperties::new(\n            1,\n            10,\n            topic_properties,\n            [1, 2, 3].to_vec(),\n            \"a\".to_string(),\n            1,\n            \"a\".to_string(),\n        );\n        let location = Location::new(1.1, 1.12);\n        let new = Incident::new(location);\n        let incident_payload = incident_payload::IncidentPayload::new(new);\n        let publish = ClientMessage::Publish {\n            packet_id: 1,\n            topic_name: \"mensajes para juan\".to_string(),\n            qos: 0,\n            retain_flag: 1,\n            payload: PayloadTypes::IncidentLocation(incident_payload),\n            dup_flag: 0,\n            properties,\n        };\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            publish.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let topics = HashMap::new();\n        let packets = Arc::new(RwLock::new(HashMap::new()));\n        let clients_ids = Arc::new(RwLock::new(HashMap::new()));\n        let clients_auth_info = HashMap::new();\n\n        let mut result: Result\u003cProtocolReturn, ProtocolError\u003e =\n            Err(ProtocolError::UnspecifiedError);\n\n        let (id_sender, _) = mpsc::channel();\n        let broker = Broker::new(vec![\"127.0.0.1\".to_string(), \"5000\".to_string()]).unwrap();\n\n        if let Ok((stream, _)) = listener.accept() {\n            result = broker.handle_messages(\n                stream,\n                topics,\n                packets,\n                clients_ids,\n                clients_auth_info,\n                id_sender,\n            );\n        }\n\n        assert_eq!(result.unwrap(), ProtocolReturn::NoAckSent);\n    }\n\n    #[test]\n    fn test_unsubcribe() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        let properties =\n            SubscribeProperties::new(1, vec![(\"propiedad\".to_string(), \"valor\".to_string())]);\n\n        let subscription =\n            Subscription::new(\"mensajes para juan\".to_string(), \"kvtr33\".to_string(), 1);\n\n        let payload = vec![subscription];\n\n        let sub = ClientMessage::Unsubscribe {\n            packet_id: 1,\n            properties,\n            payload,\n        };\n\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            sub.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let mut topics = HashMap::new();\n        let packets = Arc::new(RwLock::new(HashMap::new()));\n\n        let t = Topic::new();\n        topics.insert(\"mensajes para juan\".to_string(), t);\n        let broker = Broker::new(vec![\"127.0.0.1\".to_string(), \"5000\".to_string()]).unwrap();\n\n        let clients_ids = Arc::new(RwLock::new(HashMap::new()));\n        let clients_auth_info = HashMap::new();\n\n        let mut result: Result\u003cProtocolReturn, ProtocolError\u003e =\n            Err(ProtocolError::UnspecifiedError);\n\n        let (id_sender, _) = mpsc::channel();\n\n        if let Ok((stream, _)) = listener.accept() {\n            result = broker.handle_messages(\n                stream,\n                topics,\n                packets,\n                clients_ids,\n                clients_auth_info,\n                id_sender,\n            );\n        }\n\n        assert_eq!(result.unwrap(), ProtocolReturn::UnsubackSent);\n    }\n\n    #[test]\n    fn test_disconnect() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n        let disconnect = ClientMessage::Disconnect {\n            reason_code: 1,\n            session_expiry_interval: 1,\n            reason_string: \"pasaron_cosas\".to_string(),\n            client_id: \"kvtr33\".to_string(),\n        };\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            disconnect.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let topics = HashMap::new();\n        let packets = Arc::new(RwLock::new(HashMap::new()));\n        let clients_ids = Arc::new(RwLock::new(HashMap::new()));\n        let clients_auth_info = HashMap::new();\n\n        let mut result: Result\u003cProtocolReturn, ProtocolError\u003e =\n            Err(ProtocolError::UnspecifiedError);\n\n        let (id_sender, _) = mpsc::channel();\n        let broker = Broker::new(vec![\"127.0.0.1\".to_string(), \"5000\".to_string()]).unwrap();\n        if let Ok((stream, _)) = listener.accept() {\n            result = broker.handle_messages(\n                stream,\n                topics,\n                packets,\n                clients_ids,\n                clients_auth_info,\n                id_sender,\n            );\n        }\n\n        assert_eq!(result.unwrap(), ProtocolReturn::DisconnectRecieved);\n    }\n\n    #[test]\n    fn test_pingreq() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr: std::net::SocketAddr = listener.local_addr().unwrap();\n\n        let pingreq = ClientMessage::Pingreq;\n\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            pingreq.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let topics = HashMap::new();\n        let packets = Arc::new(RwLock::new(HashMap::new()));\n        let clients_ids = Arc::new(RwLock::new(HashMap::new()));\n        let clients_auth_info = HashMap::new();\n\n        let mut result: Result\u003cProtocolReturn, ProtocolError\u003e =\n            Err(ProtocolError::UnspecifiedError);\n\n        let (id_sender, _) = mpsc::channel();\n        let broker = Broker::new(vec![\"127.0.0.1\".to_string(), \"5000\".to_string()]).unwrap();\n        if let Ok((stream, _)) = listener.accept() {\n            result = broker.handle_messages(\n                stream,\n                topics,\n                packets,\n                clients_ids,\n                clients_auth_info,\n                id_sender,\n            );\n        }\n\n        assert_eq!(result.unwrap(), ProtocolReturn::PingrespSent);\n    }\n\n    // #[test]\n    // fn test_auth() {\n    //     let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n    //     let addr = listener.local_addr().unwrap();\n\n    //     let auth = ClientMessage::Auth {\n    //         reason_code: 0,\n    //         authentication_method: \"password-based\".to_string(),\n    //         authentication_data: vec![],\n    //         reason_string: \"buendia\".to_string(),\n    //         user_properties: vec![(\"hola\".to_string(), \"mundo\".to_string())],\n    //     };\n\n    //     thread::spawn(move || {\n    //         let mut stream = TcpStream::connect(addr).unwrap();\n    //         let mut buffer = vec![];\n    //         auth.write_to(\u0026mut buffer).unwrap();\n    //         stream.write_all(\u0026buffer).unwrap();\n    //     });\n\n    //     let topics = HashMap::new();\n    //     let packets = Arc::new(RwLock::new(HashMap::new()));\n    //     let clients_ids = Arc::new(RwLock::new(HashMap::new()));\n    //     let clients_auth_info = HashMap::new();\n\n    //     let mut result: Result\u003cProtocolReturn, ProtocolError\u003e =\n    //         Err(ProtocolError::UnspecifiedError);\n\n    //     let (id_sender, _) = mpsc::channel();\n    //     let broker = Broker::new(vec![\"127.0.0.1\".to_string(), \"5000\".to_string()]).unwrap();\n    //     if let Ok((stream, _)) = listener.accept() {\n    //         result = broker.handle_messages(\n    //             stream,\n    //             topics,\n    //             packets,\n    //             clients_ids,\n    //             clients_auth_info,\n    //             id_sender,\n    //         );\n    //     }\n\n    //     assert_eq!(result.unwrap(), ProtocolReturn::AuthRecieved);\n    // }\n\n    #[test]\n    fn test_auth_method_not_supported() -\u003e Result\u003c(), ProtocolError\u003e {\n        // Set up a listener on a local port.\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        let connect_config = client_message::Connect::read_connect_config(\n            \"./tests/connect_config_test/config_with_invalid_auth_method.json\",\n        )\n        .unwrap();\n\n        let connect = ClientMessage::Connect(connect_config.clone());\n\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            connect.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let topics = HashMap::new();\n        let packets = Arc::new(RwLock::new(HashMap::new()));\n        let clients_ids = Arc::new(RwLock::new(HashMap::new()));\n        let clients_auth_info = HashMap::new();\n\n        let mut result: Result\u003cProtocolReturn, ProtocolError\u003e =\n            Err(ProtocolError::UnspecifiedError);\n\n        let (id_sender, _) = mpsc::channel();\n        let broker = Broker::new(vec![\"127.0.0.1\".to_string(), \"5000\".to_string()]).unwrap();\n        if let Ok((stream, _)) = listener.accept() {\n            result = broker.handle_messages(\n                stream,\n                topics,\n                packets,\n                clients_ids,\n                clients_auth_info,\n                id_sender,\n            );\n        }\n\n        assert_eq!(result.unwrap(), ProtocolReturn::ConnackSent);\n\n        Ok(())\n    }\n\n    #[test]\n    fn connect_disconnect_connect() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        let connect_propierties = ConnectProperties {\n            session_expiry_interval: 1,\n            receive_maximum: 2,\n            maximum_packet_size: 10,\n            topic_alias_maximum: 99,\n            request_response_information: true,\n            request_problem_information: false,\n            user_properties: vec![\n                (\"Hola\".to_string(), \"Mundo\".to_string()),\n                (\"Chau\".to_string(), \"Mundo\".to_string()),\n            ],\n            authentication_method: \"test\".to_string(),\n            authentication_data: vec![1_u8, 2_u8, 3_u8, 4_u8, 5_u8],\n        };\n\n        let will_properties = WillProperties::new(\n            120,\n            1,\n            30,\n            \"plain\".to_string(),\n            \"topic\".to_string(),\n            vec![1, 2, 3, 4, 5],\n            vec![(\"propiedad\".to_string(), \"valor\".to_string())],\n        );\n\n        let connect = Connect::new(\n            true,\n            true,\n            1,\n            true,\n            35,\n            connect_propierties,\n            \"kvtr33\".to_string(),\n            will_properties,\n            \"topic\".to_string(),\n            \"chauchis\".to_string(),\n            \"prueba\".to_string(),\n            \"\".to_string(),\n        );\n\n        let connect = ClientMessage::Connect(connect);\n\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            connect.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let mut result: Result\u003cProtocolReturn, ProtocolError\u003e =\n            Err(ProtocolError::UnspecifiedError);\n        let broker = Broker::new(vec![\"127.0.0.1\".to_string(), \"5000\".to_string()]).unwrap();\n\n        let topics = HashMap::new();\n        let packets = Arc::new(RwLock::new(HashMap::new()));\n        let clients_ids = Arc::new(RwLock::new(HashMap::new()));\n        let clients_auth_info = HashMap::new();\n\n        let (id_sender, _) = mpsc::channel();\n        if let Ok((stream, _)) = listener.accept() {\n            result = broker.handle_messages(\n                stream,\n                topics.clone(),\n                packets.clone(),\n                clients_ids,\n                clients_auth_info,\n                id_sender,\n            );\n        }\n\n        assert_eq!(result.unwrap(), ProtocolReturn::ConnackSent);\n\n        // desconecto\n\n        let disconnect = ClientMessage::Disconnect {\n            reason_code: 1,\n            session_expiry_interval: 1,\n            reason_string: \"desconecto_normal\".to_string(),\n            client_id: \"kvtr33\".to_string(),\n        };\n\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            disconnect.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let (id_sender, _) = mpsc::channel();\n        let topics = HashMap::new();\n        let packets = Arc::new(RwLock::new(HashMap::new()));\n        let clients_ids = Arc::new(RwLock::new(HashMap::new()));\n        let clients_auth_info = HashMap::new();\n\n        let mut result: Result\u003cProtocolReturn, ProtocolError\u003e =\n            Err(ProtocolError::UnspecifiedError);\n        if let Ok((stream, _)) = listener.accept() {\n            result = broker.handle_messages(\n                stream,\n                topics.clone(),\n                packets.clone(),\n                clients_ids,\n                clients_auth_info,\n                id_sender,\n            );\n        }\n\n        assert_eq!(result.unwrap(), ProtocolReturn::DisconnectRecieved);\n\n        // verifico la lista de desconectados\n        let offline_clients = broker.get_offline_clients();\n        assert!(offline_clients.contains_key(\"kvtr33\"));\n\n        // verificio que no este en la lista de conectados\n        let online_clients = broker.get_clients_ids();\n        assert!(!online_clients.contains(\u0026\"kvtr33\".to_string()));\n\n        // vuelvo a conectar\n        let connect_propierties = ConnectProperties {\n            session_expiry_interval: 1,\n            receive_maximum: 2,\n            maximum_packet_size: 10,\n            topic_alias_maximum: 99,\n            request_response_information: true,\n            request_problem_information: false,\n            user_properties: vec![\n                (\"Hola\".to_string(), \"Mundo\".to_string()),\n                (\"Chau\".to_string(), \"Mundo\".to_string()),\n            ],\n            authentication_method: \"test\".to_string(),\n            authentication_data: vec![1_u8, 2_u8, 3_u8, 4_u8, 5_u8],\n        };\n\n        let will_properties = WillProperties::new(\n            120,\n            1,\n            30,\n            \"plain\".to_string(),\n            \"topic\".to_string(),\n            vec![1, 2, 3, 4, 5],\n            vec![(\"propiedad\".to_string(), \"valor\".to_string())],\n        );\n\n        let connect = Connect::new(\n            true,\n            true,\n            1,\n            true,\n            35,\n            connect_propierties,\n            \"kvtr33\".to_string(),\n            will_properties,\n            \"topic\".to_string(),\n            \"chauchis\".to_string(),\n            \"prueba\".to_string(),\n            \"\".to_string(),\n        );\n\n        let connect = ClientMessage::Connect(connect);\n\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            connect.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let topics = HashMap::new();\n        let packets = Arc::new(RwLock::new(HashMap::new()));\n        let clients_ids = Arc::new(RwLock::new(HashMap::new()));\n        let clients_auth_info = HashMap::new();\n        let (id_sender, _) = mpsc::channel();\n\n        let mut result: Result\u003cProtocolReturn, ProtocolError\u003e =\n            Err(ProtocolError::UnspecifiedError);\n\n        if let Ok((stream, _)) = listener.accept() {\n            result = broker.handle_messages(\n                stream,\n                topics.clone(),\n                packets.clone(),\n                clients_ids,\n                clients_auth_info,\n                id_sender,\n            );\n        }\n\n        assert_eq!(result.unwrap(), ProtocolReturn::ConnackSent);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","tests","client_test.rs"],"content":"#[cfg(test)]\nmod tests {\n    use rustic_city_eye::{\n        monitoring::incident::Incident,\n        mqtt::{\n            broker::Broker,\n            broker_message::BrokerMessage,\n            client::handle_message,\n            client_return::ClientReturn,\n            connack_properties::ConnackProperties,\n            protocol_error::ProtocolError,\n            publish::publish_properties::{PublishProperties, TopicProperties},\n        },\n        surveilling::camera_system::CameraSystem,\n        utils::{\n            incident_payload::IncidentPayload, location::Location, payload_types::PayloadTypes,\n        },\n    };\n    use std::{\n        io::Write,\n        net::{TcpListener, TcpStream},\n        sync::{mpsc::channel, Arc, Condvar, Mutex},\n        thread,\n    };\n\n    #[test]\n    fn test_recibir_connack() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        let properties = ConnackProperties {\n            session_expiry_interval: 0,\n            receive_maximum: 0,\n            maximum_packet_size: 0,\n            topic_alias_maximum: 0,\n            user_properties: vec![],\n            authentication_method: \"password-based\".to_string(),\n            authentication_data: vec![],\n            assigned_client_identifier: \"none\".to_string(),\n            maximum_qos: true,\n            reason_string: \"buendia\".to_string(),\n            wildcard_subscription_available: false,\n            subscription_identifier_available: false,\n            shared_subscription_available: false,\n            server_keep_alive: 0,\n            response_information: \"none\".to_string(),\n            server_reference: \"none\".to_string(),\n            retain_available: false,\n        };\n\n        let connack = BrokerMessage::Connack {\n            session_present: true,\n            reason_code: 0x00_u8,\n            properties,\n        };\n\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            connack.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let mut result: Result\u003cClientReturn, ProtocolError\u003e = Err(ProtocolError::UnspecifiedError);\n\n        let pending_messages: Vec\u003cu16\u003e = Vec::new();\n        let (sender, _) = channel();\n        let (tx, _) = channel();\n        if let Ok((stream, _)) = listener.accept() {\n            result = handle_message(stream, pending_messages, sender, tx)\n        }\n\n        assert_eq!(result.unwrap(), ClientReturn::ConnackReceived);\n    }\n\n    #[test]\n    fn test_recibir_puback() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        let puback = BrokerMessage::Puback {\n            packet_id_msb: 1,\n            packet_id_lsb: 5,\n            reason_code: 1,\n        };\n\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            puback.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let mut result: Result\u003cClientReturn, ProtocolError\u003e = Err(ProtocolError::UnspecifiedError);\n\n        let pending_messages: Vec\u003cu16\u003e = Vec::new();\n        let (sender, recibidor) = channel();\n        let (tx, _) = channel();\n\n        thread::spawn(move || loop {\n            if let Ok(recibido) = recibidor.try_recv() {\n                if recibido {\n                    break;\n                }\n            }\n        });\n        if let Ok((stream, _)) = listener.accept() {\n            result = handle_message(stream, pending_messages, sender, tx)\n        }\n\n        assert_eq!(result.unwrap(), ClientReturn::PubackRecieved);\n    }\n\n    #[test]\n    fn test_recibir_disconnect() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        let disconnect = BrokerMessage::Disconnect {\n            reason_code: 1,\n            session_expiry_interval: 1,\n            reason_string: \"pasaron_cosas\".to_string(),\n            user_properties: vec![(\"propiedad\".to_string(), \"valor\".to_string())],\n        };\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            disconnect.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n        let mut result: Result\u003cClientReturn, ProtocolError\u003e = Err(ProtocolError::UnspecifiedError);\n\n        let pending_messages: Vec\u003cu16\u003e = Vec::new();\n        let (sender, _) = channel();\n        let (tx, _) = channel();\n        if let Ok((stream, _)) = listener.accept() {\n            result = handle_message(stream, pending_messages, sender, tx);\n        }\n\n        assert_eq!(result.unwrap(), ClientReturn::DisconnectRecieved);\n    }\n\n    #[test]\n    fn test_recibir_suback() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        let suback = BrokerMessage::Suback {\n            packet_id_msb: 3,\n            packet_id_lsb: 1,\n            reason_code: 3,\n        };\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            suback.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let mut result: Result\u003cClientReturn, ProtocolError\u003e = Err(ProtocolError::UnspecifiedError);\n\n        let pending_messages: Vec\u003cu16\u003e = Vec::new();\n        let (sender, _) = channel();\n        let (tx, _) = channel();\n        if let Ok((stream, _)) = listener.accept() {\n            result = handle_message(stream, pending_messages, sender, tx)\n        }\n        assert_eq!(result.unwrap(), ClientReturn::SubackRecieved);\n    }\n\n    #[test]\n    fn test_recibir_publish_delivery() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        let topic = TopicProperties {\n            topic_alias: 1,\n            response_topic: \"topic\".to_string(),\n        };\n\n        let publish_propreties = PublishProperties {\n            payload_format_indicator: 1,\n            message_expiry_interval: 2,\n            topic_properties: topic,\n            correlation_data: vec![1, 2, 3],\n            user_property: \"propiedad\".to_string(),\n            subscription_identifier: 3,\n            content_type: \"content\".to_string(),\n        };\n        let location = Location::new(1.1, 1.12);\n        let new = Incident::new(location);\n        let incident_payload = IncidentPayload::new(new);\n        let pub_delivery = BrokerMessage::PublishDelivery {\n            packet_id: 1,\n            topic_name: \"topic\".to_string(),\n            qos: 1,\n            retain_flag: 2,\n            payload: PayloadTypes::IncidentLocation(incident_payload),\n            dup_flag: 4,\n            properties: publish_propreties,\n        };\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            pub_delivery.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let mut result: Result\u003cClientReturn, ProtocolError\u003e = Err(ProtocolError::UnspecifiedError);\n\n        let pending_messages: Vec\u003cu16\u003e = Vec::new();\n        //agregar id 1 a pending messages\n        //pending_messages.push(1);\n        let (sender, _) = channel();\n\n        let (tx, _rx) = channel();\n        if let Ok((stream, _)) = listener.accept() {\n            result = handle_message(stream, pending_messages.clone(), sender, tx)\n        }\n\n        assert_eq!(result.unwrap(), ClientReturn::PublishDeliveryRecieved);\n        //assert_eq!(pending_messages.len(), 0);\n    }\n\n    #[test]\n    fn test_recibir_unsuback() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        let unsuback = BrokerMessage::Unsuback {\n            packet_id_msb: 1,\n            packet_id_lsb: 1,\n            reason_code: 1,\n        };\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            unsuback.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let mut result: Result\u003cClientReturn, ProtocolError\u003e = Err(ProtocolError::UnspecifiedError);\n\n        let pending_messages: Vec\u003cu16\u003e = Vec::new();\n        let (sender, _) = channel();\n        let (tx, _) = channel();\n        if let Ok((stream, _)) = listener.accept() {\n            result = handle_message(stream, pending_messages, sender, tx)\n        }\n\n        assert_eq!(result.unwrap(), ClientReturn::UnsubackRecieved);\n    }\n\n    #[test]\n    fn test_recibir_pingresp() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        let pingresp = BrokerMessage::Pingresp;\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            pingresp.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let mut result: Result\u003cClientReturn, ProtocolError\u003e = Err(ProtocolError::UnspecifiedError);\n\n        let pending_messages: Vec\u003cu16\u003e = Vec::new();\n        let (sender, _) = channel();\n        let (tx, _) = channel();\n        if let Ok((stream, _)) = listener.accept() {\n            result = handle_message(stream, pending_messages, sender, tx)\n        }\n\n        assert_eq!(result.unwrap(), ClientReturn::PingrespRecieved);\n    }\n\n    #[test]\n    fn test_recibir_auth() {\n        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n        let addr = listener.local_addr().unwrap();\n\n        let auth = BrokerMessage::Auth {\n            reason_code: 0x00_u8,\n            authentication_method: \"password-based\".to_string(),\n            authentication_data: vec![0x00_u8, 0x01_u8],\n            reason_string: \"success\".to_string(),\n            user_properties: vec![(\"juan\".to_string(), \"hola\".to_string())],\n        };\n\n        thread::spawn(move || {\n            let mut stream = TcpStream::connect(addr).unwrap();\n            let mut buffer = vec![];\n            auth.write_to(\u0026mut buffer).unwrap();\n            stream.write_all(\u0026buffer).unwrap();\n        });\n\n        let mut result: Result\u003cClientReturn, ProtocolError\u003e = Err(ProtocolError::UnspecifiedError);\n\n        let pending_messages: Vec\u003cu16\u003e = Vec::new();\n        let (sender, _) = channel();\n        let (tx, _) = channel();\n        if let Ok((stream, _)) = listener.accept() {\n            result = handle_message(stream, pending_messages, sender, tx)\n        }\n\n        assert_eq!(result.unwrap(), ClientReturn::AuthRecieved);\n    }\n\n    #[test]\n    fn test_creo_cliente_y_envio_sub_por_channel() {\n        let args = vec![\"127.0.0.1\".to_string(), \"5097\".to_string()];\n        let mut broker = match Broker::new(args) {\n            Ok(broker) =\u003e broker,\n            Err(e) =\u003e panic!(\"Error creating broker: {:?}\", e),\n        };\n\n        let server_ready = Arc::new((Mutex::new(false), Condvar::new()));\n        let server_ready_clone = server_ready.clone();\n        thread::spawn(move || {\n            {\n                let (lock, cvar) = \u0026*server_ready_clone;\n                let mut ready = lock.lock().unwrap();\n                *ready = true;\n                cvar.notify_all();\n            }\n            let _ = broker.server_run();\n        });\n\n        // Wait for the server to start\n        {\n            let (lock, cvar) = \u0026*server_ready;\n            let mut ready = lock.lock().unwrap();\n            while !*ready {\n                ready = cvar.wait(ready).unwrap();\n            }\n        }\n\n        let _handle = thread::spawn(move || {\n            let mut _camera_system = CameraSystem::with_real_client(\"127.0.0.1::5097\".to_string());\n        });\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","tests","target","debug","build","glutin_egl_sys-dcb90fcb4d26e00a","out","egl_bindings.rs"],"content":"\n        mod __gl_imports {\n            pub use std::mem;\n            pub use std::marker::Send;\n            pub use std::os::raw;\n        }\n    \n\n        pub mod types {\n            #![allow(non_camel_case_types, non_snake_case, dead_code, missing_copy_implementations)]\n    \n// platform-specific aliases are unknown\n// IMPORTANT: these are alises to the same level of the bindings\n// the values must be defined by the user\n#[allow(dead_code)]\npub type khronos_utime_nanoseconds_t = super::khronos_utime_nanoseconds_t;\n#[allow(dead_code)]\npub type khronos_uint64_t = super::khronos_uint64_t;\n#[allow(dead_code)]\npub type khronos_ssize_t = super::khronos_ssize_t;\npub type EGLNativeDisplayType = super::EGLNativeDisplayType;\n#[allow(dead_code)]\npub type EGLNativePixmapType = super::EGLNativePixmapType;\n#[allow(dead_code)]\npub type EGLNativeWindowType = super::EGLNativeWindowType;\npub type EGLint = super::EGLint;\n#[allow(dead_code)]\npub type NativeDisplayType = super::NativeDisplayType;\n#[allow(dead_code)]\npub type NativePixmapType = super::NativePixmapType;\n#[allow(dead_code)]\npub type NativeWindowType = super::NativeWindowType;\n\n// EGL alises\npub type Bool = EGLBoolean; // TODO: not sure\npub type EGLBoolean = super::__gl_imports::raw::c_uint;\npub type EGLenum = super::__gl_imports::raw::c_uint;\npub type EGLAttribKHR = isize;\npub type EGLAttrib = isize;\npub type EGLConfig = *const super::__gl_imports::raw::c_void;\npub type EGLContext = *const super::__gl_imports::raw::c_void;\npub type EGLDeviceEXT = *const super::__gl_imports::raw::c_void;\npub type EGLDisplay = *const super::__gl_imports::raw::c_void;\npub type EGLSurface = *const super::__gl_imports::raw::c_void;\npub type EGLClientBuffer = *const super::__gl_imports::raw::c_void;\npub enum __eglMustCastToProperFunctionPointerType_fn {}\npub type __eglMustCastToProperFunctionPointerType =\n    *mut __eglMustCastToProperFunctionPointerType_fn;\npub type EGLImageKHR = *const super::__gl_imports::raw::c_void;\npub type EGLImage = *const super::__gl_imports::raw::c_void;\npub type EGLOutputLayerEXT = *const super::__gl_imports::raw::c_void;\npub type EGLOutputPortEXT = *const super::__gl_imports::raw::c_void;\npub type EGLSyncKHR = *const super::__gl_imports::raw::c_void;\npub type EGLSync = *const super::__gl_imports::raw::c_void;\npub type EGLTimeKHR = khronos_utime_nanoseconds_t;\npub type EGLTime = khronos_utime_nanoseconds_t;\npub type EGLSyncNV = *const super::__gl_imports::raw::c_void;\npub type EGLTimeNV = khronos_utime_nanoseconds_t;\npub type EGLuint64NV = khronos_utime_nanoseconds_t;\npub type EGLStreamKHR = *const super::__gl_imports::raw::c_void;\npub type EGLuint64KHR = khronos_uint64_t;\npub type EGLNativeFileDescriptorKHR = super::__gl_imports::raw::c_int;\npub type EGLsizeiANDROID = khronos_ssize_t;\npub type EGLSetBlobFuncANDROID = extern \"system\" fn(*const super::__gl_imports::raw::c_void,\n                                                    EGLsizeiANDROID,\n                                                    *const super::__gl_imports::raw::c_void,\n                                                    EGLsizeiANDROID)\n                                                    -\u003e ();\npub type EGLGetBlobFuncANDROID = extern \"system\" fn(*const super::__gl_imports::raw::c_void,\n                                                    EGLsizeiANDROID,\n                                                    *mut super::__gl_imports::raw::c_void,\n                                                    EGLsizeiANDROID)\n                                                    -\u003e EGLsizeiANDROID;\n\n#[repr(C)]\npub struct EGLClientPixmapHI {\n    pData: *const super::__gl_imports::raw::c_void,\n    iWidth: EGLint,\n    iHeight: EGLint,\n    iStride: EGLint,\n}\n\n}\n#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_FORMAT: types::EGLenum = 0x3088;\n#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_FORMAT_NONPRE: types::EGLenum = 0x308B;\n#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_FORMAT_PRE: types::EGLenum = 0x308C;\n#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_MASK_SIZE: types::EGLenum = 0x303E;\n#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_SIZE: types::EGLenum = 0x3021;\n#[allow(dead_code, non_upper_case_globals)] pub const BACK_BUFFER: types::EGLenum = 0x3084;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_ACCESS: types::EGLenum = 0x3002;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_ALLOC: types::EGLenum = 0x3003;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_ATTRIBUTE: types::EGLenum = 0x3004;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_CONFIG: types::EGLenum = 0x3005;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_CONTEXT: types::EGLenum = 0x3006;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_CURRENT_SURFACE: types::EGLenum = 0x3007;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_DEVICE_EXT: types::EGLenum = 0x322B;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_DISPLAY: types::EGLenum = 0x3008;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_MATCH: types::EGLenum = 0x3009;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_NATIVE_PIXMAP: types::EGLenum = 0x300A;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_NATIVE_WINDOW: types::EGLenum = 0x300B;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_PARAMETER: types::EGLenum = 0x300C;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_SURFACE: types::EGLenum = 0x300D;\n#[allow(dead_code, non_upper_case_globals)] pub const BIND_TO_TEXTURE_RGB: types::EGLenum = 0x3039;\n#[allow(dead_code, non_upper_case_globals)] pub const BIND_TO_TEXTURE_RGBA: types::EGLenum = 0x303A;\n#[allow(dead_code, non_upper_case_globals)] pub const BLUE_SIZE: types::EGLenum = 0x3022;\n#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_AGE_EXT: types::EGLenum = 0x313D;\n#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_DESTROYED: types::EGLenum = 0x3095;\n#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_PRESERVED: types::EGLenum = 0x3094;\n#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_SIZE: types::EGLenum = 0x3020;\n#[allow(dead_code, non_upper_case_globals)] pub const CLIENT_APIS: types::EGLenum = 0x308D;\n#[allow(dead_code, non_upper_case_globals)] pub const CL_EVENT_HANDLE: types::EGLenum = 0x309C;\n#[allow(dead_code, non_upper_case_globals)] pub const COLORSPACE: types::EGLenum = 0x3087;\n#[allow(dead_code, non_upper_case_globals)] pub const COLORSPACE_LINEAR: types::EGLenum = 0x308A;\n#[allow(dead_code, non_upper_case_globals)] pub const COLORSPACE_sRGB: types::EGLenum = 0x3089;\n#[allow(dead_code, non_upper_case_globals)] pub const COLOR_BUFFER_TYPE: types::EGLenum = 0x303F;\n#[allow(dead_code, non_upper_case_globals)] pub const COLOR_COMPONENT_TYPE_EXT: types::EGLenum = 0x3339;\n#[allow(dead_code, non_upper_case_globals)] pub const COLOR_COMPONENT_TYPE_FIXED_EXT: types::EGLenum = 0x333A;\n#[allow(dead_code, non_upper_case_globals)] pub const COLOR_COMPONENT_TYPE_FLOAT_EXT: types::EGLenum = 0x333B;\n#[allow(dead_code, non_upper_case_globals)] pub const CONDITION_SATISFIED: types::EGLenum = 0x30F6;\n#[allow(dead_code, non_upper_case_globals)] pub const CONFIG_CAVEAT: types::EGLenum = 0x3027;\n#[allow(dead_code, non_upper_case_globals)] pub const CONFIG_ID: types::EGLenum = 0x3028;\n#[allow(dead_code, non_upper_case_globals)] pub const CONFORMANT: types::EGLenum = 0x3042;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_CLIENT_TYPE: types::EGLenum = 0x3097;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_CLIENT_VERSION: types::EGLenum = 0x3098;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_FLAGS_KHR: types::EGLenum = 0x30FC;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_LOST: types::EGLenum = 0x300E;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MAJOR_VERSION: types::EGLenum = 0x3098;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MAJOR_VERSION_KHR: types::EGLenum = 0x3098;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MINOR_VERSION: types::EGLenum = 0x30FB;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MINOR_VERSION_KHR: types::EGLenum = 0x30FB;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT: types::EGLenum = 0x00000002;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR: types::EGLenum = 0x00000002;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_CORE_PROFILE_BIT: types::EGLenum = 0x00000001;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR: types::EGLenum = 0x00000001;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_DEBUG: types::EGLenum = 0x31B0;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_DEBUG_BIT_KHR: types::EGLenum = 0x00000001;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_FORWARD_COMPATIBLE: types::EGLenum = 0x31B1;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR: types::EGLenum = 0x00000002;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_NO_ERROR_KHR: types::EGLenum = 0x31B3;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_PROFILE_MASK: types::EGLenum = 0x30FD;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_PROFILE_MASK_KHR: types::EGLenum = 0x30FD;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY: types::EGLenum = 0x31BD;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT: types::EGLenum = 0x3138;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR: types::EGLenum = 0x31BD;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_ROBUST_ACCESS: types::EGLenum = 0x31B2;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR: types::EGLenum = 0x00000004;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_ROBUST_ACCESS_EXT: types::EGLenum = 0x30BF;\n#[allow(dead_code, non_upper_case_globals)] pub const CORE_NATIVE_ENGINE: types::EGLenum = 0x305B;\n#[allow(dead_code, non_upper_case_globals)] pub const DEFAULT_DISPLAY: types::EGLNativeDisplayType = 0 as types::EGLNativeDisplayType;\n#[allow(dead_code, non_upper_case_globals)] pub const DEPTH_SIZE: types::EGLenum = 0x3025;\n#[allow(dead_code, non_upper_case_globals)] pub const DEVICE_EXT: types::EGLenum = 0x322C;\n#[allow(dead_code, non_upper_case_globals)] pub const DISPLAY_SCALING: types::EGLenum = 10000;\n#[allow(dead_code, non_upper_case_globals)] pub const DONT_CARE: types::EGLint = -1 as types::EGLint;\n#[allow(dead_code, non_upper_case_globals)] pub const DRAW: types::EGLenum = 0x3059;\n#[allow(dead_code, non_upper_case_globals)] pub const DRM_DEVICE_FILE_EXT: types::EGLenum = 0x3233;\n#[allow(dead_code, non_upper_case_globals)] pub const DRM_MASTER_FD_EXT: types::EGLenum = 0x333C;\n#[allow(dead_code, non_upper_case_globals)] pub const EXTENSIONS: types::EGLenum = 0x3055;\n#[allow(dead_code, non_upper_case_globals)] pub const FALSE: types::EGLBoolean = 0;\n#[allow(dead_code, non_upper_case_globals)] pub const FOREVER: types::EGLuint64KHR = 0xFFFFFFFFFFFFFFFF;\n#[allow(dead_code, non_upper_case_globals)] pub const GL_COLORSPACE: types::EGLenum = 0x309D;\n#[allow(dead_code, non_upper_case_globals)] pub const GL_COLORSPACE_LINEAR: types::EGLenum = 0x308A;\n#[allow(dead_code, non_upper_case_globals)] pub const GL_COLORSPACE_SRGB: types::EGLenum = 0x3089;\n#[allow(dead_code, non_upper_case_globals)] pub const GL_RENDERBUFFER: types::EGLenum = 0x30B9;\n#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_2D: types::EGLenum = 0x30B1;\n#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_3D: types::EGLenum = 0x30B2;\n#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_X: types::EGLenum = 0x30B4;\n#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: types::EGLenum = 0x30B6;\n#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: types::EGLenum = 0x30B8;\n#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_POSITIVE_X: types::EGLenum = 0x30B3;\n#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Y: types::EGLenum = 0x30B5;\n#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Z: types::EGLenum = 0x30B7;\n#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_LEVEL: types::EGLenum = 0x30BC;\n#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_ZOFFSET: types::EGLenum = 0x30BD;\n#[allow(dead_code, non_upper_case_globals)] pub const GREEN_SIZE: types::EGLenum = 0x3023;\n#[allow(dead_code, non_upper_case_globals)] pub const HEIGHT: types::EGLenum = 0x3056;\n#[allow(dead_code, non_upper_case_globals)] pub const HORIZONTAL_RESOLUTION: types::EGLenum = 0x3090;\n#[allow(dead_code, non_upper_case_globals)] pub const IMAGE_PRESERVED: types::EGLenum = 0x30D2;\n#[allow(dead_code, non_upper_case_globals)] pub const LARGEST_PBUFFER: types::EGLenum = 0x3058;\n#[allow(dead_code, non_upper_case_globals)] pub const LEVEL: types::EGLenum = 0x3029;\n#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET: types::EGLenum = 0x31BF;\n#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET_EXT: types::EGLenum = 0x31BF;\n#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET_KHR: types::EGLenum = 0x31BF;\n#[allow(dead_code, non_upper_case_globals)] pub const LUMINANCE_BUFFER: types::EGLenum = 0x308F;\n#[allow(dead_code, non_upper_case_globals)] pub const LUMINANCE_SIZE: types::EGLenum = 0x303D;\n#[allow(dead_code, non_upper_case_globals)] pub const MATCH_NATIVE_PIXMAP: types::EGLenum = 0x3041;\n#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_HEIGHT: types::EGLenum = 0x302A;\n#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_PIXELS: types::EGLenum = 0x302B;\n#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_WIDTH: types::EGLenum = 0x302C;\n#[allow(dead_code, non_upper_case_globals)] pub const MAX_SWAP_INTERVAL: types::EGLenum = 0x303C;\n#[allow(dead_code, non_upper_case_globals)] pub const MIN_SWAP_INTERVAL: types::EGLenum = 0x303B;\n#[allow(dead_code, non_upper_case_globals)] pub const MIPMAP_LEVEL: types::EGLenum = 0x3083;\n#[allow(dead_code, non_upper_case_globals)] pub const MIPMAP_TEXTURE: types::EGLenum = 0x3082;\n#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE: types::EGLenum = 0x3099;\n#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE_BOX: types::EGLenum = 0x309B;\n#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE_BOX_BIT: types::EGLenum = 0x0200;\n#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE_DEFAULT: types::EGLenum = 0x309A;\n#[allow(dead_code, non_upper_case_globals)] pub const NATIVE_RENDERABLE: types::EGLenum = 0x302D;\n#[allow(dead_code, non_upper_case_globals)] pub const NATIVE_VISUAL_ID: types::EGLenum = 0x302E;\n#[allow(dead_code, non_upper_case_globals)] pub const NATIVE_VISUAL_TYPE: types::EGLenum = 0x302F;\n#[allow(dead_code, non_upper_case_globals)] pub const NONE: types::EGLenum = 0x3038;\n#[allow(dead_code, non_upper_case_globals)] pub const NON_CONFORMANT_CONFIG: types::EGLenum = 0x3051;\n#[allow(dead_code, non_upper_case_globals)] pub const NOT_INITIALIZED: types::EGLenum = 0x3001;\n#[allow(dead_code, non_upper_case_globals)] pub const NO_CONTEXT: types::EGLContext = 0 as types::EGLContext;\n#[allow(dead_code, non_upper_case_globals)] pub const NO_DEVICE_EXT: types::EGLDeviceEXT = 0 as types::EGLDeviceEXT;\n#[allow(dead_code, non_upper_case_globals)] pub const NO_DISPLAY: types::EGLDisplay = 0 as types::EGLDisplay;\n#[allow(dead_code, non_upper_case_globals)] pub const NO_IMAGE: types::EGLImage = 0 as types::EGLImage;\n#[allow(dead_code, non_upper_case_globals)] pub const NO_NATIVE_FENCE_FD_ANDROID: types::EGLint = -1;\n#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION: types::EGLenum = 0x31BE;\n#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION_EXT: types::EGLenum = 0x31BE;\n#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION_KHR: types::EGLenum = 0x31BE;\n#[allow(dead_code, non_upper_case_globals)] pub const NO_SURFACE: types::EGLSurface = 0 as types::EGLSurface;\n#[allow(dead_code, non_upper_case_globals)] pub const NO_SYNC: types::EGLSync = 0 as types::EGLSync;\n#[allow(dead_code, non_upper_case_globals)] pub const NO_TEXTURE: types::EGLenum = 0x305C;\n#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_API: types::EGLenum = 0x30A2;\n#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_BIT: types::EGLenum = 0x0008;\n#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES2_BIT: types::EGLenum = 0x0004;\n#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES3_BIT: types::EGLenum = 0x00000040;\n#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES3_BIT_KHR: types::EGLenum = 0x00000040;\n#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES_API: types::EGLenum = 0x30A0;\n#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES_BIT: types::EGLenum = 0x0001;\n#[allow(dead_code, non_upper_case_globals)] pub const OPENVG_API: types::EGLenum = 0x30A1;\n#[allow(dead_code, non_upper_case_globals)] pub const OPENVG_BIT: types::EGLenum = 0x0002;\n#[allow(dead_code, non_upper_case_globals)] pub const OPENVG_IMAGE: types::EGLenum = 0x3096;\n#[allow(dead_code, non_upper_case_globals)] pub const PBUFFER_BIT: types::EGLenum = 0x0001;\n#[allow(dead_code, non_upper_case_globals)] pub const PIXEL_ASPECT_RATIO: types::EGLenum = 0x3092;\n#[allow(dead_code, non_upper_case_globals)] pub const PIXMAP_BIT: types::EGLenum = 0x0002;\n#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_ANDROID_KHR: types::EGLenum = 0x3141;\n#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_DEVICE_EXT: types::EGLenum = 0x313F;\n#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_GBM_KHR: types::EGLenum = 0x31D7;\n#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_GBM_MESA: types::EGLenum = 0x31D7;\n#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_WAYLAND_EXT: types::EGLenum = 0x31D8;\n#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_WAYLAND_KHR: types::EGLenum = 0x31D8;\n#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_EXT: types::EGLenum = 0x31D5;\n#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_KHR: types::EGLenum = 0x31D5;\n#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_SCREEN_EXT: types::EGLenum = 0x31D6;\n#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_SCREEN_KHR: types::EGLenum = 0x31D6;\n#[allow(dead_code, non_upper_case_globals)] pub const READ: types::EGLenum = 0x305A;\n#[allow(dead_code, non_upper_case_globals)] pub const RED_SIZE: types::EGLenum = 0x3024;\n#[allow(dead_code, non_upper_case_globals)] pub const RENDERABLE_TYPE: types::EGLenum = 0x3040;\n#[allow(dead_code, non_upper_case_globals)] pub const RENDER_BUFFER: types::EGLenum = 0x3086;\n#[allow(dead_code, non_upper_case_globals)] pub const RGB_BUFFER: types::EGLenum = 0x308E;\n#[allow(dead_code, non_upper_case_globals)] pub const SAMPLES: types::EGLenum = 0x3031;\n#[allow(dead_code, non_upper_case_globals)] pub const SAMPLE_BUFFERS: types::EGLenum = 0x3032;\n#[allow(dead_code, non_upper_case_globals)] pub const SIGNALED: types::EGLenum = 0x30F2;\n#[allow(dead_code, non_upper_case_globals)] pub const SINGLE_BUFFER: types::EGLenum = 0x3085;\n#[allow(dead_code, non_upper_case_globals)] pub const SLOW_CONFIG: types::EGLenum = 0x3050;\n#[allow(dead_code, non_upper_case_globals)] pub const STENCIL_SIZE: types::EGLenum = 0x3026;\n#[allow(dead_code, non_upper_case_globals)] pub const SUCCESS: types::EGLenum = 0x3000;\n#[allow(dead_code, non_upper_case_globals)] pub const SURFACE_TYPE: types::EGLenum = 0x3033;\n#[allow(dead_code, non_upper_case_globals)] pub const SWAP_BEHAVIOR: types::EGLenum = 0x3093;\n#[allow(dead_code, non_upper_case_globals)] pub const SWAP_BEHAVIOR_PRESERVED_BIT: types::EGLenum = 0x0400;\n#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CL_EVENT: types::EGLenum = 0x30FE;\n#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CL_EVENT_COMPLETE: types::EGLenum = 0x30FF;\n#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CONDITION: types::EGLenum = 0x30F8;\n#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CONDITION_KHR: types::EGLenum = 0x30F8;\n#[allow(dead_code, non_upper_case_globals)] pub const SYNC_FENCE: types::EGLenum = 0x30F9;\n#[allow(dead_code, non_upper_case_globals)] pub const SYNC_FENCE_KHR: types::EGLenum = 0x30F9;\n#[allow(dead_code, non_upper_case_globals)] pub const SYNC_FLUSH_COMMANDS_BIT: types::EGLenum = 0x0001;\n#[allow(dead_code, non_upper_case_globals)] pub const SYNC_NATIVE_FENCE_ANDROID: types::EGLenum = 0x3144;\n#[allow(dead_code, non_upper_case_globals)] pub const SYNC_NATIVE_FENCE_FD_ANDROID: types::EGLenum = 0x3145;\n#[allow(dead_code, non_upper_case_globals)] pub const SYNC_NATIVE_FENCE_SIGNALED_ANDROID: types::EGLenum = 0x3146;\n#[allow(dead_code, non_upper_case_globals)] pub const SYNC_PRIOR_COMMANDS_COMPLETE: types::EGLenum = 0x30F0;\n#[allow(dead_code, non_upper_case_globals)] pub const SYNC_PRIOR_COMMANDS_COMPLETE_KHR: types::EGLenum = 0x30F0;\n#[allow(dead_code, non_upper_case_globals)] pub const SYNC_STATUS: types::EGLenum = 0x30F1;\n#[allow(dead_code, non_upper_case_globals)] pub const SYNC_TYPE: types::EGLenum = 0x30F7;\n#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_2D: types::EGLenum = 0x305F;\n#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_FORMAT: types::EGLenum = 0x3080;\n#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_RGB: types::EGLenum = 0x305D;\n#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_RGBA: types::EGLenum = 0x305E;\n#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_TARGET: types::EGLenum = 0x3081;\n#[allow(dead_code, non_upper_case_globals)] pub const TIMEOUT_EXPIRED: types::EGLenum = 0x30F5;\n#[allow(dead_code, non_upper_case_globals)] pub const TRACK_REFERENCES_KHR: types::EGLenum = 0x3352;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_BLUE_VALUE: types::EGLenum = 0x3035;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_GREEN_VALUE: types::EGLenum = 0x3036;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RED_VALUE: types::EGLenum = 0x3037;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RGB: types::EGLenum = 0x3052;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_TYPE: types::EGLenum = 0x3034;\n#[allow(dead_code, non_upper_case_globals)] pub const TRUE: types::EGLBoolean = 1;\n#[allow(dead_code, non_upper_case_globals)] pub const UNKNOWN: types::EGLint = -1 as types::EGLint;\n#[allow(dead_code, non_upper_case_globals)] pub const UNSIGNALED: types::EGLenum = 0x30F3;\n#[allow(dead_code, non_upper_case_globals)] pub const VENDOR: types::EGLenum = 0x3053;\n#[allow(dead_code, non_upper_case_globals)] pub const VERSION: types::EGLenum = 0x3054;\n#[allow(dead_code, non_upper_case_globals)] pub const VERTICAL_RESOLUTION: types::EGLenum = 0x3091;\n#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT: types::EGLenum = 0x3088;\n#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT_NONPRE: types::EGLenum = 0x308B;\n#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT_PRE: types::EGLenum = 0x308C;\n#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT_PRE_BIT: types::EGLenum = 0x0040;\n#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE: types::EGLenum = 0x3087;\n#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE_LINEAR: types::EGLenum = 0x308A;\n#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE_LINEAR_BIT: types::EGLenum = 0x0020;\n#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE_sRGB: types::EGLenum = 0x3089;\n#[allow(dead_code, non_upper_case_globals)] pub const WIDTH: types::EGLenum = 0x3057;\n#[allow(dead_code, non_upper_case_globals)] pub const WINDOW_BIT: types::EGLenum = 0x0004;\n\n        #[allow(dead_code, missing_copy_implementations)]\n        #[derive(Clone)]\n        pub struct FnPtr {\n            /// The function pointer that will be used when calling the function.\n            f: *const __gl_imports::raw::c_void,\n            /// True if the pointer points to a real function, false if points to a `panic!` fn.\n            is_loaded: bool,\n        }\n\n        impl FnPtr {\n            /// Creates a `FnPtr` from a load attempt.\n            fn new(ptr: *const __gl_imports::raw::c_void) -\u003e FnPtr {\n                if ptr.is_null() {\n                    FnPtr {\n                        f: missing_fn_panic as *const __gl_imports::raw::c_void,\n                        is_loaded: false\n                    }\n                } else {\n                    FnPtr { f: ptr, is_loaded: true }\n                }\n            }\n\n            /// Returns `true` if the function has been successfully loaded.\n            ///\n            /// If it returns `false`, calling the corresponding function will fail.\n            #[inline]\n            #[allow(dead_code)]\n            pub fn is_loaded(\u0026self) -\u003e bool {\n                self.is_loaded\n            }\n        }\n    \n#[inline(never)]\n        fn missing_fn_panic() -\u003e ! {\n            panic!(\"egl function was not loaded\")\n        }\n\n        #[allow(non_camel_case_types, non_snake_case, dead_code)]\n        #[derive(Clone)]\n        pub struct Egl {\npub BindAPI: FnPtr,\npub BindTexImage: FnPtr,\npub ChooseConfig: FnPtr,\n/// Fallbacks: ClientWaitSyncKHR\npub ClientWaitSync: FnPtr,\npub ClientWaitSyncKHR: FnPtr,\npub CopyBuffers: FnPtr,\npub CreateContext: FnPtr,\npub CreateImage: FnPtr,\npub CreatePbufferFromClientBuffer: FnPtr,\npub CreatePbufferSurface: FnPtr,\npub CreatePixmapSurface: FnPtr,\npub CreatePlatformPixmapSurface: FnPtr,\npub CreatePlatformPixmapSurfaceEXT: FnPtr,\npub CreatePlatformWindowSurface: FnPtr,\npub CreatePlatformWindowSurfaceEXT: FnPtr,\n/// Fallbacks: CreateSync64KHR\npub CreateSync: FnPtr,\npub CreateSyncKHR: FnPtr,\npub CreateWindowSurface: FnPtr,\npub DestroyContext: FnPtr,\n/// Fallbacks: DestroyImageKHR\npub DestroyImage: FnPtr,\npub DestroySurface: FnPtr,\n/// Fallbacks: DestroySyncKHR\npub DestroySync: FnPtr,\npub DestroySyncKHR: FnPtr,\npub DupNativeFenceFDANDROID: FnPtr,\npub GetConfigAttrib: FnPtr,\npub GetConfigs: FnPtr,\npub GetCurrentContext: FnPtr,\npub GetCurrentDisplay: FnPtr,\npub GetCurrentSurface: FnPtr,\npub GetDisplay: FnPtr,\npub GetError: FnPtr,\npub GetPlatformDisplay: FnPtr,\npub GetPlatformDisplayEXT: FnPtr,\npub GetProcAddress: FnPtr,\npub GetSyncAttrib: FnPtr,\npub GetSyncAttribKHR: FnPtr,\npub Initialize: FnPtr,\npub MakeCurrent: FnPtr,\npub QueryAPI: FnPtr,\npub QueryContext: FnPtr,\npub QueryDeviceAttribEXT: FnPtr,\npub QueryDeviceStringEXT: FnPtr,\npub QueryDevicesEXT: FnPtr,\npub QueryDisplayAttribEXT: FnPtr,\n/// Fallbacks: QueryDisplayAttribEXT, QueryDisplayAttribNV\npub QueryDisplayAttribKHR: FnPtr,\npub QueryString: FnPtr,\npub QuerySurface: FnPtr,\npub ReleaseTexImage: FnPtr,\npub ReleaseThread: FnPtr,\npub SurfaceAttrib: FnPtr,\npub SwapBuffers: FnPtr,\npub SwapBuffersWithDamageEXT: FnPtr,\npub SwapBuffersWithDamageKHR: FnPtr,\npub SwapInterval: FnPtr,\npub Terminate: FnPtr,\npub WaitClient: FnPtr,\npub WaitGL: FnPtr,\npub WaitNative: FnPtr,\npub WaitSync: FnPtr,\npub WaitSyncKHR: FnPtr,\n_priv: ()\n}\nimpl Egl {\n            /// Load each OpenGL symbol using a custom load function. This allows for the\n            /// use of functions like `glfwGetProcAddress` or `SDL_GL_GetProcAddress`.\n            ///\n            /// ~~~ignore\n            /// let gl = Gl::load_with(|s| glfw.get_proc_address(s));\n            /// ~~~\n            #[allow(dead_code, unused_variables)]\n            pub fn load_with\u003cF\u003e(mut loadfn: F) -\u003e Egl where F: FnMut(\u0026'static str) -\u003e *const __gl_imports::raw::c_void {\n                #[inline(never)]\n                fn do_metaloadfn(loadfn: \u0026mut dyn FnMut(\u0026'static str) -\u003e *const __gl_imports::raw::c_void,\n                                 symbol: \u0026'static str,\n                                 symbols: \u0026[\u0026'static str])\n                                 -\u003e *const __gl_imports::raw::c_void {\n                    let mut ptr = loadfn(symbol);\n                    if ptr.is_null() {\n                        for \u0026sym in symbols {\n                            ptr = loadfn(sym);\n                            if !ptr.is_null() { break; }\n                        }\n                    }\n                    ptr\n                }\n                let mut metaloadfn = |symbol: \u0026'static str, symbols: \u0026[\u0026'static str]| {\n                    do_metaloadfn(\u0026mut loadfn, symbol, symbols)\n                };\n                Egl {\nBindAPI: FnPtr::new(metaloadfn(\"eglBindAPI\", \u0026[])),\nBindTexImage: FnPtr::new(metaloadfn(\"eglBindTexImage\", \u0026[])),\nChooseConfig: FnPtr::new(metaloadfn(\"eglChooseConfig\", \u0026[])),\nClientWaitSync: FnPtr::new(metaloadfn(\"eglClientWaitSync\", \u0026[\"eglClientWaitSyncKHR\"])),\nClientWaitSyncKHR: FnPtr::new(metaloadfn(\"eglClientWaitSyncKHR\", \u0026[])),\nCopyBuffers: FnPtr::new(metaloadfn(\"eglCopyBuffers\", \u0026[])),\nCreateContext: FnPtr::new(metaloadfn(\"eglCreateContext\", \u0026[])),\nCreateImage: FnPtr::new(metaloadfn(\"eglCreateImage\", \u0026[])),\nCreatePbufferFromClientBuffer: FnPtr::new(metaloadfn(\"eglCreatePbufferFromClientBuffer\", \u0026[])),\nCreatePbufferSurface: FnPtr::new(metaloadfn(\"eglCreatePbufferSurface\", \u0026[])),\nCreatePixmapSurface: FnPtr::new(metaloadfn(\"eglCreatePixmapSurface\", \u0026[])),\nCreatePlatformPixmapSurface: FnPtr::new(metaloadfn(\"eglCreatePlatformPixmapSurface\", \u0026[])),\nCreatePlatformPixmapSurfaceEXT: FnPtr::new(metaloadfn(\"eglCreatePlatformPixmapSurfaceEXT\", \u0026[])),\nCreatePlatformWindowSurface: FnPtr::new(metaloadfn(\"eglCreatePlatformWindowSurface\", \u0026[])),\nCreatePlatformWindowSurfaceEXT: FnPtr::new(metaloadfn(\"eglCreatePlatformWindowSurfaceEXT\", \u0026[])),\nCreateSync: FnPtr::new(metaloadfn(\"eglCreateSync\", \u0026[\"eglCreateSync64KHR\"])),\nCreateSyncKHR: FnPtr::new(metaloadfn(\"eglCreateSyncKHR\", \u0026[])),\nCreateWindowSurface: FnPtr::new(metaloadfn(\"eglCreateWindowSurface\", \u0026[])),\nDestroyContext: FnPtr::new(metaloadfn(\"eglDestroyContext\", \u0026[])),\nDestroyImage: FnPtr::new(metaloadfn(\"eglDestroyImage\", \u0026[\"eglDestroyImageKHR\"])),\nDestroySurface: FnPtr::new(metaloadfn(\"eglDestroySurface\", \u0026[])),\nDestroySync: FnPtr::new(metaloadfn(\"eglDestroySync\", \u0026[\"eglDestroySyncKHR\"])),\nDestroySyncKHR: FnPtr::new(metaloadfn(\"eglDestroySyncKHR\", \u0026[])),\nDupNativeFenceFDANDROID: FnPtr::new(metaloadfn(\"eglDupNativeFenceFDANDROID\", \u0026[])),\nGetConfigAttrib: FnPtr::new(metaloadfn(\"eglGetConfigAttrib\", \u0026[])),\nGetConfigs: FnPtr::new(metaloadfn(\"eglGetConfigs\", \u0026[])),\nGetCurrentContext: FnPtr::new(metaloadfn(\"eglGetCurrentContext\", \u0026[])),\nGetCurrentDisplay: FnPtr::new(metaloadfn(\"eglGetCurrentDisplay\", \u0026[])),\nGetCurrentSurface: FnPtr::new(metaloadfn(\"eglGetCurrentSurface\", \u0026[])),\nGetDisplay: FnPtr::new(metaloadfn(\"eglGetDisplay\", \u0026[])),\nGetError: FnPtr::new(metaloadfn(\"eglGetError\", \u0026[])),\nGetPlatformDisplay: FnPtr::new(metaloadfn(\"eglGetPlatformDisplay\", \u0026[])),\nGetPlatformDisplayEXT: FnPtr::new(metaloadfn(\"eglGetPlatformDisplayEXT\", \u0026[])),\nGetProcAddress: FnPtr::new(metaloadfn(\"eglGetProcAddress\", \u0026[])),\nGetSyncAttrib: FnPtr::new(metaloadfn(\"eglGetSyncAttrib\", \u0026[])),\nGetSyncAttribKHR: FnPtr::new(metaloadfn(\"eglGetSyncAttribKHR\", \u0026[])),\nInitialize: FnPtr::new(metaloadfn(\"eglInitialize\", \u0026[])),\nMakeCurrent: FnPtr::new(metaloadfn(\"eglMakeCurrent\", \u0026[])),\nQueryAPI: FnPtr::new(metaloadfn(\"eglQueryAPI\", \u0026[])),\nQueryContext: FnPtr::new(metaloadfn(\"eglQueryContext\", \u0026[])),\nQueryDeviceAttribEXT: FnPtr::new(metaloadfn(\"eglQueryDeviceAttribEXT\", \u0026[])),\nQueryDeviceStringEXT: FnPtr::new(metaloadfn(\"eglQueryDeviceStringEXT\", \u0026[])),\nQueryDevicesEXT: FnPtr::new(metaloadfn(\"eglQueryDevicesEXT\", \u0026[])),\nQueryDisplayAttribEXT: FnPtr::new(metaloadfn(\"eglQueryDisplayAttribEXT\", \u0026[])),\nQueryDisplayAttribKHR: FnPtr::new(metaloadfn(\"eglQueryDisplayAttribKHR\", \u0026[\"eglQueryDisplayAttribEXT\", \"eglQueryDisplayAttribNV\"])),\nQueryString: FnPtr::new(metaloadfn(\"eglQueryString\", \u0026[])),\nQuerySurface: FnPtr::new(metaloadfn(\"eglQuerySurface\", \u0026[])),\nReleaseTexImage: FnPtr::new(metaloadfn(\"eglReleaseTexImage\", \u0026[])),\nReleaseThread: FnPtr::new(metaloadfn(\"eglReleaseThread\", \u0026[])),\nSurfaceAttrib: FnPtr::new(metaloadfn(\"eglSurfaceAttrib\", \u0026[])),\nSwapBuffers: FnPtr::new(metaloadfn(\"eglSwapBuffers\", \u0026[])),\nSwapBuffersWithDamageEXT: FnPtr::new(metaloadfn(\"eglSwapBuffersWithDamageEXT\", \u0026[])),\nSwapBuffersWithDamageKHR: FnPtr::new(metaloadfn(\"eglSwapBuffersWithDamageKHR\", \u0026[])),\nSwapInterval: FnPtr::new(metaloadfn(\"eglSwapInterval\", \u0026[])),\nTerminate: FnPtr::new(metaloadfn(\"eglTerminate\", \u0026[])),\nWaitClient: FnPtr::new(metaloadfn(\"eglWaitClient\", \u0026[])),\nWaitGL: FnPtr::new(metaloadfn(\"eglWaitGL\", \u0026[])),\nWaitNative: FnPtr::new(metaloadfn(\"eglWaitNative\", \u0026[])),\nWaitSync: FnPtr::new(metaloadfn(\"eglWaitSync\", \u0026[])),\nWaitSyncKHR: FnPtr::new(metaloadfn(\"eglWaitSyncKHR\", \u0026[])),\n_priv: ()\n}\n        }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn BindAPI(\u0026self, api: types::EGLenum) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLenum) -\u003e types::EGLBoolean\u003e(self.BindAPI.f)(api) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn BindTexImage(\u0026self, dpy: types::EGLDisplay, surface: types::EGLSurface, buffer: types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSurface, types::EGLint) -\u003e types::EGLBoolean\u003e(self.BindTexImage.f)(dpy, surface, buffer) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn ChooseConfig(\u0026self, dpy: types::EGLDisplay, attrib_list: *const types::EGLint, configs: *mut types::EGLConfig, config_size: types::EGLint, num_config: *mut types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, *const types::EGLint, *mut types::EGLConfig, types::EGLint, *mut types::EGLint) -\u003e types::EGLBoolean\u003e(self.ChooseConfig.f)(dpy, attrib_list, configs, config_size, num_config) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn ClientWaitSync(\u0026self, dpy: types::EGLDisplay, sync: types::EGLSync, flags: types::EGLint, timeout: types::EGLTime) -\u003e types::EGLint { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSync, types::EGLint, types::EGLTime) -\u003e types::EGLint\u003e(self.ClientWaitSync.f)(dpy, sync, flags, timeout) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn ClientWaitSyncKHR(\u0026self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR, flags: types::EGLint, timeout: types::EGLTimeKHR) -\u003e types::EGLint { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSyncKHR, types::EGLint, types::EGLTimeKHR) -\u003e types::EGLint\u003e(self.ClientWaitSyncKHR.f)(dpy, sync, flags, timeout) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CopyBuffers(\u0026self, dpy: types::EGLDisplay, surface: types::EGLSurface, target: types::EGLNativePixmapType) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSurface, types::EGLNativePixmapType) -\u003e types::EGLBoolean\u003e(self.CopyBuffers.f)(dpy, surface, target) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreateContext(\u0026self, dpy: types::EGLDisplay, config: types::EGLConfig, share_context: types::EGLContext, attrib_list: *const types::EGLint) -\u003e types::EGLContext { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLConfig, types::EGLContext, *const types::EGLint) -\u003e types::EGLContext\u003e(self.CreateContext.f)(dpy, config, share_context, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreateImage(\u0026self, dpy: types::EGLDisplay, ctx: types::EGLContext, target: types::EGLenum, buffer: types::EGLClientBuffer, attrib_list: *const types::EGLAttrib) -\u003e types::EGLImage { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLContext, types::EGLenum, types::EGLClientBuffer, *const types::EGLAttrib) -\u003e types::EGLImage\u003e(self.CreateImage.f)(dpy, ctx, target, buffer, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreatePbufferFromClientBuffer(\u0026self, dpy: types::EGLDisplay, buftype: types::EGLenum, buffer: types::EGLClientBuffer, config: types::EGLConfig, attrib_list: *const types::EGLint) -\u003e types::EGLSurface { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLenum, types::EGLClientBuffer, types::EGLConfig, *const types::EGLint) -\u003e types::EGLSurface\u003e(self.CreatePbufferFromClientBuffer.f)(dpy, buftype, buffer, config, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreatePbufferSurface(\u0026self, dpy: types::EGLDisplay, config: types::EGLConfig, attrib_list: *const types::EGLint) -\u003e types::EGLSurface { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLConfig, *const types::EGLint) -\u003e types::EGLSurface\u003e(self.CreatePbufferSurface.f)(dpy, config, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreatePixmapSurface(\u0026self, dpy: types::EGLDisplay, config: types::EGLConfig, pixmap: types::EGLNativePixmapType, attrib_list: *const types::EGLint) -\u003e types::EGLSurface { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLConfig, types::EGLNativePixmapType, *const types::EGLint) -\u003e types::EGLSurface\u003e(self.CreatePixmapSurface.f)(dpy, config, pixmap, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreatePlatformPixmapSurface(\u0026self, dpy: types::EGLDisplay, config: types::EGLConfig, native_pixmap: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLAttrib) -\u003e types::EGLSurface { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLAttrib) -\u003e types::EGLSurface\u003e(self.CreatePlatformPixmapSurface.f)(dpy, config, native_pixmap, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreatePlatformPixmapSurfaceEXT(\u0026self, dpy: types::EGLDisplay, config: types::EGLConfig, native_pixmap: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLint) -\u003e types::EGLSurface { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLint) -\u003e types::EGLSurface\u003e(self.CreatePlatformPixmapSurfaceEXT.f)(dpy, config, native_pixmap, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreatePlatformWindowSurface(\u0026self, dpy: types::EGLDisplay, config: types::EGLConfig, native_window: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLAttrib) -\u003e types::EGLSurface { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLAttrib) -\u003e types::EGLSurface\u003e(self.CreatePlatformWindowSurface.f)(dpy, config, native_window, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreatePlatformWindowSurfaceEXT(\u0026self, dpy: types::EGLDisplay, config: types::EGLConfig, native_window: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLint) -\u003e types::EGLSurface { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLint) -\u003e types::EGLSurface\u003e(self.CreatePlatformWindowSurfaceEXT.f)(dpy, config, native_window, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreateSync(\u0026self, dpy: types::EGLDisplay, type_: types::EGLenum, attrib_list: *const types::EGLAttrib) -\u003e types::EGLSync { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLenum, *const types::EGLAttrib) -\u003e types::EGLSync\u003e(self.CreateSync.f)(dpy, type_, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreateSyncKHR(\u0026self, dpy: types::EGLDisplay, type_: types::EGLenum, attrib_list: *const types::EGLint) -\u003e types::EGLSyncKHR { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLenum, *const types::EGLint) -\u003e types::EGLSyncKHR\u003e(self.CreateSyncKHR.f)(dpy, type_, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreateWindowSurface(\u0026self, dpy: types::EGLDisplay, config: types::EGLConfig, win: types::EGLNativeWindowType, attrib_list: *const types::EGLint) -\u003e types::EGLSurface { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLConfig, types::EGLNativeWindowType, *const types::EGLint) -\u003e types::EGLSurface\u003e(self.CreateWindowSurface.f)(dpy, config, win, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DestroyContext(\u0026self, dpy: types::EGLDisplay, ctx: types::EGLContext) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLContext) -\u003e types::EGLBoolean\u003e(self.DestroyContext.f)(dpy, ctx) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DestroyImage(\u0026self, dpy: types::EGLDisplay, image: types::EGLImage) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLImage) -\u003e types::EGLBoolean\u003e(self.DestroyImage.f)(dpy, image) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DestroySurface(\u0026self, dpy: types::EGLDisplay, surface: types::EGLSurface) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSurface) -\u003e types::EGLBoolean\u003e(self.DestroySurface.f)(dpy, surface) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DestroySync(\u0026self, dpy: types::EGLDisplay, sync: types::EGLSync) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSync) -\u003e types::EGLBoolean\u003e(self.DestroySync.f)(dpy, sync) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DestroySyncKHR(\u0026self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSyncKHR) -\u003e types::EGLBoolean\u003e(self.DestroySyncKHR.f)(dpy, sync) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DupNativeFenceFDANDROID(\u0026self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR) -\u003e types::EGLint { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSyncKHR) -\u003e types::EGLint\u003e(self.DupNativeFenceFDANDROID.f)(dpy, sync) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetConfigAttrib(\u0026self, dpy: types::EGLDisplay, config: types::EGLConfig, attribute: types::EGLint, value: *mut types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLConfig, types::EGLint, *mut types::EGLint) -\u003e types::EGLBoolean\u003e(self.GetConfigAttrib.f)(dpy, config, attribute, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetConfigs(\u0026self, dpy: types::EGLDisplay, configs: *mut types::EGLConfig, config_size: types::EGLint, num_config: *mut types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, *mut types::EGLConfig, types::EGLint, *mut types::EGLint) -\u003e types::EGLBoolean\u003e(self.GetConfigs.f)(dpy, configs, config_size, num_config) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetCurrentContext(\u0026self, ) -\u003e types::EGLContext { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e types::EGLContext\u003e(self.GetCurrentContext.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetCurrentDisplay(\u0026self, ) -\u003e types::EGLDisplay { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e types::EGLDisplay\u003e(self.GetCurrentDisplay.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetCurrentSurface(\u0026self, readdraw: types::EGLint) -\u003e types::EGLSurface { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLint) -\u003e types::EGLSurface\u003e(self.GetCurrentSurface.f)(readdraw) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetDisplay(\u0026self, display_id: types::EGLNativeDisplayType) -\u003e types::EGLDisplay { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLNativeDisplayType) -\u003e types::EGLDisplay\u003e(self.GetDisplay.f)(display_id) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetError(\u0026self, ) -\u003e types::EGLint { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e types::EGLint\u003e(self.GetError.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetPlatformDisplay(\u0026self, platform: types::EGLenum, native_display: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLAttrib) -\u003e types::EGLDisplay { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLenum, *mut __gl_imports::raw::c_void, *const types::EGLAttrib) -\u003e types::EGLDisplay\u003e(self.GetPlatformDisplay.f)(platform, native_display, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetPlatformDisplayEXT(\u0026self, platform: types::EGLenum, native_display: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLint) -\u003e types::EGLDisplay { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLenum, *mut __gl_imports::raw::c_void, *const types::EGLint) -\u003e types::EGLDisplay\u003e(self.GetPlatformDisplayEXT.f)(platform, native_display, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetProcAddress(\u0026self, procname: *const __gl_imports::raw::c_char) -\u003e types::__eglMustCastToProperFunctionPointerType { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*const __gl_imports::raw::c_char) -\u003e types::__eglMustCastToProperFunctionPointerType\u003e(self.GetProcAddress.f)(procname) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetSyncAttrib(\u0026self, dpy: types::EGLDisplay, sync: types::EGLSync, attribute: types::EGLint, value: *mut types::EGLAttrib) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSync, types::EGLint, *mut types::EGLAttrib) -\u003e types::EGLBoolean\u003e(self.GetSyncAttrib.f)(dpy, sync, attribute, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetSyncAttribKHR(\u0026self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR, attribute: types::EGLint, value: *mut types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSyncKHR, types::EGLint, *mut types::EGLint) -\u003e types::EGLBoolean\u003e(self.GetSyncAttribKHR.f)(dpy, sync, attribute, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn Initialize(\u0026self, dpy: types::EGLDisplay, major: *mut types::EGLint, minor: *mut types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, *mut types::EGLint, *mut types::EGLint) -\u003e types::EGLBoolean\u003e(self.Initialize.f)(dpy, major, minor) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn MakeCurrent(\u0026self, dpy: types::EGLDisplay, draw: types::EGLSurface, read: types::EGLSurface, ctx: types::EGLContext) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSurface, types::EGLSurface, types::EGLContext) -\u003e types::EGLBoolean\u003e(self.MakeCurrent.f)(dpy, draw, read, ctx) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryAPI(\u0026self, ) -\u003e types::EGLenum { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e types::EGLenum\u003e(self.QueryAPI.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryContext(\u0026self, dpy: types::EGLDisplay, ctx: types::EGLContext, attribute: types::EGLint, value: *mut types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLContext, types::EGLint, *mut types::EGLint) -\u003e types::EGLBoolean\u003e(self.QueryContext.f)(dpy, ctx, attribute, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryDeviceAttribEXT(\u0026self, device: types::EGLDeviceEXT, attribute: types::EGLint, value: *mut types::EGLAttrib) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDeviceEXT, types::EGLint, *mut types::EGLAttrib) -\u003e types::EGLBoolean\u003e(self.QueryDeviceAttribEXT.f)(device, attribute, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryDeviceStringEXT(\u0026self, device: types::EGLDeviceEXT, name: types::EGLint) -\u003e *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDeviceEXT, types::EGLint) -\u003e *const __gl_imports::raw::c_char\u003e(self.QueryDeviceStringEXT.f)(device, name) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryDevicesEXT(\u0026self, max_devices: types::EGLint, devices: *mut types::EGLDeviceEXT, num_devices: *mut types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLint, *mut types::EGLDeviceEXT, *mut types::EGLint) -\u003e types::EGLBoolean\u003e(self.QueryDevicesEXT.f)(max_devices, devices, num_devices) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryDisplayAttribEXT(\u0026self, dpy: types::EGLDisplay, attribute: types::EGLint, value: *mut types::EGLAttrib) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLint, *mut types::EGLAttrib) -\u003e types::EGLBoolean\u003e(self.QueryDisplayAttribEXT.f)(dpy, attribute, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryDisplayAttribKHR(\u0026self, dpy: types::EGLDisplay, name: types::EGLint, value: *mut types::EGLAttrib) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLint, *mut types::EGLAttrib) -\u003e types::EGLBoolean\u003e(self.QueryDisplayAttribKHR.f)(dpy, name, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryString(\u0026self, dpy: types::EGLDisplay, name: types::EGLint) -\u003e *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLint) -\u003e *const __gl_imports::raw::c_char\u003e(self.QueryString.f)(dpy, name) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QuerySurface(\u0026self, dpy: types::EGLDisplay, surface: types::EGLSurface, attribute: types::EGLint, value: *mut types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSurface, types::EGLint, *mut types::EGLint) -\u003e types::EGLBoolean\u003e(self.QuerySurface.f)(dpy, surface, attribute, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn ReleaseTexImage(\u0026self, dpy: types::EGLDisplay, surface: types::EGLSurface, buffer: types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSurface, types::EGLint) -\u003e types::EGLBoolean\u003e(self.ReleaseTexImage.f)(dpy, surface, buffer) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn ReleaseThread(\u0026self, ) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e types::EGLBoolean\u003e(self.ReleaseThread.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn SurfaceAttrib(\u0026self, dpy: types::EGLDisplay, surface: types::EGLSurface, attribute: types::EGLint, value: types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSurface, types::EGLint, types::EGLint) -\u003e types::EGLBoolean\u003e(self.SurfaceAttrib.f)(dpy, surface, attribute, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn SwapBuffers(\u0026self, dpy: types::EGLDisplay, surface: types::EGLSurface) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSurface) -\u003e types::EGLBoolean\u003e(self.SwapBuffers.f)(dpy, surface) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn SwapBuffersWithDamageEXT(\u0026self, dpy: types::EGLDisplay, surface: types::EGLSurface, rects: *mut types::EGLint, n_rects: types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSurface, *mut types::EGLint, types::EGLint) -\u003e types::EGLBoolean\u003e(self.SwapBuffersWithDamageEXT.f)(dpy, surface, rects, n_rects) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn SwapBuffersWithDamageKHR(\u0026self, dpy: types::EGLDisplay, surface: types::EGLSurface, rects: *mut types::EGLint, n_rects: types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSurface, *mut types::EGLint, types::EGLint) -\u003e types::EGLBoolean\u003e(self.SwapBuffersWithDamageKHR.f)(dpy, surface, rects, n_rects) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn SwapInterval(\u0026self, dpy: types::EGLDisplay, interval: types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLint) -\u003e types::EGLBoolean\u003e(self.SwapInterval.f)(dpy, interval) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn Terminate(\u0026self, dpy: types::EGLDisplay) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay) -\u003e types::EGLBoolean\u003e(self.Terminate.f)(dpy) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn WaitClient(\u0026self, ) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e types::EGLBoolean\u003e(self.WaitClient.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn WaitGL(\u0026self, ) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e types::EGLBoolean\u003e(self.WaitGL.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn WaitNative(\u0026self, engine: types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLint) -\u003e types::EGLBoolean\u003e(self.WaitNative.f)(engine) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn WaitSync(\u0026self, dpy: types::EGLDisplay, sync: types::EGLSync, flags: types::EGLint) -\u003e types::EGLBoolean { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSync, types::EGLint) -\u003e types::EGLBoolean\u003e(self.WaitSync.f)(dpy, sync, flags) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn WaitSyncKHR(\u0026self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR, flags: types::EGLint) -\u003e types::EGLint { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::EGLDisplay, types::EGLSyncKHR, types::EGLint) -\u003e types::EGLint\u003e(self.WaitSyncKHR.f)(dpy, sync, flags) }\n}\n\n        unsafe impl __gl_imports::Send for Egl {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","tests","target","debug","build","glutin_glx_sys-50c3a38781448249","out","glx_bindings.rs"],"content":"\n        mod __gl_imports {\n            pub use std::mem;\n            pub use std::marker::Send;\n            pub use std::os::raw;\n        }\n    \n\n        pub mod types {\n            #![allow(non_camel_case_types, non_snake_case, dead_code, missing_copy_implementations)]\n    \n// Common types from OpenGL 1.1\npub type GLenum = super::__gl_imports::raw::c_uint;\npub type GLboolean = super::__gl_imports::raw::c_uchar;\npub type GLbitfield = super::__gl_imports::raw::c_uint;\npub type GLvoid = super::__gl_imports::raw::c_void;\npub type GLbyte = super::__gl_imports::raw::c_char;\npub type GLshort = super::__gl_imports::raw::c_short;\npub type GLint = super::__gl_imports::raw::c_int;\npub type GLclampx = super::__gl_imports::raw::c_int;\npub type GLubyte = super::__gl_imports::raw::c_uchar;\npub type GLushort = super::__gl_imports::raw::c_ushort;\npub type GLuint = super::__gl_imports::raw::c_uint;\npub type GLsizei = super::__gl_imports::raw::c_int;\npub type GLfloat = super::__gl_imports::raw::c_float;\npub type GLclampf = super::__gl_imports::raw::c_float;\npub type GLdouble = super::__gl_imports::raw::c_double;\npub type GLclampd = super::__gl_imports::raw::c_double;\npub type GLeglImageOES = *const super::__gl_imports::raw::c_void;\npub type GLchar = super::__gl_imports::raw::c_char;\npub type GLcharARB = super::__gl_imports::raw::c_char;\n\n#[cfg(target_os = \"macos\")]\npub type GLhandleARB = *const super::__gl_imports::raw::c_void;\n#[cfg(not(target_os = \"macos\"))]\npub type GLhandleARB = super::__gl_imports::raw::c_uint;\n\npub type GLhalfARB = super::__gl_imports::raw::c_ushort;\npub type GLhalf = super::__gl_imports::raw::c_ushort;\n\n// Must be 32 bits\npub type GLfixed = GLint;\n\npub type GLintptr = isize;\npub type GLsizeiptr = isize;\npub type GLint64 = i64;\npub type GLuint64 = u64;\npub type GLintptrARB = isize;\npub type GLsizeiptrARB = isize;\npub type GLint64EXT = i64;\npub type GLuint64EXT = u64;\n\npub enum __GLsync {}\npub type GLsync = *const __GLsync;\n\n// compatible with OpenCL cl_context\npub enum _cl_context {}\npub enum _cl_event {}\n\npub type GLDEBUGPROC = Option\u003cextern \"system\" fn(source: GLenum,\n                                                 gltype: GLenum,\n                                                 id: GLuint,\n                                                 severity: GLenum,\n                                                 length: GLsizei,\n                                                 message: *const GLchar,\n                                                 userParam: *mut super::__gl_imports::raw::c_void)\u003e;\npub type GLDEBUGPROCARB = Option\u003cextern \"system\" fn(source: GLenum,\n                                                    gltype: GLenum,\n                                                    id: GLuint,\n                                                    severity: GLenum,\n                                                    length: GLsizei,\n                                                    message: *const GLchar,\n                                                    userParam: *mut super::__gl_imports::raw::c_void)\u003e;\npub type GLDEBUGPROCKHR = Option\u003cextern \"system\" fn(source: GLenum,\n                                                    gltype: GLenum,\n                                                    id: GLuint,\n                                                    severity: GLenum,\n                                                    length: GLsizei,\n                                                    message: *const GLchar,\n                                                    userParam: *mut super::__gl_imports::raw::c_void)\u003e;\n\n// GLES 1 types\n// \"pub type GLclampx = i32;\",\n\n// GLES 1/2 types (tagged for GLES 1)\n// \"pub type GLbyte = i8;\",\n// \"pub type GLubyte = u8;\",\n// \"pub type GLfloat = GLfloat;\",\n// \"pub type GLclampf = GLfloat;\",\n// \"pub type GLfixed = i32;\",\n// \"pub type GLint64 = i64;\",\n// \"pub type GLuint64 = u64;\",\n// \"pub type GLintptr = intptr_t;\",\n// \"pub type GLsizeiptr = ssize_t;\",\n\n// GLES 1/2 types (tagged for GLES 2 - attribute syntax is limited)\n// \"pub type GLbyte = i8;\",\n// \"pub type GLubyte = u8;\",\n// \"pub type GLfloat = GLfloat;\",\n// \"pub type GLclampf = GLfloat;\",\n// \"pub type GLfixed = i32;\",\n// \"pub type GLint64 = i64;\",\n// \"pub type GLuint64 = u64;\",\n// \"pub type GLint64EXT = i64;\",\n// \"pub type GLuint64EXT = u64;\",\n// \"pub type GLintptr = intptr_t;\",\n// \"pub type GLsizeiptr = ssize_t;\",\n\n// GLES 2 types (none currently)\n\n// Vendor extension types\npub type GLDEBUGPROCAMD = Option\u003cextern \"system\" fn(id: GLuint,\n                                                    category: GLenum,\n                                                    severity: GLenum,\n                                                    length: GLsizei,\n                                                    message: *const GLchar,\n                                                    userParam: *mut super::__gl_imports::raw::c_void)\u003e;\npub type GLhalfNV = super::__gl_imports::raw::c_ushort;\npub type GLvdpauSurfaceNV = GLintptr;\n\npub type XID = super::__gl_imports::raw::c_ulong;\npub type Bool = super::__gl_imports::raw::c_int; // Not sure if this is correct...\npub enum Display {}\n\npub type Font = XID;\npub type Pixmap = XID;\npub enum Visual {} // TODO: not sure\npub type VisualID = super::__gl_imports::raw::c_ulong; // TODO: not sure\npub type Window = XID;\npub type GLXFBConfigID = XID;\npub type GLXFBConfig = *const super::__gl_imports::raw::c_void;\npub type GLXContextID = XID;\npub type GLXContext = *const super::__gl_imports::raw::c_void;\npub type GLXPixmap = XID;\npub type GLXDrawable = XID;\npub type GLXWindow = XID;\npub type GLXPbuffer = XID;\npub enum __GLXextFuncPtr_fn {}\npub type __GLXextFuncPtr = *mut __GLXextFuncPtr_fn;\npub type GLXVideoCaptureDeviceNV = XID;\npub type GLXVideoDeviceNV = super::__gl_imports::raw::c_int;\npub type GLXVideoSourceSGIX = XID;\npub type GLXFBConfigIDSGIX = XID;\npub type GLXFBConfigSGIX = *const super::__gl_imports::raw::c_void;\npub type GLXPbufferSGIX = XID;\n\n#[repr(C)]\npub struct XVisualInfo {\n    pub visual: *mut Visual,\n    pub visualid: VisualID,\n    pub screen: super::__gl_imports::raw::c_int,\n    pub depth: super::__gl_imports::raw::c_int,\n    pub class: super::__gl_imports::raw::c_int,\n    pub red_mask: super::__gl_imports::raw::c_ulong,\n    pub green_mask: super::__gl_imports::raw::c_ulong,\n    pub blue_mask: super::__gl_imports::raw::c_ulong,\n    pub colormap_size: super::__gl_imports::raw::c_int,\n    pub bits_per_rgb: super::__gl_imports::raw::c_int,\n}\n\n#[repr(C)]\npub struct GLXPbufferClobberEvent {\n    pub event_type: super::__gl_imports::raw::c_int, // GLX_DAMAGED or GLX_SAVED\n    pub draw_type: super::__gl_imports::raw::c_int, // GLX_WINDOW or GLX_PBUFFER\n    pub serial: super::__gl_imports::raw::c_ulong, // # of last request processed by server\n    pub send_event: Bool, // true if this came for SendEvent request\n    pub display: *const Display, // display the event was read from\n    pub drawable: GLXDrawable, // XID of Drawable\n    pub buffer_mask: super::__gl_imports::raw::c_uint, // mask indicating which buffers are affected\n    pub aux_buffer: super::__gl_imports::raw::c_uint, // which aux buffer was affected\n    pub x: super::__gl_imports::raw::c_int,\n    pub y: super::__gl_imports::raw::c_int,\n    pub width: super::__gl_imports::raw::c_int,\n    pub height: super::__gl_imports::raw::c_int,\n    pub count: super::__gl_imports::raw::c_int, // if nonzero, at least this many more\n}\n\n#[repr(C)]\npub struct GLXBufferSwapComplete {\n    pub type_: super::__gl_imports::raw::c_int,\n    pub serial: super::__gl_imports::raw::c_ulong, // # of last request processed by server\n    pub send_event: Bool, // true if this came from a SendEvent request\n    pub display: *const Display, // Display the event was read from\n    pub drawable: GLXDrawable, // drawable on which event was requested in event mask\n    pub event_type: super::__gl_imports::raw::c_int,\n    pub ust: i64,\n    pub msc: i64,\n    pub sbc: i64,\n}\n\n// typedef union __GLXEvent {\n//     GLXPbufferClobberEvent glxpbufferclobber;\n//     GLXBufferSwapComplete glxbufferswapcomplete;\n//     long pad[24];\n// }\n\n#[repr(C)]\npub struct GLXBufferClobberEventSGIX {\n    pub type_: super::__gl_imports::raw::c_int,\n    pub serial: super::__gl_imports::raw::c_ulong, // # of last request processed by server\n    pub send_event: Bool, // true if this came for SendEvent request\n    pub display: *const Display, // display the event was read from\n    pub drawable: GLXDrawable, // i.d. of Drawable\n    pub event_type: super::__gl_imports::raw::c_int, // GLX_DAMAGED_SGIX or GLX_SAVED_SGIX\n    pub draw_type: super::__gl_imports::raw::c_int, // GLX_WINDOW_SGIX or GLX_PBUFFER_SGIX\n    pub mask: super::__gl_imports::raw::c_uint, // mask indicating which buffers are affected\n    pub x: super::__gl_imports::raw::c_int,\n    pub y: super::__gl_imports::raw::c_int,\n    pub width: super::__gl_imports::raw::c_int,\n    pub height: super::__gl_imports::raw::c_int,\n    pub count: super::__gl_imports::raw::c_int, // if nonzero, at least this many more\n}\n\n#[repr(C)]\npub struct GLXHyperpipeNetworkSGIX {\n    pub pipeName: [super::__gl_imports::raw::c_char; 80], // Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX]\n    pub networkId: super::__gl_imports::raw::c_int,\n}\n\n#[repr(C)]\npub struct GLXHyperpipeConfigSGIX {\n    pub pipeName: [super::__gl_imports::raw::c_char; 80], // Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX]\n    pub channel: super::__gl_imports::raw::c_int,\n    pub participationType: super::__gl_imports::raw::c_uint,\n    pub timeSlice: super::__gl_imports::raw::c_int,\n}\n\n#[repr(C)]\npub struct GLXPipeRect {\n    pub pipeName: [super::__gl_imports::raw::c_char; 80], // Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX]\n    pub srcXOrigin: super::__gl_imports::raw::c_int,\n    pub srcYOrigin: super::__gl_imports::raw::c_int,\n    pub srcWidth: super::__gl_imports::raw::c_int,\n    pub srcHeight: super::__gl_imports::raw::c_int,\n    pub destXOrigin: super::__gl_imports::raw::c_int,\n    pub destYOrigin: super::__gl_imports::raw::c_int,\n    pub destWidth: super::__gl_imports::raw::c_int,\n    pub destHeight: super::__gl_imports::raw::c_int,\n}\n\n#[repr(C)]\npub struct GLXPipeRectLimits {\n    pub pipeName: [super::__gl_imports::raw::c_char; 80], // Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX]\n    pub XOrigin: super::__gl_imports::raw::c_int,\n    pub YOrigin: super::__gl_imports::raw::c_int,\n    pub maxHeight: super::__gl_imports::raw::c_int,\n    pub maxWidth: super::__gl_imports::raw::c_int,\n}\n\n}\n#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_ALPHA_SIZE: types::GLenum = 17;\n#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_BLUE_SIZE: types::GLenum = 16;\n#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_BUFFER_BIT: types::GLenum = 0x00000080;\n#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_GREEN_SIZE: types::GLenum = 15;\n#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_RED_SIZE: types::GLenum = 14;\n#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_SIZE: types::GLenum = 11;\n#[allow(dead_code, non_upper_case_globals)] pub const AUX_BUFFERS: types::GLenum = 7;\n#[allow(dead_code, non_upper_case_globals)] pub const AUX_BUFFERS_BIT: types::GLenum = 0x00000010;\n#[allow(dead_code, non_upper_case_globals)] pub const BACK_LEFT_BUFFER_BIT: types::GLenum = 0x00000004;\n#[allow(dead_code, non_upper_case_globals)] pub const BACK_RIGHT_BUFFER_BIT: types::GLenum = 0x00000008;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_ATTRIBUTE: types::GLenum = 2;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_CONTEXT: types::GLenum = 5;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_ENUM: types::GLenum = 7;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_SCREEN: types::GLenum = 1;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_VALUE: types::GLenum = 6;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_VISUAL: types::GLenum = 4;\n#[allow(dead_code, non_upper_case_globals)] pub const BLUE_SIZE: types::GLenum = 10;\n#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_SIZE: types::GLenum = 2;\n#[allow(dead_code, non_upper_case_globals)] pub const BufferSwapComplete: types::GLenum = 1;\n#[allow(dead_code, non_upper_case_globals)] pub const COLOR_INDEX_BIT: types::GLenum = 0x00000002;\n#[allow(dead_code, non_upper_case_globals)] pub const COLOR_INDEX_TYPE: types::GLenum = 0x8015;\n#[allow(dead_code, non_upper_case_globals)] pub const CONFIG_CAVEAT: types::GLenum = 0x20;\n#[allow(dead_code, non_upper_case_globals)] pub const DAMAGED: types::GLenum = 0x8020;\n#[allow(dead_code, non_upper_case_globals)] pub const DEPTH_BUFFER_BIT: types::GLenum = 0x00000020;\n#[allow(dead_code, non_upper_case_globals)] pub const DEPTH_SIZE: types::GLenum = 12;\n#[allow(dead_code, non_upper_case_globals)] pub const DIRECT_COLOR: types::GLenum = 0x8003;\n#[allow(dead_code, non_upper_case_globals)] pub const DONT_CARE: types::GLenum = 0xFFFFFFFF;\n#[allow(dead_code, non_upper_case_globals)] pub const DOUBLEBUFFER: types::GLenum = 5;\n#[allow(dead_code, non_upper_case_globals)] pub const DRAWABLE_TYPE: types::GLenum = 0x8010;\n#[allow(dead_code, non_upper_case_globals)] pub const EVENT_MASK: types::GLenum = 0x801F;\n#[allow(dead_code, non_upper_case_globals)] pub const EXTENSIONS: types::GLenum = 0x3;\n#[allow(dead_code, non_upper_case_globals)] pub const EXTENSION_NAME: \u0026'static str = \"GLX\";\n#[allow(dead_code, non_upper_case_globals)] pub const FBCONFIG_ID: types::GLenum = 0x8013;\n#[allow(dead_code, non_upper_case_globals)] pub const FRONT_LEFT_BUFFER_BIT: types::GLenum = 0x00000001;\n#[allow(dead_code, non_upper_case_globals)] pub const FRONT_RIGHT_BUFFER_BIT: types::GLenum = 0x00000002;\n#[allow(dead_code, non_upper_case_globals)] pub const GRAY_SCALE: types::GLenum = 0x8006;\n#[allow(dead_code, non_upper_case_globals)] pub const GREEN_SIZE: types::GLenum = 9;\n#[allow(dead_code, non_upper_case_globals)] pub const HEIGHT: types::GLenum = 0x801E;\n#[allow(dead_code, non_upper_case_globals)] pub const LARGEST_PBUFFER: types::GLenum = 0x801C;\n#[allow(dead_code, non_upper_case_globals)] pub const LEVEL: types::GLenum = 3;\n#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_HEIGHT: types::GLenum = 0x8017;\n#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_PIXELS: types::GLenum = 0x8018;\n#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_WIDTH: types::GLenum = 0x8016;\n#[allow(dead_code, non_upper_case_globals)] pub const NONE: types::GLenum = 0x8000;\n#[allow(dead_code, non_upper_case_globals)] pub const NON_CONFORMANT_CONFIG: types::GLenum = 0x800D;\n#[allow(dead_code, non_upper_case_globals)] pub const NO_EXTENSION: types::GLenum = 3;\n#[allow(dead_code, non_upper_case_globals)] pub const PBUFFER: types::GLenum = 0x8023;\n#[allow(dead_code, non_upper_case_globals)] pub const PBUFFER_BIT: types::GLenum = 0x00000004;\n#[allow(dead_code, non_upper_case_globals)] pub const PBUFFER_CLOBBER_MASK: types::GLenum = 0x08000000;\n#[allow(dead_code, non_upper_case_globals)] pub const PBUFFER_HEIGHT: types::GLenum = 0x8040;\n#[allow(dead_code, non_upper_case_globals)] pub const PBUFFER_WIDTH: types::GLenum = 0x8041;\n#[allow(dead_code, non_upper_case_globals)] pub const PIXMAP_BIT: types::GLenum = 0x00000002;\n#[allow(dead_code, non_upper_case_globals)] pub const PRESERVED_CONTENTS: types::GLenum = 0x801B;\n#[allow(dead_code, non_upper_case_globals)] pub const PSEUDO_COLOR: types::GLenum = 0x8004;\n#[allow(dead_code, non_upper_case_globals)] pub const PbufferClobber: types::GLenum = 0;\n#[allow(dead_code, non_upper_case_globals)] pub const RED_SIZE: types::GLenum = 8;\n#[allow(dead_code, non_upper_case_globals)] pub const RENDER_TYPE: types::GLenum = 0x8011;\n#[allow(dead_code, non_upper_case_globals)] pub const RGBA: types::GLenum = 4;\n#[allow(dead_code, non_upper_case_globals)] pub const RGBA_BIT: types::GLenum = 0x00000001;\n#[allow(dead_code, non_upper_case_globals)] pub const RGBA_TYPE: types::GLenum = 0x8014;\n#[allow(dead_code, non_upper_case_globals)] pub const SAMPLES: types::GLenum = 100001;\n#[allow(dead_code, non_upper_case_globals)] pub const SAMPLE_BUFFERS: types::GLenum = 100000;\n#[allow(dead_code, non_upper_case_globals)] pub const SAVED: types::GLenum = 0x8021;\n#[allow(dead_code, non_upper_case_globals)] pub const SCREEN: types::GLenum = 0x800C;\n#[allow(dead_code, non_upper_case_globals)] pub const SLOW_CONFIG: types::GLenum = 0x8001;\n#[allow(dead_code, non_upper_case_globals)] pub const STATIC_COLOR: types::GLenum = 0x8005;\n#[allow(dead_code, non_upper_case_globals)] pub const STATIC_GRAY: types::GLenum = 0x8007;\n#[allow(dead_code, non_upper_case_globals)] pub const STENCIL_BUFFER_BIT: types::GLenum = 0x00000040;\n#[allow(dead_code, non_upper_case_globals)] pub const STENCIL_SIZE: types::GLenum = 13;\n#[allow(dead_code, non_upper_case_globals)] pub const STEREO: types::GLenum = 6;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_ALPHA_VALUE: types::GLenum = 0x28;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_BLUE_VALUE: types::GLenum = 0x27;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_GREEN_VALUE: types::GLenum = 0x26;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_INDEX: types::GLenum = 0x8009;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_INDEX_VALUE: types::GLenum = 0x24;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RED_VALUE: types::GLenum = 0x25;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RGB: types::GLenum = 0x8008;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_TYPE: types::GLenum = 0x23;\n#[allow(dead_code, non_upper_case_globals)] pub const TRUE_COLOR: types::GLenum = 0x8002;\n#[allow(dead_code, non_upper_case_globals)] pub const USE_GL: types::GLenum = 1;\n#[allow(dead_code, non_upper_case_globals)] pub const VENDOR: types::GLenum = 0x1;\n#[allow(dead_code, non_upper_case_globals)] pub const VERSION: types::GLenum = 0x2;\n#[allow(dead_code, non_upper_case_globals)] pub const VISUAL_ID: types::GLenum = 0x800B;\n#[allow(dead_code, non_upper_case_globals)] pub const WIDTH: types::GLenum = 0x801D;\n#[allow(dead_code, non_upper_case_globals)] pub const WINDOW: types::GLenum = 0x8022;\n#[allow(dead_code, non_upper_case_globals)] pub const WINDOW_BIT: types::GLenum = 0x00000001;\n#[allow(dead_code, non_upper_case_globals)] pub const X_RENDERABLE: types::GLenum = 0x8012;\n#[allow(dead_code, non_upper_case_globals)] pub const X_VISUAL_TYPE: types::GLenum = 0x22;\n\n        #[allow(dead_code, missing_copy_implementations)]\n        #[derive(Clone)]\n        pub struct FnPtr {\n            /// The function pointer that will be used when calling the function.\n            f: *const __gl_imports::raw::c_void,\n            /// True if the pointer points to a real function, false if points to a `panic!` fn.\n            is_loaded: bool,\n        }\n\n        impl FnPtr {\n            /// Creates a `FnPtr` from a load attempt.\n            fn new(ptr: *const __gl_imports::raw::c_void) -\u003e FnPtr {\n                if ptr.is_null() {\n                    FnPtr {\n                        f: missing_fn_panic as *const __gl_imports::raw::c_void,\n                        is_loaded: false\n                    }\n                } else {\n                    FnPtr { f: ptr, is_loaded: true }\n                }\n            }\n\n            /// Returns `true` if the function has been successfully loaded.\n            ///\n            /// If it returns `false`, calling the corresponding function will fail.\n            #[inline]\n            #[allow(dead_code)]\n            pub fn is_loaded(\u0026self) -\u003e bool {\n                self.is_loaded\n            }\n        }\n    \n#[inline(never)]\n        fn missing_fn_panic() -\u003e ! {\n            panic!(\"glx function was not loaded\")\n        }\n\n        #[allow(non_camel_case_types, non_snake_case, dead_code)]\n        #[derive(Clone)]\n        pub struct Glx {\npub ChooseFBConfig: FnPtr,\npub ChooseVisual: FnPtr,\npub CopyContext: FnPtr,\npub CreateContext: FnPtr,\npub CreateGLXPixmap: FnPtr,\npub CreateNewContext: FnPtr,\npub CreatePbuffer: FnPtr,\npub CreatePixmap: FnPtr,\npub CreateWindow: FnPtr,\npub DestroyContext: FnPtr,\npub DestroyGLXPixmap: FnPtr,\npub DestroyPbuffer: FnPtr,\npub DestroyPixmap: FnPtr,\npub DestroyWindow: FnPtr,\npub GetClientString: FnPtr,\npub GetConfig: FnPtr,\npub GetCurrentContext: FnPtr,\npub GetCurrentDisplay: FnPtr,\npub GetCurrentDrawable: FnPtr,\npub GetCurrentReadDrawable: FnPtr,\npub GetFBConfigAttrib: FnPtr,\npub GetFBConfigs: FnPtr,\npub GetProcAddress: FnPtr,\npub GetSelectedEvent: FnPtr,\npub GetVisualFromFBConfig: FnPtr,\npub IsDirect: FnPtr,\npub MakeContextCurrent: FnPtr,\npub MakeCurrent: FnPtr,\npub QueryContext: FnPtr,\npub QueryDrawable: FnPtr,\npub QueryExtension: FnPtr,\npub QueryExtensionsString: FnPtr,\npub QueryServerString: FnPtr,\npub QueryVersion: FnPtr,\npub SelectEvent: FnPtr,\npub SwapBuffers: FnPtr,\npub UseXFont: FnPtr,\npub WaitGL: FnPtr,\npub WaitX: FnPtr,\n_priv: ()\n}\nimpl Glx {\n            /// Load each OpenGL symbol using a custom load function. This allows for the\n            /// use of functions like `glfwGetProcAddress` or `SDL_GL_GetProcAddress`.\n            ///\n            /// ~~~ignore\n            /// let gl = Gl::load_with(|s| glfw.get_proc_address(s));\n            /// ~~~\n            #[allow(dead_code, unused_variables)]\n            pub fn load_with\u003cF\u003e(mut loadfn: F) -\u003e Glx where F: FnMut(\u0026'static str) -\u003e *const __gl_imports::raw::c_void {\n                #[inline(never)]\n                fn do_metaloadfn(loadfn: \u0026mut dyn FnMut(\u0026'static str) -\u003e *const __gl_imports::raw::c_void,\n                                 symbol: \u0026'static str,\n                                 symbols: \u0026[\u0026'static str])\n                                 -\u003e *const __gl_imports::raw::c_void {\n                    let mut ptr = loadfn(symbol);\n                    if ptr.is_null() {\n                        for \u0026sym in symbols {\n                            ptr = loadfn(sym);\n                            if !ptr.is_null() { break; }\n                        }\n                    }\n                    ptr\n                }\n                let mut metaloadfn = |symbol: \u0026'static str, symbols: \u0026[\u0026'static str]| {\n                    do_metaloadfn(\u0026mut loadfn, symbol, symbols)\n                };\n                Glx {\nChooseFBConfig: FnPtr::new(metaloadfn(\"glXChooseFBConfig\", \u0026[])),\nChooseVisual: FnPtr::new(metaloadfn(\"glXChooseVisual\", \u0026[])),\nCopyContext: FnPtr::new(metaloadfn(\"glXCopyContext\", \u0026[])),\nCreateContext: FnPtr::new(metaloadfn(\"glXCreateContext\", \u0026[])),\nCreateGLXPixmap: FnPtr::new(metaloadfn(\"glXCreateGLXPixmap\", \u0026[])),\nCreateNewContext: FnPtr::new(metaloadfn(\"glXCreateNewContext\", \u0026[])),\nCreatePbuffer: FnPtr::new(metaloadfn(\"glXCreatePbuffer\", \u0026[])),\nCreatePixmap: FnPtr::new(metaloadfn(\"glXCreatePixmap\", \u0026[])),\nCreateWindow: FnPtr::new(metaloadfn(\"glXCreateWindow\", \u0026[])),\nDestroyContext: FnPtr::new(metaloadfn(\"glXDestroyContext\", \u0026[])),\nDestroyGLXPixmap: FnPtr::new(metaloadfn(\"glXDestroyGLXPixmap\", \u0026[])),\nDestroyPbuffer: FnPtr::new(metaloadfn(\"glXDestroyPbuffer\", \u0026[])),\nDestroyPixmap: FnPtr::new(metaloadfn(\"glXDestroyPixmap\", \u0026[])),\nDestroyWindow: FnPtr::new(metaloadfn(\"glXDestroyWindow\", \u0026[])),\nGetClientString: FnPtr::new(metaloadfn(\"glXGetClientString\", \u0026[])),\nGetConfig: FnPtr::new(metaloadfn(\"glXGetConfig\", \u0026[])),\nGetCurrentContext: FnPtr::new(metaloadfn(\"glXGetCurrentContext\", \u0026[])),\nGetCurrentDisplay: FnPtr::new(metaloadfn(\"glXGetCurrentDisplay\", \u0026[])),\nGetCurrentDrawable: FnPtr::new(metaloadfn(\"glXGetCurrentDrawable\", \u0026[])),\nGetCurrentReadDrawable: FnPtr::new(metaloadfn(\"glXGetCurrentReadDrawable\", \u0026[])),\nGetFBConfigAttrib: FnPtr::new(metaloadfn(\"glXGetFBConfigAttrib\", \u0026[])),\nGetFBConfigs: FnPtr::new(metaloadfn(\"glXGetFBConfigs\", \u0026[])),\nGetProcAddress: FnPtr::new(metaloadfn(\"glXGetProcAddress\", \u0026[])),\nGetSelectedEvent: FnPtr::new(metaloadfn(\"glXGetSelectedEvent\", \u0026[])),\nGetVisualFromFBConfig: FnPtr::new(metaloadfn(\"glXGetVisualFromFBConfig\", \u0026[])),\nIsDirect: FnPtr::new(metaloadfn(\"glXIsDirect\", \u0026[])),\nMakeContextCurrent: FnPtr::new(metaloadfn(\"glXMakeContextCurrent\", \u0026[])),\nMakeCurrent: FnPtr::new(metaloadfn(\"glXMakeCurrent\", \u0026[])),\nQueryContext: FnPtr::new(metaloadfn(\"glXQueryContext\", \u0026[])),\nQueryDrawable: FnPtr::new(metaloadfn(\"glXQueryDrawable\", \u0026[])),\nQueryExtension: FnPtr::new(metaloadfn(\"glXQueryExtension\", \u0026[])),\nQueryExtensionsString: FnPtr::new(metaloadfn(\"glXQueryExtensionsString\", \u0026[])),\nQueryServerString: FnPtr::new(metaloadfn(\"glXQueryServerString\", \u0026[])),\nQueryVersion: FnPtr::new(metaloadfn(\"glXQueryVersion\", \u0026[])),\nSelectEvent: FnPtr::new(metaloadfn(\"glXSelectEvent\", \u0026[])),\nSwapBuffers: FnPtr::new(metaloadfn(\"glXSwapBuffers\", \u0026[])),\nUseXFont: FnPtr::new(metaloadfn(\"glXUseXFont\", \u0026[])),\nWaitGL: FnPtr::new(metaloadfn(\"glXWaitGL\", \u0026[])),\nWaitX: FnPtr::new(metaloadfn(\"glXWaitX\", \u0026[])),\n_priv: ()\n}\n        }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn ChooseFBConfig(\u0026self, dpy: *mut types::Display, screen: __gl_imports::raw::c_int, attrib_list: *const __gl_imports::raw::c_int, nelements: *mut __gl_imports::raw::c_int) -\u003e *mut types::GLXFBConfig { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, __gl_imports::raw::c_int, *const __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e *mut types::GLXFBConfig\u003e(self.ChooseFBConfig.f)(dpy, screen, attrib_list, nelements) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn ChooseVisual(\u0026self, dpy: *mut types::Display, screen: __gl_imports::raw::c_int, attribList: *mut __gl_imports::raw::c_int) -\u003e *mut types::XVisualInfo { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e *mut types::XVisualInfo\u003e(self.ChooseVisual.f)(dpy, screen, attribList) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CopyContext(\u0026self, dpy: *mut types::Display, src: types::GLXContext, dst: types::GLXContext, mask: __gl_imports::raw::c_ulong) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXContext, types::GLXContext, __gl_imports::raw::c_ulong) -\u003e ()\u003e(self.CopyContext.f)(dpy, src, dst, mask) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreateContext(\u0026self, dpy: *mut types::Display, vis: *mut types::XVisualInfo, shareList: types::GLXContext, direct: types::Bool) -\u003e types::GLXContext { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, *mut types::XVisualInfo, types::GLXContext, types::Bool) -\u003e types::GLXContext\u003e(self.CreateContext.f)(dpy, vis, shareList, direct) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreateGLXPixmap(\u0026self, dpy: *mut types::Display, visual: *mut types::XVisualInfo, pixmap: types::Pixmap) -\u003e types::GLXPixmap { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, *mut types::XVisualInfo, types::Pixmap) -\u003e types::GLXPixmap\u003e(self.CreateGLXPixmap.f)(dpy, visual, pixmap) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreateNewContext(\u0026self, dpy: *mut types::Display, config: types::GLXFBConfig, render_type: __gl_imports::raw::c_int, share_list: types::GLXContext, direct: types::Bool) -\u003e types::GLXContext { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXFBConfig, __gl_imports::raw::c_int, types::GLXContext, types::Bool) -\u003e types::GLXContext\u003e(self.CreateNewContext.f)(dpy, config, render_type, share_list, direct) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreatePbuffer(\u0026self, dpy: *mut types::Display, config: types::GLXFBConfig, attrib_list: *const __gl_imports::raw::c_int) -\u003e types::GLXPbuffer { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXFBConfig, *const __gl_imports::raw::c_int) -\u003e types::GLXPbuffer\u003e(self.CreatePbuffer.f)(dpy, config, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreatePixmap(\u0026self, dpy: *mut types::Display, config: types::GLXFBConfig, pixmap: types::Pixmap, attrib_list: *const __gl_imports::raw::c_int) -\u003e types::GLXPixmap { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXFBConfig, types::Pixmap, *const __gl_imports::raw::c_int) -\u003e types::GLXPixmap\u003e(self.CreatePixmap.f)(dpy, config, pixmap, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreateWindow(\u0026self, dpy: *mut types::Display, config: types::GLXFBConfig, win: types::Window, attrib_list: *const __gl_imports::raw::c_int) -\u003e types::GLXWindow { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXFBConfig, types::Window, *const __gl_imports::raw::c_int) -\u003e types::GLXWindow\u003e(self.CreateWindow.f)(dpy, config, win, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DestroyContext(\u0026self, dpy: *mut types::Display, ctx: types::GLXContext) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXContext) -\u003e ()\u003e(self.DestroyContext.f)(dpy, ctx) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DestroyGLXPixmap(\u0026self, dpy: *mut types::Display, pixmap: types::GLXPixmap) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXPixmap) -\u003e ()\u003e(self.DestroyGLXPixmap.f)(dpy, pixmap) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DestroyPbuffer(\u0026self, dpy: *mut types::Display, pbuf: types::GLXPbuffer) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXPbuffer) -\u003e ()\u003e(self.DestroyPbuffer.f)(dpy, pbuf) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DestroyPixmap(\u0026self, dpy: *mut types::Display, pixmap: types::GLXPixmap) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXPixmap) -\u003e ()\u003e(self.DestroyPixmap.f)(dpy, pixmap) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DestroyWindow(\u0026self, dpy: *mut types::Display, win: types::GLXWindow) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXWindow) -\u003e ()\u003e(self.DestroyWindow.f)(dpy, win) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetClientString(\u0026self, dpy: *mut types::Display, name: __gl_imports::raw::c_int) -\u003e *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, __gl_imports::raw::c_int) -\u003e *const __gl_imports::raw::c_char\u003e(self.GetClientString.f)(dpy, name) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetConfig(\u0026self, dpy: *mut types::Display, visual: *mut types::XVisualInfo, attrib: __gl_imports::raw::c_int, value: *mut __gl_imports::raw::c_int) -\u003e __gl_imports::raw::c_int { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, *mut types::XVisualInfo, __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e __gl_imports::raw::c_int\u003e(self.GetConfig.f)(dpy, visual, attrib, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetCurrentContext(\u0026self, ) -\u003e types::GLXContext { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e types::GLXContext\u003e(self.GetCurrentContext.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetCurrentDisplay(\u0026self, ) -\u003e *mut types::Display { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e *mut types::Display\u003e(self.GetCurrentDisplay.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetCurrentDrawable(\u0026self, ) -\u003e types::GLXDrawable { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e types::GLXDrawable\u003e(self.GetCurrentDrawable.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetCurrentReadDrawable(\u0026self, ) -\u003e types::GLXDrawable { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e types::GLXDrawable\u003e(self.GetCurrentReadDrawable.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetFBConfigAttrib(\u0026self, dpy: *mut types::Display, config: types::GLXFBConfig, attribute: __gl_imports::raw::c_int, value: *mut __gl_imports::raw::c_int) -\u003e __gl_imports::raw::c_int { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXFBConfig, __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e __gl_imports::raw::c_int\u003e(self.GetFBConfigAttrib.f)(dpy, config, attribute, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetFBConfigs(\u0026self, dpy: *mut types::Display, screen: __gl_imports::raw::c_int, nelements: *mut __gl_imports::raw::c_int) -\u003e *mut types::GLXFBConfig { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e *mut types::GLXFBConfig\u003e(self.GetFBConfigs.f)(dpy, screen, nelements) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetProcAddress(\u0026self, procName: *const types::GLubyte) -\u003e types::__GLXextFuncPtr { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*const types::GLubyte) -\u003e types::__GLXextFuncPtr\u003e(self.GetProcAddress.f)(procName) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetSelectedEvent(\u0026self, dpy: *mut types::Display, draw: types::GLXDrawable, event_mask: *mut __gl_imports::raw::c_ulong) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXDrawable, *mut __gl_imports::raw::c_ulong) -\u003e ()\u003e(self.GetSelectedEvent.f)(dpy, draw, event_mask) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetVisualFromFBConfig(\u0026self, dpy: *mut types::Display, config: types::GLXFBConfig) -\u003e *mut types::XVisualInfo { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXFBConfig) -\u003e *mut types::XVisualInfo\u003e(self.GetVisualFromFBConfig.f)(dpy, config) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn IsDirect(\u0026self, dpy: *mut types::Display, ctx: types::GLXContext) -\u003e types::Bool { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXContext) -\u003e types::Bool\u003e(self.IsDirect.f)(dpy, ctx) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn MakeContextCurrent(\u0026self, dpy: *mut types::Display, draw: types::GLXDrawable, read: types::GLXDrawable, ctx: types::GLXContext) -\u003e types::Bool { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXDrawable, types::GLXDrawable, types::GLXContext) -\u003e types::Bool\u003e(self.MakeContextCurrent.f)(dpy, draw, read, ctx) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn MakeCurrent(\u0026self, dpy: *mut types::Display, drawable: types::GLXDrawable, ctx: types::GLXContext) -\u003e types::Bool { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXDrawable, types::GLXContext) -\u003e types::Bool\u003e(self.MakeCurrent.f)(dpy, drawable, ctx) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryContext(\u0026self, dpy: *mut types::Display, ctx: types::GLXContext, attribute: __gl_imports::raw::c_int, value: *mut __gl_imports::raw::c_int) -\u003e __gl_imports::raw::c_int { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXContext, __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e __gl_imports::raw::c_int\u003e(self.QueryContext.f)(dpy, ctx, attribute, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryDrawable(\u0026self, dpy: *mut types::Display, draw: types::GLXDrawable, attribute: __gl_imports::raw::c_int, value: *mut __gl_imports::raw::c_uint) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXDrawable, __gl_imports::raw::c_int, *mut __gl_imports::raw::c_uint) -\u003e ()\u003e(self.QueryDrawable.f)(dpy, draw, attribute, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryExtension(\u0026self, dpy: *mut types::Display, errorb: *mut __gl_imports::raw::c_int, event: *mut __gl_imports::raw::c_int) -\u003e types::Bool { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, *mut __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e types::Bool\u003e(self.QueryExtension.f)(dpy, errorb, event) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryExtensionsString(\u0026self, dpy: *mut types::Display, screen: __gl_imports::raw::c_int) -\u003e *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, __gl_imports::raw::c_int) -\u003e *const __gl_imports::raw::c_char\u003e(self.QueryExtensionsString.f)(dpy, screen) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryServerString(\u0026self, dpy: *mut types::Display, screen: __gl_imports::raw::c_int, name: __gl_imports::raw::c_int) -\u003e *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, __gl_imports::raw::c_int, __gl_imports::raw::c_int) -\u003e *const __gl_imports::raw::c_char\u003e(self.QueryServerString.f)(dpy, screen, name) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryVersion(\u0026self, dpy: *mut types::Display, maj: *mut __gl_imports::raw::c_int, min: *mut __gl_imports::raw::c_int) -\u003e types::Bool { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, *mut __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e types::Bool\u003e(self.QueryVersion.f)(dpy, maj, min) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn SelectEvent(\u0026self, dpy: *mut types::Display, draw: types::GLXDrawable, event_mask: __gl_imports::raw::c_ulong) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXDrawable, __gl_imports::raw::c_ulong) -\u003e ()\u003e(self.SelectEvent.f)(dpy, draw, event_mask) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn SwapBuffers(\u0026self, dpy: *mut types::Display, drawable: types::GLXDrawable) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXDrawable) -\u003e ()\u003e(self.SwapBuffers.f)(dpy, drawable) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn UseXFont(\u0026self, font: types::Font, first: __gl_imports::raw::c_int, count: __gl_imports::raw::c_int, list: __gl_imports::raw::c_int) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::Font, __gl_imports::raw::c_int, __gl_imports::raw::c_int, __gl_imports::raw::c_int) -\u003e ()\u003e(self.UseXFont.f)(font, first, count, list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn WaitGL(\u0026self, ) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e ()\u003e(self.WaitGL.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn WaitX(\u0026self, ) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e ()\u003e(self.WaitX.f)() }\n}\n\n        unsafe impl __gl_imports::Send for Glx {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","tests","target","debug","build","glutin_glx_sys-50c3a38781448249","out","glx_extra_bindings.rs"],"content":"\n        mod __gl_imports {\n            pub use std::mem;\n            pub use std::marker::Send;\n            pub use std::os::raw;\n        }\n    \n\n        pub mod types {\n            #![allow(non_camel_case_types, non_snake_case, dead_code, missing_copy_implementations)]\n    \n// Common types from OpenGL 1.1\npub type GLenum = super::__gl_imports::raw::c_uint;\npub type GLboolean = super::__gl_imports::raw::c_uchar;\npub type GLbitfield = super::__gl_imports::raw::c_uint;\npub type GLvoid = super::__gl_imports::raw::c_void;\npub type GLbyte = super::__gl_imports::raw::c_char;\npub type GLshort = super::__gl_imports::raw::c_short;\npub type GLint = super::__gl_imports::raw::c_int;\npub type GLclampx = super::__gl_imports::raw::c_int;\npub type GLubyte = super::__gl_imports::raw::c_uchar;\npub type GLushort = super::__gl_imports::raw::c_ushort;\npub type GLuint = super::__gl_imports::raw::c_uint;\npub type GLsizei = super::__gl_imports::raw::c_int;\npub type GLfloat = super::__gl_imports::raw::c_float;\npub type GLclampf = super::__gl_imports::raw::c_float;\npub type GLdouble = super::__gl_imports::raw::c_double;\npub type GLclampd = super::__gl_imports::raw::c_double;\npub type GLeglImageOES = *const super::__gl_imports::raw::c_void;\npub type GLchar = super::__gl_imports::raw::c_char;\npub type GLcharARB = super::__gl_imports::raw::c_char;\n\n#[cfg(target_os = \"macos\")]\npub type GLhandleARB = *const super::__gl_imports::raw::c_void;\n#[cfg(not(target_os = \"macos\"))]\npub type GLhandleARB = super::__gl_imports::raw::c_uint;\n\npub type GLhalfARB = super::__gl_imports::raw::c_ushort;\npub type GLhalf = super::__gl_imports::raw::c_ushort;\n\n// Must be 32 bits\npub type GLfixed = GLint;\n\npub type GLintptr = isize;\npub type GLsizeiptr = isize;\npub type GLint64 = i64;\npub type GLuint64 = u64;\npub type GLintptrARB = isize;\npub type GLsizeiptrARB = isize;\npub type GLint64EXT = i64;\npub type GLuint64EXT = u64;\n\npub enum __GLsync {}\npub type GLsync = *const __GLsync;\n\n// compatible with OpenCL cl_context\npub enum _cl_context {}\npub enum _cl_event {}\n\npub type GLDEBUGPROC = Option\u003cextern \"system\" fn(source: GLenum,\n                                                 gltype: GLenum,\n                                                 id: GLuint,\n                                                 severity: GLenum,\n                                                 length: GLsizei,\n                                                 message: *const GLchar,\n                                                 userParam: *mut super::__gl_imports::raw::c_void)\u003e;\npub type GLDEBUGPROCARB = Option\u003cextern \"system\" fn(source: GLenum,\n                                                    gltype: GLenum,\n                                                    id: GLuint,\n                                                    severity: GLenum,\n                                                    length: GLsizei,\n                                                    message: *const GLchar,\n                                                    userParam: *mut super::__gl_imports::raw::c_void)\u003e;\npub type GLDEBUGPROCKHR = Option\u003cextern \"system\" fn(source: GLenum,\n                                                    gltype: GLenum,\n                                                    id: GLuint,\n                                                    severity: GLenum,\n                                                    length: GLsizei,\n                                                    message: *const GLchar,\n                                                    userParam: *mut super::__gl_imports::raw::c_void)\u003e;\n\n// GLES 1 types\n// \"pub type GLclampx = i32;\",\n\n// GLES 1/2 types (tagged for GLES 1)\n// \"pub type GLbyte = i8;\",\n// \"pub type GLubyte = u8;\",\n// \"pub type GLfloat = GLfloat;\",\n// \"pub type GLclampf = GLfloat;\",\n// \"pub type GLfixed = i32;\",\n// \"pub type GLint64 = i64;\",\n// \"pub type GLuint64 = u64;\",\n// \"pub type GLintptr = intptr_t;\",\n// \"pub type GLsizeiptr = ssize_t;\",\n\n// GLES 1/2 types (tagged for GLES 2 - attribute syntax is limited)\n// \"pub type GLbyte = i8;\",\n// \"pub type GLubyte = u8;\",\n// \"pub type GLfloat = GLfloat;\",\n// \"pub type GLclampf = GLfloat;\",\n// \"pub type GLfixed = i32;\",\n// \"pub type GLint64 = i64;\",\n// \"pub type GLuint64 = u64;\",\n// \"pub type GLint64EXT = i64;\",\n// \"pub type GLuint64EXT = u64;\",\n// \"pub type GLintptr = intptr_t;\",\n// \"pub type GLsizeiptr = ssize_t;\",\n\n// GLES 2 types (none currently)\n\n// Vendor extension types\npub type GLDEBUGPROCAMD = Option\u003cextern \"system\" fn(id: GLuint,\n                                                    category: GLenum,\n                                                    severity: GLenum,\n                                                    length: GLsizei,\n                                                    message: *const GLchar,\n                                                    userParam: *mut super::__gl_imports::raw::c_void)\u003e;\npub type GLhalfNV = super::__gl_imports::raw::c_ushort;\npub type GLvdpauSurfaceNV = GLintptr;\n\npub type XID = super::__gl_imports::raw::c_ulong;\npub type Bool = super::__gl_imports::raw::c_int; // Not sure if this is correct...\npub enum Display {}\n\npub type Font = XID;\npub type Pixmap = XID;\npub enum Visual {} // TODO: not sure\npub type VisualID = super::__gl_imports::raw::c_ulong; // TODO: not sure\npub type Window = XID;\npub type GLXFBConfigID = XID;\npub type GLXFBConfig = *const super::__gl_imports::raw::c_void;\npub type GLXContextID = XID;\npub type GLXContext = *const super::__gl_imports::raw::c_void;\npub type GLXPixmap = XID;\npub type GLXDrawable = XID;\npub type GLXWindow = XID;\npub type GLXPbuffer = XID;\npub enum __GLXextFuncPtr_fn {}\npub type __GLXextFuncPtr = *mut __GLXextFuncPtr_fn;\npub type GLXVideoCaptureDeviceNV = XID;\npub type GLXVideoDeviceNV = super::__gl_imports::raw::c_int;\npub type GLXVideoSourceSGIX = XID;\npub type GLXFBConfigIDSGIX = XID;\npub type GLXFBConfigSGIX = *const super::__gl_imports::raw::c_void;\npub type GLXPbufferSGIX = XID;\n\n#[repr(C)]\npub struct XVisualInfo {\n    pub visual: *mut Visual,\n    pub visualid: VisualID,\n    pub screen: super::__gl_imports::raw::c_int,\n    pub depth: super::__gl_imports::raw::c_int,\n    pub class: super::__gl_imports::raw::c_int,\n    pub red_mask: super::__gl_imports::raw::c_ulong,\n    pub green_mask: super::__gl_imports::raw::c_ulong,\n    pub blue_mask: super::__gl_imports::raw::c_ulong,\n    pub colormap_size: super::__gl_imports::raw::c_int,\n    pub bits_per_rgb: super::__gl_imports::raw::c_int,\n}\n\n#[repr(C)]\npub struct GLXPbufferClobberEvent {\n    pub event_type: super::__gl_imports::raw::c_int, // GLX_DAMAGED or GLX_SAVED\n    pub draw_type: super::__gl_imports::raw::c_int, // GLX_WINDOW or GLX_PBUFFER\n    pub serial: super::__gl_imports::raw::c_ulong, // # of last request processed by server\n    pub send_event: Bool, // true if this came for SendEvent request\n    pub display: *const Display, // display the event was read from\n    pub drawable: GLXDrawable, // XID of Drawable\n    pub buffer_mask: super::__gl_imports::raw::c_uint, // mask indicating which buffers are affected\n    pub aux_buffer: super::__gl_imports::raw::c_uint, // which aux buffer was affected\n    pub x: super::__gl_imports::raw::c_int,\n    pub y: super::__gl_imports::raw::c_int,\n    pub width: super::__gl_imports::raw::c_int,\n    pub height: super::__gl_imports::raw::c_int,\n    pub count: super::__gl_imports::raw::c_int, // if nonzero, at least this many more\n}\n\n#[repr(C)]\npub struct GLXBufferSwapComplete {\n    pub type_: super::__gl_imports::raw::c_int,\n    pub serial: super::__gl_imports::raw::c_ulong, // # of last request processed by server\n    pub send_event: Bool, // true if this came from a SendEvent request\n    pub display: *const Display, // Display the event was read from\n    pub drawable: GLXDrawable, // drawable on which event was requested in event mask\n    pub event_type: super::__gl_imports::raw::c_int,\n    pub ust: i64,\n    pub msc: i64,\n    pub sbc: i64,\n}\n\n// typedef union __GLXEvent {\n//     GLXPbufferClobberEvent glxpbufferclobber;\n//     GLXBufferSwapComplete glxbufferswapcomplete;\n//     long pad[24];\n// }\n\n#[repr(C)]\npub struct GLXBufferClobberEventSGIX {\n    pub type_: super::__gl_imports::raw::c_int,\n    pub serial: super::__gl_imports::raw::c_ulong, // # of last request processed by server\n    pub send_event: Bool, // true if this came for SendEvent request\n    pub display: *const Display, // display the event was read from\n    pub drawable: GLXDrawable, // i.d. of Drawable\n    pub event_type: super::__gl_imports::raw::c_int, // GLX_DAMAGED_SGIX or GLX_SAVED_SGIX\n    pub draw_type: super::__gl_imports::raw::c_int, // GLX_WINDOW_SGIX or GLX_PBUFFER_SGIX\n    pub mask: super::__gl_imports::raw::c_uint, // mask indicating which buffers are affected\n    pub x: super::__gl_imports::raw::c_int,\n    pub y: super::__gl_imports::raw::c_int,\n    pub width: super::__gl_imports::raw::c_int,\n    pub height: super::__gl_imports::raw::c_int,\n    pub count: super::__gl_imports::raw::c_int, // if nonzero, at least this many more\n}\n\n#[repr(C)]\npub struct GLXHyperpipeNetworkSGIX {\n    pub pipeName: [super::__gl_imports::raw::c_char; 80], // Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX]\n    pub networkId: super::__gl_imports::raw::c_int,\n}\n\n#[repr(C)]\npub struct GLXHyperpipeConfigSGIX {\n    pub pipeName: [super::__gl_imports::raw::c_char; 80], // Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX]\n    pub channel: super::__gl_imports::raw::c_int,\n    pub participationType: super::__gl_imports::raw::c_uint,\n    pub timeSlice: super::__gl_imports::raw::c_int,\n}\n\n#[repr(C)]\npub struct GLXPipeRect {\n    pub pipeName: [super::__gl_imports::raw::c_char; 80], // Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX]\n    pub srcXOrigin: super::__gl_imports::raw::c_int,\n    pub srcYOrigin: super::__gl_imports::raw::c_int,\n    pub srcWidth: super::__gl_imports::raw::c_int,\n    pub srcHeight: super::__gl_imports::raw::c_int,\n    pub destXOrigin: super::__gl_imports::raw::c_int,\n    pub destYOrigin: super::__gl_imports::raw::c_int,\n    pub destWidth: super::__gl_imports::raw::c_int,\n    pub destHeight: super::__gl_imports::raw::c_int,\n}\n\n#[repr(C)]\npub struct GLXPipeRectLimits {\n    pub pipeName: [super::__gl_imports::raw::c_char; 80], // Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX]\n    pub XOrigin: super::__gl_imports::raw::c_int,\n    pub YOrigin: super::__gl_imports::raw::c_int,\n    pub maxHeight: super::__gl_imports::raw::c_int,\n    pub maxWidth: super::__gl_imports::raw::c_int,\n}\n\n}\n#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_ALPHA_SIZE: types::GLenum = 17;\n#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_BLUE_SIZE: types::GLenum = 16;\n#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_BUFFER_BIT: types::GLenum = 0x00000080;\n#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_GREEN_SIZE: types::GLenum = 15;\n#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_RED_SIZE: types::GLenum = 14;\n#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_SIZE: types::GLenum = 11;\n#[allow(dead_code, non_upper_case_globals)] pub const AUX_BUFFERS: types::GLenum = 7;\n#[allow(dead_code, non_upper_case_globals)] pub const AUX_BUFFERS_BIT: types::GLenum = 0x00000010;\n#[allow(dead_code, non_upper_case_globals)] pub const BACK_BUFFER_AGE_EXT: types::GLenum = 0x20F4;\n#[allow(dead_code, non_upper_case_globals)] pub const BACK_LEFT_BUFFER_BIT: types::GLenum = 0x00000004;\n#[allow(dead_code, non_upper_case_globals)] pub const BACK_RIGHT_BUFFER_BIT: types::GLenum = 0x00000008;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_ATTRIBUTE: types::GLenum = 2;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_CONTEXT: types::GLenum = 5;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_ENUM: types::GLenum = 7;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_SCREEN: types::GLenum = 1;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_VALUE: types::GLenum = 6;\n#[allow(dead_code, non_upper_case_globals)] pub const BAD_VISUAL: types::GLenum = 4;\n#[allow(dead_code, non_upper_case_globals)] pub const BLUE_SIZE: types::GLenum = 10;\n#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_SIZE: types::GLenum = 2;\n#[allow(dead_code, non_upper_case_globals)] pub const BufferSwapComplete: types::GLenum = 1;\n#[allow(dead_code, non_upper_case_globals)] pub const COLOR_INDEX_BIT: types::GLenum = 0x00000002;\n#[allow(dead_code, non_upper_case_globals)] pub const COLOR_INDEX_TYPE: types::GLenum = 0x8015;\n#[allow(dead_code, non_upper_case_globals)] pub const CONFIG_CAVEAT: types::GLenum = 0x20;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB: types::GLenum = 0x00000002;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_CORE_PROFILE_BIT_ARB: types::GLenum = 0x00000001;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_DEBUG_BIT_ARB: types::GLenum = 0x00000001;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_ES2_PROFILE_BIT_EXT: types::GLenum = 0x00000004;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_FLAGS_ARB: types::GLenum = 0x2094;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_FORWARD_COMPATIBLE_BIT_ARB: types::GLenum = 0x00000002;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MAJOR_VERSION_ARB: types::GLenum = 0x2091;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MINOR_VERSION_ARB: types::GLenum = 0x2092;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_NO_ERROR_ARB: types::GLenum = 0x31B3;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_PROFILE_MASK_ARB: types::GLenum = 0x9126;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RELEASE_BEHAVIOR_ARB: types::GLenum = 0x2097;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB: types::GLenum = 0x2098;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RELEASE_BEHAVIOR_NONE_ARB: types::GLenum = 0;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB: types::GLenum = 0x8256;\n#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_ROBUST_ACCESS_BIT_ARB: types::GLenum = 0x00000004;\n#[allow(dead_code, non_upper_case_globals)] pub const DAMAGED: types::GLenum = 0x8020;\n#[allow(dead_code, non_upper_case_globals)] pub const DEPTH_BUFFER_BIT: types::GLenum = 0x00000020;\n#[allow(dead_code, non_upper_case_globals)] pub const DEPTH_SIZE: types::GLenum = 12;\n#[allow(dead_code, non_upper_case_globals)] pub const DIRECT_COLOR: types::GLenum = 0x8003;\n#[allow(dead_code, non_upper_case_globals)] pub const DONT_CARE: types::GLenum = 0xFFFFFFFF;\n#[allow(dead_code, non_upper_case_globals)] pub const DOUBLEBUFFER: types::GLenum = 5;\n#[allow(dead_code, non_upper_case_globals)] pub const DRAWABLE_TYPE: types::GLenum = 0x8010;\n#[allow(dead_code, non_upper_case_globals)] pub const EVENT_MASK: types::GLenum = 0x801F;\n#[allow(dead_code, non_upper_case_globals)] pub const EXTENSIONS: types::GLenum = 0x3;\n#[allow(dead_code, non_upper_case_globals)] pub const EXTENSION_NAME: \u0026'static str = \"GLX\";\n#[allow(dead_code, non_upper_case_globals)] pub const FBCONFIG_ID: types::GLenum = 0x8013;\n#[allow(dead_code, non_upper_case_globals)] pub const FRAMEBUFFER_SRGB_CAPABLE_ARB: types::GLenum = 0x20B2;\n#[allow(dead_code, non_upper_case_globals)] pub const FRAMEBUFFER_SRGB_CAPABLE_EXT: types::GLenum = 0x20B2;\n#[allow(dead_code, non_upper_case_globals)] pub const FRONT_LEFT_BUFFER_BIT: types::GLenum = 0x00000001;\n#[allow(dead_code, non_upper_case_globals)] pub const FRONT_RIGHT_BUFFER_BIT: types::GLenum = 0x00000002;\n#[allow(dead_code, non_upper_case_globals)] pub const GRAY_SCALE: types::GLenum = 0x8006;\n#[allow(dead_code, non_upper_case_globals)] pub const GREEN_SIZE: types::GLenum = 9;\n#[allow(dead_code, non_upper_case_globals)] pub const HEIGHT: types::GLenum = 0x801E;\n#[allow(dead_code, non_upper_case_globals)] pub const LARGEST_PBUFFER: types::GLenum = 0x801C;\n#[allow(dead_code, non_upper_case_globals)] pub const LEVEL: types::GLenum = 3;\n#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET_ARB: types::GLenum = 0x8252;\n#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_HEIGHT: types::GLenum = 0x8017;\n#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_PIXELS: types::GLenum = 0x8018;\n#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_WIDTH: types::GLenum = 0x8016;\n#[allow(dead_code, non_upper_case_globals)] pub const MAX_SWAP_INTERVAL_EXT: types::GLenum = 0x20F2;\n#[allow(dead_code, non_upper_case_globals)] pub const NONE: types::GLenum = 0x8000;\n#[allow(dead_code, non_upper_case_globals)] pub const NON_CONFORMANT_CONFIG: types::GLenum = 0x800D;\n#[allow(dead_code, non_upper_case_globals)] pub const NO_EXTENSION: types::GLenum = 3;\n#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION_ARB: types::GLenum = 0x8261;\n#[allow(dead_code, non_upper_case_globals)] pub const PBUFFER: types::GLenum = 0x8023;\n#[allow(dead_code, non_upper_case_globals)] pub const PBUFFER_BIT: types::GLenum = 0x00000004;\n#[allow(dead_code, non_upper_case_globals)] pub const PBUFFER_CLOBBER_MASK: types::GLenum = 0x08000000;\n#[allow(dead_code, non_upper_case_globals)] pub const PBUFFER_HEIGHT: types::GLenum = 0x8040;\n#[allow(dead_code, non_upper_case_globals)] pub const PBUFFER_WIDTH: types::GLenum = 0x8041;\n#[allow(dead_code, non_upper_case_globals)] pub const PIXMAP_BIT: types::GLenum = 0x00000002;\n#[allow(dead_code, non_upper_case_globals)] pub const PRESERVED_CONTENTS: types::GLenum = 0x801B;\n#[allow(dead_code, non_upper_case_globals)] pub const PSEUDO_COLOR: types::GLenum = 0x8004;\n#[allow(dead_code, non_upper_case_globals)] pub const PbufferClobber: types::GLenum = 0;\n#[allow(dead_code, non_upper_case_globals)] pub const RED_SIZE: types::GLenum = 8;\n#[allow(dead_code, non_upper_case_globals)] pub const RENDER_TYPE: types::GLenum = 0x8011;\n#[allow(dead_code, non_upper_case_globals)] pub const RGBA: types::GLenum = 4;\n#[allow(dead_code, non_upper_case_globals)] pub const RGBA_BIT: types::GLenum = 0x00000001;\n#[allow(dead_code, non_upper_case_globals)] pub const RGBA_FLOAT_BIT_ARB: types::GLenum = 0x00000004;\n#[allow(dead_code, non_upper_case_globals)] pub const RGBA_FLOAT_TYPE_ARB: types::GLenum = 0x20B9;\n#[allow(dead_code, non_upper_case_globals)] pub const RGBA_TYPE: types::GLenum = 0x8014;\n#[allow(dead_code, non_upper_case_globals)] pub const SAMPLES: types::GLenum = 100001;\n#[allow(dead_code, non_upper_case_globals)] pub const SAMPLES_ARB: types::GLenum = 100001;\n#[allow(dead_code, non_upper_case_globals)] pub const SAMPLE_BUFFERS: types::GLenum = 100000;\n#[allow(dead_code, non_upper_case_globals)] pub const SAMPLE_BUFFERS_ARB: types::GLenum = 100000;\n#[allow(dead_code, non_upper_case_globals)] pub const SAVED: types::GLenum = 0x8021;\n#[allow(dead_code, non_upper_case_globals)] pub const SCREEN: types::GLenum = 0x800C;\n#[allow(dead_code, non_upper_case_globals)] pub const SLOW_CONFIG: types::GLenum = 0x8001;\n#[allow(dead_code, non_upper_case_globals)] pub const STATIC_COLOR: types::GLenum = 0x8005;\n#[allow(dead_code, non_upper_case_globals)] pub const STATIC_GRAY: types::GLenum = 0x8007;\n#[allow(dead_code, non_upper_case_globals)] pub const STENCIL_BUFFER_BIT: types::GLenum = 0x00000040;\n#[allow(dead_code, non_upper_case_globals)] pub const STENCIL_SIZE: types::GLenum = 13;\n#[allow(dead_code, non_upper_case_globals)] pub const STEREO: types::GLenum = 6;\n#[allow(dead_code, non_upper_case_globals)] pub const SWAP_INTERVAL_EXT: types::GLenum = 0x20F1;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_ALPHA_VALUE: types::GLenum = 0x28;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_BLUE_VALUE: types::GLenum = 0x27;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_GREEN_VALUE: types::GLenum = 0x26;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_INDEX: types::GLenum = 0x8009;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_INDEX_VALUE: types::GLenum = 0x24;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RED_VALUE: types::GLenum = 0x25;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RGB: types::GLenum = 0x8008;\n#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_TYPE: types::GLenum = 0x23;\n#[allow(dead_code, non_upper_case_globals)] pub const TRUE_COLOR: types::GLenum = 0x8002;\n#[allow(dead_code, non_upper_case_globals)] pub const USE_GL: types::GLenum = 1;\n#[allow(dead_code, non_upper_case_globals)] pub const VENDOR: types::GLenum = 0x1;\n#[allow(dead_code, non_upper_case_globals)] pub const VERSION: types::GLenum = 0x2;\n#[allow(dead_code, non_upper_case_globals)] pub const VISUAL_ID: types::GLenum = 0x800B;\n#[allow(dead_code, non_upper_case_globals)] pub const WIDTH: types::GLenum = 0x801D;\n#[allow(dead_code, non_upper_case_globals)] pub const WINDOW: types::GLenum = 0x8022;\n#[allow(dead_code, non_upper_case_globals)] pub const WINDOW_BIT: types::GLenum = 0x00000001;\n#[allow(dead_code, non_upper_case_globals)] pub const X_RENDERABLE: types::GLenum = 0x8012;\n#[allow(dead_code, non_upper_case_globals)] pub const X_VISUAL_TYPE: types::GLenum = 0x22;\n\n        #[allow(dead_code, missing_copy_implementations)]\n        #[derive(Clone)]\n        pub struct FnPtr {\n            /// The function pointer that will be used when calling the function.\n            f: *const __gl_imports::raw::c_void,\n            /// True if the pointer points to a real function, false if points to a `panic!` fn.\n            is_loaded: bool,\n        }\n\n        impl FnPtr {\n            /// Creates a `FnPtr` from a load attempt.\n            fn new(ptr: *const __gl_imports::raw::c_void) -\u003e FnPtr {\n                if ptr.is_null() {\n                    FnPtr {\n                        f: missing_fn_panic as *const __gl_imports::raw::c_void,\n                        is_loaded: false\n                    }\n                } else {\n                    FnPtr { f: ptr, is_loaded: true }\n                }\n            }\n\n            /// Returns `true` if the function has been successfully loaded.\n            ///\n            /// If it returns `false`, calling the corresponding function will fail.\n            #[inline]\n            #[allow(dead_code)]\n            pub fn is_loaded(\u0026self) -\u003e bool {\n                self.is_loaded\n            }\n        }\n    \n#[inline(never)]\n        fn missing_fn_panic() -\u003e ! {\n            panic!(\"glx function was not loaded\")\n        }\n\n        #[allow(non_camel_case_types, non_snake_case, dead_code)]\n        #[derive(Clone)]\n        pub struct Glx {\npub ChooseFBConfig: FnPtr,\npub ChooseVisual: FnPtr,\npub CopyContext: FnPtr,\npub CreateContext: FnPtr,\npub CreateContextAttribsARB: FnPtr,\npub CreateGLXPixmap: FnPtr,\npub CreateNewContext: FnPtr,\npub CreatePbuffer: FnPtr,\npub CreatePixmap: FnPtr,\npub CreateWindow: FnPtr,\npub DestroyContext: FnPtr,\npub DestroyGLXPixmap: FnPtr,\npub DestroyPbuffer: FnPtr,\npub DestroyPixmap: FnPtr,\npub DestroyWindow: FnPtr,\npub GetClientString: FnPtr,\npub GetConfig: FnPtr,\npub GetCurrentContext: FnPtr,\npub GetCurrentDisplay: FnPtr,\npub GetCurrentDrawable: FnPtr,\npub GetCurrentReadDrawable: FnPtr,\npub GetFBConfigAttrib: FnPtr,\npub GetFBConfigs: FnPtr,\npub GetProcAddress: FnPtr,\npub GetSelectedEvent: FnPtr,\npub GetSwapIntervalMESA: FnPtr,\npub GetVisualFromFBConfig: FnPtr,\npub IsDirect: FnPtr,\npub MakeContextCurrent: FnPtr,\npub MakeCurrent: FnPtr,\npub QueryContext: FnPtr,\npub QueryDrawable: FnPtr,\npub QueryExtension: FnPtr,\npub QueryExtensionsString: FnPtr,\npub QueryServerString: FnPtr,\npub QueryVersion: FnPtr,\npub SelectEvent: FnPtr,\npub SwapBuffers: FnPtr,\npub SwapIntervalEXT: FnPtr,\npub SwapIntervalMESA: FnPtr,\npub SwapIntervalSGI: FnPtr,\npub UseXFont: FnPtr,\npub WaitGL: FnPtr,\npub WaitX: FnPtr,\n_priv: ()\n}\nimpl Glx {\n            /// Load each OpenGL symbol using a custom load function. This allows for the\n            /// use of functions like `glfwGetProcAddress` or `SDL_GL_GetProcAddress`.\n            ///\n            /// ~~~ignore\n            /// let gl = Gl::load_with(|s| glfw.get_proc_address(s));\n            /// ~~~\n            #[allow(dead_code, unused_variables)]\n            pub fn load_with\u003cF\u003e(mut loadfn: F) -\u003e Glx where F: FnMut(\u0026'static str) -\u003e *const __gl_imports::raw::c_void {\n                #[inline(never)]\n                fn do_metaloadfn(loadfn: \u0026mut dyn FnMut(\u0026'static str) -\u003e *const __gl_imports::raw::c_void,\n                                 symbol: \u0026'static str,\n                                 symbols: \u0026[\u0026'static str])\n                                 -\u003e *const __gl_imports::raw::c_void {\n                    let mut ptr = loadfn(symbol);\n                    if ptr.is_null() {\n                        for \u0026sym in symbols {\n                            ptr = loadfn(sym);\n                            if !ptr.is_null() { break; }\n                        }\n                    }\n                    ptr\n                }\n                let mut metaloadfn = |symbol: \u0026'static str, symbols: \u0026[\u0026'static str]| {\n                    do_metaloadfn(\u0026mut loadfn, symbol, symbols)\n                };\n                Glx {\nChooseFBConfig: FnPtr::new(metaloadfn(\"glXChooseFBConfig\", \u0026[])),\nChooseVisual: FnPtr::new(metaloadfn(\"glXChooseVisual\", \u0026[])),\nCopyContext: FnPtr::new(metaloadfn(\"glXCopyContext\", \u0026[])),\nCreateContext: FnPtr::new(metaloadfn(\"glXCreateContext\", \u0026[])),\nCreateContextAttribsARB: FnPtr::new(metaloadfn(\"glXCreateContextAttribsARB\", \u0026[])),\nCreateGLXPixmap: FnPtr::new(metaloadfn(\"glXCreateGLXPixmap\", \u0026[])),\nCreateNewContext: FnPtr::new(metaloadfn(\"glXCreateNewContext\", \u0026[])),\nCreatePbuffer: FnPtr::new(metaloadfn(\"glXCreatePbuffer\", \u0026[])),\nCreatePixmap: FnPtr::new(metaloadfn(\"glXCreatePixmap\", \u0026[])),\nCreateWindow: FnPtr::new(metaloadfn(\"glXCreateWindow\", \u0026[])),\nDestroyContext: FnPtr::new(metaloadfn(\"glXDestroyContext\", \u0026[])),\nDestroyGLXPixmap: FnPtr::new(metaloadfn(\"glXDestroyGLXPixmap\", \u0026[])),\nDestroyPbuffer: FnPtr::new(metaloadfn(\"glXDestroyPbuffer\", \u0026[])),\nDestroyPixmap: FnPtr::new(metaloadfn(\"glXDestroyPixmap\", \u0026[])),\nDestroyWindow: FnPtr::new(metaloadfn(\"glXDestroyWindow\", \u0026[])),\nGetClientString: FnPtr::new(metaloadfn(\"glXGetClientString\", \u0026[])),\nGetConfig: FnPtr::new(metaloadfn(\"glXGetConfig\", \u0026[])),\nGetCurrentContext: FnPtr::new(metaloadfn(\"glXGetCurrentContext\", \u0026[])),\nGetCurrentDisplay: FnPtr::new(metaloadfn(\"glXGetCurrentDisplay\", \u0026[])),\nGetCurrentDrawable: FnPtr::new(metaloadfn(\"glXGetCurrentDrawable\", \u0026[])),\nGetCurrentReadDrawable: FnPtr::new(metaloadfn(\"glXGetCurrentReadDrawable\", \u0026[])),\nGetFBConfigAttrib: FnPtr::new(metaloadfn(\"glXGetFBConfigAttrib\", \u0026[])),\nGetFBConfigs: FnPtr::new(metaloadfn(\"glXGetFBConfigs\", \u0026[])),\nGetProcAddress: FnPtr::new(metaloadfn(\"glXGetProcAddress\", \u0026[])),\nGetSelectedEvent: FnPtr::new(metaloadfn(\"glXGetSelectedEvent\", \u0026[])),\nGetSwapIntervalMESA: FnPtr::new(metaloadfn(\"glXGetSwapIntervalMESA\", \u0026[])),\nGetVisualFromFBConfig: FnPtr::new(metaloadfn(\"glXGetVisualFromFBConfig\", \u0026[])),\nIsDirect: FnPtr::new(metaloadfn(\"glXIsDirect\", \u0026[])),\nMakeContextCurrent: FnPtr::new(metaloadfn(\"glXMakeContextCurrent\", \u0026[])),\nMakeCurrent: FnPtr::new(metaloadfn(\"glXMakeCurrent\", \u0026[])),\nQueryContext: FnPtr::new(metaloadfn(\"glXQueryContext\", \u0026[])),\nQueryDrawable: FnPtr::new(metaloadfn(\"glXQueryDrawable\", \u0026[])),\nQueryExtension: FnPtr::new(metaloadfn(\"glXQueryExtension\", \u0026[])),\nQueryExtensionsString: FnPtr::new(metaloadfn(\"glXQueryExtensionsString\", \u0026[])),\nQueryServerString: FnPtr::new(metaloadfn(\"glXQueryServerString\", \u0026[])),\nQueryVersion: FnPtr::new(metaloadfn(\"glXQueryVersion\", \u0026[])),\nSelectEvent: FnPtr::new(metaloadfn(\"glXSelectEvent\", \u0026[])),\nSwapBuffers: FnPtr::new(metaloadfn(\"glXSwapBuffers\", \u0026[])),\nSwapIntervalEXT: FnPtr::new(metaloadfn(\"glXSwapIntervalEXT\", \u0026[])),\nSwapIntervalMESA: FnPtr::new(metaloadfn(\"glXSwapIntervalMESA\", \u0026[])),\nSwapIntervalSGI: FnPtr::new(metaloadfn(\"glXSwapIntervalSGI\", \u0026[])),\nUseXFont: FnPtr::new(metaloadfn(\"glXUseXFont\", \u0026[])),\nWaitGL: FnPtr::new(metaloadfn(\"glXWaitGL\", \u0026[])),\nWaitX: FnPtr::new(metaloadfn(\"glXWaitX\", \u0026[])),\n_priv: ()\n}\n        }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn ChooseFBConfig(\u0026self, dpy: *mut types::Display, screen: __gl_imports::raw::c_int, attrib_list: *const __gl_imports::raw::c_int, nelements: *mut __gl_imports::raw::c_int) -\u003e *mut types::GLXFBConfig { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, __gl_imports::raw::c_int, *const __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e *mut types::GLXFBConfig\u003e(self.ChooseFBConfig.f)(dpy, screen, attrib_list, nelements) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn ChooseVisual(\u0026self, dpy: *mut types::Display, screen: __gl_imports::raw::c_int, attribList: *mut __gl_imports::raw::c_int) -\u003e *mut types::XVisualInfo { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e *mut types::XVisualInfo\u003e(self.ChooseVisual.f)(dpy, screen, attribList) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CopyContext(\u0026self, dpy: *mut types::Display, src: types::GLXContext, dst: types::GLXContext, mask: __gl_imports::raw::c_ulong) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXContext, types::GLXContext, __gl_imports::raw::c_ulong) -\u003e ()\u003e(self.CopyContext.f)(dpy, src, dst, mask) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreateContext(\u0026self, dpy: *mut types::Display, vis: *mut types::XVisualInfo, shareList: types::GLXContext, direct: types::Bool) -\u003e types::GLXContext { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, *mut types::XVisualInfo, types::GLXContext, types::Bool) -\u003e types::GLXContext\u003e(self.CreateContext.f)(dpy, vis, shareList, direct) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreateContextAttribsARB(\u0026self, dpy: *mut types::Display, config: types::GLXFBConfig, share_context: types::GLXContext, direct: types::Bool, attrib_list: *const __gl_imports::raw::c_int) -\u003e types::GLXContext { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXFBConfig, types::GLXContext, types::Bool, *const __gl_imports::raw::c_int) -\u003e types::GLXContext\u003e(self.CreateContextAttribsARB.f)(dpy, config, share_context, direct, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreateGLXPixmap(\u0026self, dpy: *mut types::Display, visual: *mut types::XVisualInfo, pixmap: types::Pixmap) -\u003e types::GLXPixmap { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, *mut types::XVisualInfo, types::Pixmap) -\u003e types::GLXPixmap\u003e(self.CreateGLXPixmap.f)(dpy, visual, pixmap) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreateNewContext(\u0026self, dpy: *mut types::Display, config: types::GLXFBConfig, render_type: __gl_imports::raw::c_int, share_list: types::GLXContext, direct: types::Bool) -\u003e types::GLXContext { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXFBConfig, __gl_imports::raw::c_int, types::GLXContext, types::Bool) -\u003e types::GLXContext\u003e(self.CreateNewContext.f)(dpy, config, render_type, share_list, direct) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreatePbuffer(\u0026self, dpy: *mut types::Display, config: types::GLXFBConfig, attrib_list: *const __gl_imports::raw::c_int) -\u003e types::GLXPbuffer { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXFBConfig, *const __gl_imports::raw::c_int) -\u003e types::GLXPbuffer\u003e(self.CreatePbuffer.f)(dpy, config, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreatePixmap(\u0026self, dpy: *mut types::Display, config: types::GLXFBConfig, pixmap: types::Pixmap, attrib_list: *const __gl_imports::raw::c_int) -\u003e types::GLXPixmap { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXFBConfig, types::Pixmap, *const __gl_imports::raw::c_int) -\u003e types::GLXPixmap\u003e(self.CreatePixmap.f)(dpy, config, pixmap, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn CreateWindow(\u0026self, dpy: *mut types::Display, config: types::GLXFBConfig, win: types::Window, attrib_list: *const __gl_imports::raw::c_int) -\u003e types::GLXWindow { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXFBConfig, types::Window, *const __gl_imports::raw::c_int) -\u003e types::GLXWindow\u003e(self.CreateWindow.f)(dpy, config, win, attrib_list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DestroyContext(\u0026self, dpy: *mut types::Display, ctx: types::GLXContext) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXContext) -\u003e ()\u003e(self.DestroyContext.f)(dpy, ctx) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DestroyGLXPixmap(\u0026self, dpy: *mut types::Display, pixmap: types::GLXPixmap) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXPixmap) -\u003e ()\u003e(self.DestroyGLXPixmap.f)(dpy, pixmap) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DestroyPbuffer(\u0026self, dpy: *mut types::Display, pbuf: types::GLXPbuffer) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXPbuffer) -\u003e ()\u003e(self.DestroyPbuffer.f)(dpy, pbuf) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DestroyPixmap(\u0026self, dpy: *mut types::Display, pixmap: types::GLXPixmap) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXPixmap) -\u003e ()\u003e(self.DestroyPixmap.f)(dpy, pixmap) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn DestroyWindow(\u0026self, dpy: *mut types::Display, win: types::GLXWindow) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXWindow) -\u003e ()\u003e(self.DestroyWindow.f)(dpy, win) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetClientString(\u0026self, dpy: *mut types::Display, name: __gl_imports::raw::c_int) -\u003e *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, __gl_imports::raw::c_int) -\u003e *const __gl_imports::raw::c_char\u003e(self.GetClientString.f)(dpy, name) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetConfig(\u0026self, dpy: *mut types::Display, visual: *mut types::XVisualInfo, attrib: __gl_imports::raw::c_int, value: *mut __gl_imports::raw::c_int) -\u003e __gl_imports::raw::c_int { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, *mut types::XVisualInfo, __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e __gl_imports::raw::c_int\u003e(self.GetConfig.f)(dpy, visual, attrib, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetCurrentContext(\u0026self, ) -\u003e types::GLXContext { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e types::GLXContext\u003e(self.GetCurrentContext.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetCurrentDisplay(\u0026self, ) -\u003e *mut types::Display { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e *mut types::Display\u003e(self.GetCurrentDisplay.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetCurrentDrawable(\u0026self, ) -\u003e types::GLXDrawable { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e types::GLXDrawable\u003e(self.GetCurrentDrawable.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetCurrentReadDrawable(\u0026self, ) -\u003e types::GLXDrawable { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e types::GLXDrawable\u003e(self.GetCurrentReadDrawable.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetFBConfigAttrib(\u0026self, dpy: *mut types::Display, config: types::GLXFBConfig, attribute: __gl_imports::raw::c_int, value: *mut __gl_imports::raw::c_int) -\u003e __gl_imports::raw::c_int { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXFBConfig, __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e __gl_imports::raw::c_int\u003e(self.GetFBConfigAttrib.f)(dpy, config, attribute, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetFBConfigs(\u0026self, dpy: *mut types::Display, screen: __gl_imports::raw::c_int, nelements: *mut __gl_imports::raw::c_int) -\u003e *mut types::GLXFBConfig { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e *mut types::GLXFBConfig\u003e(self.GetFBConfigs.f)(dpy, screen, nelements) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetProcAddress(\u0026self, procName: *const types::GLubyte) -\u003e types::__GLXextFuncPtr { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*const types::GLubyte) -\u003e types::__GLXextFuncPtr\u003e(self.GetProcAddress.f)(procName) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetSelectedEvent(\u0026self, dpy: *mut types::Display, draw: types::GLXDrawable, event_mask: *mut __gl_imports::raw::c_ulong) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXDrawable, *mut __gl_imports::raw::c_ulong) -\u003e ()\u003e(self.GetSelectedEvent.f)(dpy, draw, event_mask) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetSwapIntervalMESA(\u0026self, ) -\u003e __gl_imports::raw::c_int { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e __gl_imports::raw::c_int\u003e(self.GetSwapIntervalMESA.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn GetVisualFromFBConfig(\u0026self, dpy: *mut types::Display, config: types::GLXFBConfig) -\u003e *mut types::XVisualInfo { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXFBConfig) -\u003e *mut types::XVisualInfo\u003e(self.GetVisualFromFBConfig.f)(dpy, config) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn IsDirect(\u0026self, dpy: *mut types::Display, ctx: types::GLXContext) -\u003e types::Bool { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXContext) -\u003e types::Bool\u003e(self.IsDirect.f)(dpy, ctx) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn MakeContextCurrent(\u0026self, dpy: *mut types::Display, draw: types::GLXDrawable, read: types::GLXDrawable, ctx: types::GLXContext) -\u003e types::Bool { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXDrawable, types::GLXDrawable, types::GLXContext) -\u003e types::Bool\u003e(self.MakeContextCurrent.f)(dpy, draw, read, ctx) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn MakeCurrent(\u0026self, dpy: *mut types::Display, drawable: types::GLXDrawable, ctx: types::GLXContext) -\u003e types::Bool { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXDrawable, types::GLXContext) -\u003e types::Bool\u003e(self.MakeCurrent.f)(dpy, drawable, ctx) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryContext(\u0026self, dpy: *mut types::Display, ctx: types::GLXContext, attribute: __gl_imports::raw::c_int, value: *mut __gl_imports::raw::c_int) -\u003e __gl_imports::raw::c_int { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXContext, __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e __gl_imports::raw::c_int\u003e(self.QueryContext.f)(dpy, ctx, attribute, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryDrawable(\u0026self, dpy: *mut types::Display, draw: types::GLXDrawable, attribute: __gl_imports::raw::c_int, value: *mut __gl_imports::raw::c_uint) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXDrawable, __gl_imports::raw::c_int, *mut __gl_imports::raw::c_uint) -\u003e ()\u003e(self.QueryDrawable.f)(dpy, draw, attribute, value) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryExtension(\u0026self, dpy: *mut types::Display, errorb: *mut __gl_imports::raw::c_int, event: *mut __gl_imports::raw::c_int) -\u003e types::Bool { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, *mut __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e types::Bool\u003e(self.QueryExtension.f)(dpy, errorb, event) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryExtensionsString(\u0026self, dpy: *mut types::Display, screen: __gl_imports::raw::c_int) -\u003e *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, __gl_imports::raw::c_int) -\u003e *const __gl_imports::raw::c_char\u003e(self.QueryExtensionsString.f)(dpy, screen) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryServerString(\u0026self, dpy: *mut types::Display, screen: __gl_imports::raw::c_int, name: __gl_imports::raw::c_int) -\u003e *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, __gl_imports::raw::c_int, __gl_imports::raw::c_int) -\u003e *const __gl_imports::raw::c_char\u003e(self.QueryServerString.f)(dpy, screen, name) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn QueryVersion(\u0026self, dpy: *mut types::Display, maj: *mut __gl_imports::raw::c_int, min: *mut __gl_imports::raw::c_int) -\u003e types::Bool { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, *mut __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -\u003e types::Bool\u003e(self.QueryVersion.f)(dpy, maj, min) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn SelectEvent(\u0026self, dpy: *mut types::Display, draw: types::GLXDrawable, event_mask: __gl_imports::raw::c_ulong) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXDrawable, __gl_imports::raw::c_ulong) -\u003e ()\u003e(self.SelectEvent.f)(dpy, draw, event_mask) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn SwapBuffers(\u0026self, dpy: *mut types::Display, drawable: types::GLXDrawable) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXDrawable) -\u003e ()\u003e(self.SwapBuffers.f)(dpy, drawable) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn SwapIntervalEXT(\u0026self, dpy: *mut types::Display, drawable: types::GLXDrawable, interval: __gl_imports::raw::c_int) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(*mut types::Display, types::GLXDrawable, __gl_imports::raw::c_int) -\u003e ()\u003e(self.SwapIntervalEXT.f)(dpy, drawable, interval) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn SwapIntervalMESA(\u0026self, interval: __gl_imports::raw::c_uint) -\u003e __gl_imports::raw::c_int { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(__gl_imports::raw::c_uint) -\u003e __gl_imports::raw::c_int\u003e(self.SwapIntervalMESA.f)(interval) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn SwapIntervalSGI(\u0026self, interval: __gl_imports::raw::c_int) -\u003e __gl_imports::raw::c_int { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(__gl_imports::raw::c_int) -\u003e __gl_imports::raw::c_int\u003e(self.SwapIntervalSGI.f)(interval) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn UseXFont(\u0026self, font: types::Font, first: __gl_imports::raw::c_int, count: __gl_imports::raw::c_int, list: __gl_imports::raw::c_int) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn(types::Font, __gl_imports::raw::c_int, __gl_imports::raw::c_int, __gl_imports::raw::c_int) -\u003e ()\u003e(self.UseXFont.f)(font, first, count, list) }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn WaitGL(\u0026self, ) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e ()\u003e(self.WaitGL.f)() }\n#[allow(non_snake_case, unused_variables, dead_code)]\n            #[inline] pub unsafe fn WaitX(\u0026self, ) -\u003e () { __gl_imports::mem::transmute::\u003c_, extern \"system\" fn() -\u003e ()\u003e(self.WaitX.f)() }\n}\n\n        unsafe impl __gl_imports::Send for Glx {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","tests","target","debug","build","khronos_api-f512357105002b15","out","webgl_exts.rs"],"content":"\u0026[\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/EXT_disjoint_timer_query_webgl2/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/OES_texture_half_float_linear/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/OES_standard_derivatives/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/WEBGL_multiview/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/OES_element_index_uint/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/WEBGL_security_sensitive_resources/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/OES_vertex_array_object/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/OES_fbo_render_mipmap/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/WEBGL_compressed_texture_etc/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/ANGLE_instanced_arrays/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/WEBGL_debug_shaders/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/WEBGL_depth_texture/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/OES_texture_float_linear/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/WEBGL_compressed_texture_etc1/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/WEBGL_compressed_texture_s3tc/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/OES_texture_half_float/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/WEBGL_lose_context/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/EXT_texture_compression_rgtc/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/WEBGL_draw_buffers/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/EXT_disjoint_timer_query/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/WEBGL_debug_renderer_info/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/EXT_float_blend/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/EXT_color_buffer_half_float/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/EXT_color_buffer_float/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/EXT_shader_texture_lod/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/EXT_blend_minmax/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/KHR_parallel_shader_compile/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/WEBGL_compressed_texture_astc/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/OES_texture_float/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/EXT_texture_compression_bptc/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/EXT_frag_depth/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/EXT_texture_filter_anisotropic/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/EXT_sRGB/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/WEBGL_compressed_texture_pvrtc/extension.xml\"),\n\u0026*include_bytes!(\"/home/kvothe/.cargo/registry/src/index.crates.io-6f17d22bba15001f/khronos_api-3.1.0/api_webgl/extensions/WEBGL_color_buffer_float/extension.xml\"),\n]\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","tests","target","debug","build","mime_guess-fc503fba6bd4f222","out","mime_types_generated.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","tests","target","debug","build","mime_guess2-534af65b592a56d6","out","mime_types_generated.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","tests","target","debug","build","rav1e-f66910fe8ba8c2eb","out","built.rs"],"content":"//\n// EVERYTHING BELOW THIS POINT WAS AUTO-GENERATED DURING COMPILATION. DO NOT MODIFY.\n//\n#[doc=r#\"The Continuous Integration platform detected during compilation.\"#]\n#[allow(dead_code)]\npub const CI_PLATFORM: Option\u003c\u0026str\u003e = None;\n#[doc=r#\"The full version.\"#]\n#[allow(dead_code)]\npub const PKG_VERSION: \u0026str = r\"0.7.1\";\n#[doc=r#\"The major version.\"#]\n#[allow(dead_code)]\npub const PKG_VERSION_MAJOR: \u0026str = r\"0\";\n#[doc=r#\"The minor version.\"#]\n#[allow(dead_code)]\npub const PKG_VERSION_MINOR: \u0026str = r\"7\";\n#[doc=r#\"The patch version.\"#]\n#[allow(dead_code)]\npub const PKG_VERSION_PATCH: \u0026str = r\"1\";\n#[doc=r#\"The pre-release version.\"#]\n#[allow(dead_code)]\npub const PKG_VERSION_PRE: \u0026str = r\"\";\n#[doc=r#\"A colon-separated list of authors.\"#]\n#[allow(dead_code)]\npub const PKG_AUTHORS: \u0026str = r\"Thomas Daede \u003ctdaede@xiph.org\u003e\";\n#[doc=r#\"The name of the package.\"#]\n#[allow(dead_code)]\npub const PKG_NAME: \u0026str = r\"rav1e\";\n#[doc=r#\"The description.\"#]\n#[allow(dead_code)]\npub const PKG_DESCRIPTION: \u0026str = r\"The fastest and safest AV1 encoder\";\n#[doc=r#\"The homepage.\"#]\n#[allow(dead_code)]\npub const PKG_HOMEPAGE: \u0026str = r\"\";\n#[doc=r#\"The license.\"#]\n#[allow(dead_code)]\npub const PKG_LICENSE: \u0026str = r\"BSD-2-Clause\";\n#[doc=r#\"The source repository as advertised in Cargo.toml.\"#]\n#[allow(dead_code)]\npub const PKG_REPOSITORY: \u0026str = r\"https://github.com/xiph/rav1e/\";\n#[doc=r#\"The target triple that was being compiled for.\"#]\n#[allow(dead_code)]\npub const TARGET: \u0026str = r\"x86_64-unknown-linux-gnu\";\n#[doc=r#\"The host triple of the rust compiler.\"#]\n#[allow(dead_code)]\npub const HOST: \u0026str = r\"x86_64-unknown-linux-gnu\";\n#[doc=r#\"`release` for release builds, `debug` for other builds.\"#]\n#[allow(dead_code)]\npub const PROFILE: \u0026str = r\"debug\";\n#[doc=r#\"The compiler that cargo resolved to use.\"#]\n#[allow(dead_code)]\npub const RUSTC: \u0026str = r\"/home/kvothe/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc\";\n#[doc=r#\"The documentation generator that cargo resolved to use.\"#]\n#[allow(dead_code)]\npub const RUSTDOC: \u0026str = r\"/home/kvothe/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustdoc\";\n#[doc=r#\"Value of OPT_LEVEL for the profile used during compilation.\"#]\n#[allow(dead_code)]\npub const OPT_LEVEL: \u0026str = r\"1\";\n#[doc=r#\"The parallelism that was specified during compilation.\"#]\n#[allow(dead_code)]\npub const NUM_JOBS: u32 = 16;\n#[doc=r#\"Value of DEBUG for the profile used during compilation.\"#]\n#[allow(dead_code)]\npub const DEBUG: bool = true;\n#[doc=r#\"The features that were enabled during compilation.\"#]\n#[allow(dead_code)]\npub const FEATURES: [\u0026str; 1] = [\"THREADING\"];\n#[doc=r#\"The features as a comma-separated string.\"#]\n#[allow(dead_code)]\npub const FEATURES_STR: \u0026str = r\"THREADING\";\n#[doc=r#\"The features as above, as lowercase strings.\"#]\n#[allow(dead_code)]\npub const FEATURES_LOWERCASE: [\u0026str; 1] = [\"threading\"];\n#[doc=r#\"The feature-string as above, from lowercase strings.\"#]\n#[allow(dead_code)]\npub const FEATURES_LOWERCASE_STR: \u0026str = r\"threading\";\n#[doc=r#\"The output of `/home/kvothe/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc -V`\"#]\n#[allow(dead_code)]\npub const RUSTC_VERSION: \u0026str = r\"rustc 1.79.0 (129f3b996 2024-06-10)\";\n#[doc=r#\"The output of `/home/kvothe/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustdoc -V`; empty string if `/home/kvothe/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustdoc -V` failed to execute\"#]\n#[allow(dead_code)]\npub const RUSTDOC_VERSION: \u0026str = r\"rustdoc 1.79.0 (129f3b996 2024-06-10)\";\n#[doc=r#\"The target architecture, given by `CARGO_CFG_TARGET_ARCH`.\"#]\n#[allow(dead_code)]\npub const CFG_TARGET_ARCH: \u0026str = r\"x86_64\";\n#[doc=r#\"The endianness, given by `CARGO_CFG_TARGET_ENDIAN`.\"#]\n#[allow(dead_code)]\npub const CFG_ENDIAN: \u0026str = r\"little\";\n#[doc=r#\"The toolchain-environment, given by `CARGO_CFG_TARGET_ENV`.\"#]\n#[allow(dead_code)]\npub const CFG_ENV: \u0026str = r\"gnu\";\n#[doc=r#\"The OS-family, given by `CARGO_CFG_TARGET_FAMILY`.\"#]\n#[allow(dead_code)]\npub const CFG_FAMILY: \u0026str = r\"unix\";\n#[doc=r#\"The operating system, given by `CARGO_CFG_TARGET_OS`.\"#]\n#[allow(dead_code)]\npub const CFG_OS: \u0026str = r\"linux\";\n#[doc=r#\"The pointer width, given by `CARGO_CFG_TARGET_POINTER_WIDTH`.\"#]\n#[allow(dead_code)]\npub const CFG_POINTER_WIDTH: \u0026str = r\"64\";\n//\n// EVERYTHING ABOVE THIS POINT WAS AUTO-GENERATED DURING COMPILATION. DO NOT MODIFY.\n//\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","tests","target","debug","build","typenum-116a99f005dfe29f","out","consts.rs"],"content":"\n/**\nType aliases for many constants.\n\nThis file is generated by typenum's build script.\n\nFor unsigned integers, the format is `U` followed by the number. We define aliases for\n\n- Numbers 0 through 1024\n- Powers of 2 below `u64::MAX`\n- Powers of 10 below `u64::MAX`\n\nThese alias definitions look like this:\n\n```rust\nuse typenum::{B0, B1, UInt, UTerm};\n\n# #[allow(dead_code)]\ntype U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n```\n\nFor positive signed integers, the format is `P` followed by the number and for negative\nsigned integers it is `N` followed by the number. For the signed integer zero, we use\n`Z0`. We define aliases for\n\n- Numbers -1024 through 1024\n- Powers of 2 between `i64::MIN` and `i64::MAX`\n- Powers of 10 between `i64::MIN` and `i64::MAX`\n\nThese alias definitions look like this:\n\n```rust\nuse typenum::{B0, B1, UInt, UTerm, PInt, NInt};\n\n# #[allow(dead_code)]\ntype P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n# #[allow(dead_code)]\ntype N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n```\n\n# Example\n```rust\n# #[allow(unused_imports)]\nuse typenum::{U0, U1, U2, U3, U4, U5, U6};\n# #[allow(unused_imports)]\nuse typenum::{N3, N2, N1, Z0, P1, P2, P3};\n# #[allow(unused_imports)]\nuse typenum::{U774, N17, N10000, P1024, P4096};\n```\n\nWe also define the aliases `False` and `True` for `B0` and `B1`, respectively.\n*/\n#[allow(missing_docs)]\npub mod consts {\n    use crate::uint::{UInt, UTerm};\n    use crate::int::{PInt, NInt};\n\n    pub use crate::bit::{B0, B1};\n    pub use crate::int::Z0;\n\n    pub type True = B1;\n    pub type False = B0;\n    pub type U0 = UTerm;\n    pub type U1 = UInt\u003cUTerm, B1\u003e;\n    pub type P1 = PInt\u003cU1\u003e; pub type N1 = NInt\u003cU1\u003e;\n    pub type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    pub type P2 = PInt\u003cU2\u003e; pub type N2 = NInt\u003cU2\u003e;\n    pub type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    pub type P3 = PInt\u003cU3\u003e; pub type N3 = NInt\u003cU3\u003e;\n    pub type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    pub type P4 = PInt\u003cU4\u003e; pub type N4 = NInt\u003cU4\u003e;\n    pub type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    pub type P5 = PInt\u003cU5\u003e; pub type N5 = NInt\u003cU5\u003e;\n    pub type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n    pub type P6 = PInt\u003cU6\u003e; pub type N6 = NInt\u003cU6\u003e;\n    pub type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n    pub type P7 = PInt\u003cU7\u003e; pub type N7 = NInt\u003cU7\u003e;\n    pub type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P8 = PInt\u003cU8\u003e; pub type N8 = NInt\u003cU8\u003e;\n    pub type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P9 = PInt\u003cU9\u003e; pub type N9 = NInt\u003cU9\u003e;\n    pub type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P10 = PInt\u003cU10\u003e; pub type N10 = NInt\u003cU10\u003e;\n    pub type U11 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P11 = PInt\u003cU11\u003e; pub type N11 = NInt\u003cU11\u003e;\n    pub type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P12 = PInt\u003cU12\u003e; pub type N12 = NInt\u003cU12\u003e;\n    pub type U13 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P13 = PInt\u003cU13\u003e; pub type N13 = NInt\u003cU13\u003e;\n    pub type U14 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P14 = PInt\u003cU14\u003e; pub type N14 = NInt\u003cU14\u003e;\n    pub type U15 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P15 = PInt\u003cU15\u003e; pub type N15 = NInt\u003cU15\u003e;\n    pub type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P16 = PInt\u003cU16\u003e; pub type N16 = NInt\u003cU16\u003e;\n    pub type U17 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P17 = PInt\u003cU17\u003e; pub type N17 = NInt\u003cU17\u003e;\n    pub type U18 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P18 = PInt\u003cU18\u003e; pub type N18 = NInt\u003cU18\u003e;\n    pub type U19 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P19 = PInt\u003cU19\u003e; pub type N19 = NInt\u003cU19\u003e;\n    pub type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P20 = PInt\u003cU20\u003e; pub type N20 = NInt\u003cU20\u003e;\n    pub type U21 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P21 = PInt\u003cU21\u003e; pub type N21 = NInt\u003cU21\u003e;\n    pub type U22 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P22 = PInt\u003cU22\u003e; pub type N22 = NInt\u003cU22\u003e;\n    pub type U23 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P23 = PInt\u003cU23\u003e; pub type N23 = NInt\u003cU23\u003e;\n    pub type U24 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P24 = PInt\u003cU24\u003e; pub type N24 = NInt\u003cU24\u003e;\n    pub type U25 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P25 = PInt\u003cU25\u003e; pub type N25 = NInt\u003cU25\u003e;\n    pub type U26 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P26 = PInt\u003cU26\u003e; pub type N26 = NInt\u003cU26\u003e;\n    pub type U27 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P27 = PInt\u003cU27\u003e; pub type N27 = NInt\u003cU27\u003e;\n    pub type U28 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P28 = PInt\u003cU28\u003e; pub type N28 = NInt\u003cU28\u003e;\n    pub type U29 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P29 = PInt\u003cU29\u003e; pub type N29 = NInt\u003cU29\u003e;\n    pub type U30 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P30 = PInt\u003cU30\u003e; pub type N30 = NInt\u003cU30\u003e;\n    pub type U31 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P31 = PInt\u003cU31\u003e; pub type N31 = NInt\u003cU31\u003e;\n    pub type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P32 = PInt\u003cU32\u003e; pub type N32 = NInt\u003cU32\u003e;\n    pub type U33 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P33 = PInt\u003cU33\u003e; pub type N33 = NInt\u003cU33\u003e;\n    pub type U34 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P34 = PInt\u003cU34\u003e; pub type N34 = NInt\u003cU34\u003e;\n    pub type U35 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P35 = PInt\u003cU35\u003e; pub type N35 = NInt\u003cU35\u003e;\n    pub type U36 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P36 = PInt\u003cU36\u003e; pub type N36 = NInt\u003cU36\u003e;\n    pub type U37 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P37 = PInt\u003cU37\u003e; pub type N37 = NInt\u003cU37\u003e;\n    pub type U38 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P38 = PInt\u003cU38\u003e; pub type N38 = NInt\u003cU38\u003e;\n    pub type U39 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P39 = PInt\u003cU39\u003e; pub type N39 = NInt\u003cU39\u003e;\n    pub type U40 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P40 = PInt\u003cU40\u003e; pub type N40 = NInt\u003cU40\u003e;\n    pub type U41 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P41 = PInt\u003cU41\u003e; pub type N41 = NInt\u003cU41\u003e;\n    pub type U42 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P42 = PInt\u003cU42\u003e; pub type N42 = NInt\u003cU42\u003e;\n    pub type U43 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P43 = PInt\u003cU43\u003e; pub type N43 = NInt\u003cU43\u003e;\n    pub type U44 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P44 = PInt\u003cU44\u003e; pub type N44 = NInt\u003cU44\u003e;\n    pub type U45 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P45 = PInt\u003cU45\u003e; pub type N45 = NInt\u003cU45\u003e;\n    pub type U46 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P46 = PInt\u003cU46\u003e; pub type N46 = NInt\u003cU46\u003e;\n    pub type U47 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P47 = PInt\u003cU47\u003e; pub type N47 = NInt\u003cU47\u003e;\n    pub type U48 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P48 = PInt\u003cU48\u003e; pub type N48 = NInt\u003cU48\u003e;\n    pub type U49 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P49 = PInt\u003cU49\u003e; pub type N49 = NInt\u003cU49\u003e;\n    pub type U50 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P50 = PInt\u003cU50\u003e; pub type N50 = NInt\u003cU50\u003e;\n    pub type U51 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P51 = PInt\u003cU51\u003e; pub type N51 = NInt\u003cU51\u003e;\n    pub type U52 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P52 = PInt\u003cU52\u003e; pub type N52 = NInt\u003cU52\u003e;\n    pub type U53 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P53 = PInt\u003cU53\u003e; pub type N53 = NInt\u003cU53\u003e;\n    pub type U54 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P54 = PInt\u003cU54\u003e; pub type N54 = NInt\u003cU54\u003e;\n    pub type U55 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P55 = PInt\u003cU55\u003e; pub type N55 = NInt\u003cU55\u003e;\n    pub type U56 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P56 = PInt\u003cU56\u003e; pub type N56 = NInt\u003cU56\u003e;\n    pub type U57 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P57 = PInt\u003cU57\u003e; pub type N57 = NInt\u003cU57\u003e;\n    pub type U58 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P58 = PInt\u003cU58\u003e; pub type N58 = NInt\u003cU58\u003e;\n    pub type U59 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P59 = PInt\u003cU59\u003e; pub type N59 = NInt\u003cU59\u003e;\n    pub type U60 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P60 = PInt\u003cU60\u003e; pub type N60 = NInt\u003cU60\u003e;\n    pub type U61 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P61 = PInt\u003cU61\u003e; pub type N61 = NInt\u003cU61\u003e;\n    pub type U62 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P62 = PInt\u003cU62\u003e; pub type N62 = NInt\u003cU62\u003e;\n    pub type U63 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P63 = PInt\u003cU63\u003e; pub type N63 = NInt\u003cU63\u003e;\n    pub type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P64 = PInt\u003cU64\u003e; pub type N64 = NInt\u003cU64\u003e;\n    pub type U65 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P65 = PInt\u003cU65\u003e; pub type N65 = NInt\u003cU65\u003e;\n    pub type U66 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P66 = PInt\u003cU66\u003e; pub type N66 = NInt\u003cU66\u003e;\n    pub type U67 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P67 = PInt\u003cU67\u003e; pub type N67 = NInt\u003cU67\u003e;\n    pub type U68 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P68 = PInt\u003cU68\u003e; pub type N68 = NInt\u003cU68\u003e;\n    pub type U69 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P69 = PInt\u003cU69\u003e; pub type N69 = NInt\u003cU69\u003e;\n    pub type U70 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P70 = PInt\u003cU70\u003e; pub type N70 = NInt\u003cU70\u003e;\n    pub type U71 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P71 = PInt\u003cU71\u003e; pub type N71 = NInt\u003cU71\u003e;\n    pub type U72 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P72 = PInt\u003cU72\u003e; pub type N72 = NInt\u003cU72\u003e;\n    pub type U73 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P73 = PInt\u003cU73\u003e; pub type N73 = NInt\u003cU73\u003e;\n    pub type U74 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P74 = PInt\u003cU74\u003e; pub type N74 = NInt\u003cU74\u003e;\n    pub type U75 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P75 = PInt\u003cU75\u003e; pub type N75 = NInt\u003cU75\u003e;\n    pub type U76 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P76 = PInt\u003cU76\u003e; pub type N76 = NInt\u003cU76\u003e;\n    pub type U77 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P77 = PInt\u003cU77\u003e; pub type N77 = NInt\u003cU77\u003e;\n    pub type U78 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P78 = PInt\u003cU78\u003e; pub type N78 = NInt\u003cU78\u003e;\n    pub type U79 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P79 = PInt\u003cU79\u003e; pub type N79 = NInt\u003cU79\u003e;\n    pub type U80 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P80 = PInt\u003cU80\u003e; pub type N80 = NInt\u003cU80\u003e;\n    pub type U81 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P81 = PInt\u003cU81\u003e; pub type N81 = NInt\u003cU81\u003e;\n    pub type U82 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P82 = PInt\u003cU82\u003e; pub type N82 = NInt\u003cU82\u003e;\n    pub type U83 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P83 = PInt\u003cU83\u003e; pub type N83 = NInt\u003cU83\u003e;\n    pub type U84 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P84 = PInt\u003cU84\u003e; pub type N84 = NInt\u003cU84\u003e;\n    pub type U85 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P85 = PInt\u003cU85\u003e; pub type N85 = NInt\u003cU85\u003e;\n    pub type U86 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P86 = PInt\u003cU86\u003e; pub type N86 = NInt\u003cU86\u003e;\n    pub type U87 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P87 = PInt\u003cU87\u003e; pub type N87 = NInt\u003cU87\u003e;\n    pub type U88 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P88 = PInt\u003cU88\u003e; pub type N88 = NInt\u003cU88\u003e;\n    pub type U89 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P89 = PInt\u003cU89\u003e; pub type N89 = NInt\u003cU89\u003e;\n    pub type U90 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P90 = PInt\u003cU90\u003e; pub type N90 = NInt\u003cU90\u003e;\n    pub type U91 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P91 = PInt\u003cU91\u003e; pub type N91 = NInt\u003cU91\u003e;\n    pub type U92 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P92 = PInt\u003cU92\u003e; pub type N92 = NInt\u003cU92\u003e;\n    pub type U93 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P93 = PInt\u003cU93\u003e; pub type N93 = NInt\u003cU93\u003e;\n    pub type U94 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P94 = PInt\u003cU94\u003e; pub type N94 = NInt\u003cU94\u003e;\n    pub type U95 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P95 = PInt\u003cU95\u003e; pub type N95 = NInt\u003cU95\u003e;\n    pub type U96 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P96 = PInt\u003cU96\u003e; pub type N96 = NInt\u003cU96\u003e;\n    pub type U97 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P97 = PInt\u003cU97\u003e; pub type N97 = NInt\u003cU97\u003e;\n    pub type U98 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P98 = PInt\u003cU98\u003e; pub type N98 = NInt\u003cU98\u003e;\n    pub type U99 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P99 = PInt\u003cU99\u003e; pub type N99 = NInt\u003cU99\u003e;\n    pub type U100 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P100 = PInt\u003cU100\u003e; pub type N100 = NInt\u003cU100\u003e;\n    pub type U101 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P101 = PInt\u003cU101\u003e; pub type N101 = NInt\u003cU101\u003e;\n    pub type U102 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P102 = PInt\u003cU102\u003e; pub type N102 = NInt\u003cU102\u003e;\n    pub type U103 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P103 = PInt\u003cU103\u003e; pub type N103 = NInt\u003cU103\u003e;\n    pub type U104 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P104 = PInt\u003cU104\u003e; pub type N104 = NInt\u003cU104\u003e;\n    pub type U105 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P105 = PInt\u003cU105\u003e; pub type N105 = NInt\u003cU105\u003e;\n    pub type U106 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P106 = PInt\u003cU106\u003e; pub type N106 = NInt\u003cU106\u003e;\n    pub type U107 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P107 = PInt\u003cU107\u003e; pub type N107 = NInt\u003cU107\u003e;\n    pub type U108 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P108 = PInt\u003cU108\u003e; pub type N108 = NInt\u003cU108\u003e;\n    pub type U109 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P109 = PInt\u003cU109\u003e; pub type N109 = NInt\u003cU109\u003e;\n    pub type U110 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P110 = PInt\u003cU110\u003e; pub type N110 = NInt\u003cU110\u003e;\n    pub type U111 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P111 = PInt\u003cU111\u003e; pub type N111 = NInt\u003cU111\u003e;\n    pub type U112 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P112 = PInt\u003cU112\u003e; pub type N112 = NInt\u003cU112\u003e;\n    pub type U113 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P113 = PInt\u003cU113\u003e; pub type N113 = NInt\u003cU113\u003e;\n    pub type U114 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P114 = PInt\u003cU114\u003e; pub type N114 = NInt\u003cU114\u003e;\n    pub type U115 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P115 = PInt\u003cU115\u003e; pub type N115 = NInt\u003cU115\u003e;\n    pub type U116 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P116 = PInt\u003cU116\u003e; pub type N116 = NInt\u003cU116\u003e;\n    pub type U117 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P117 = PInt\u003cU117\u003e; pub type N117 = NInt\u003cU117\u003e;\n    pub type U118 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P118 = PInt\u003cU118\u003e; pub type N118 = NInt\u003cU118\u003e;\n    pub type U119 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P119 = PInt\u003cU119\u003e; pub type N119 = NInt\u003cU119\u003e;\n    pub type U120 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P120 = PInt\u003cU120\u003e; pub type N120 = NInt\u003cU120\u003e;\n    pub type U121 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P121 = PInt\u003cU121\u003e; pub type N121 = NInt\u003cU121\u003e;\n    pub type U122 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P122 = PInt\u003cU122\u003e; pub type N122 = NInt\u003cU122\u003e;\n    pub type U123 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P123 = PInt\u003cU123\u003e; pub type N123 = NInt\u003cU123\u003e;\n    pub type U124 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P124 = PInt\u003cU124\u003e; pub type N124 = NInt\u003cU124\u003e;\n    pub type U125 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P125 = PInt\u003cU125\u003e; pub type N125 = NInt\u003cU125\u003e;\n    pub type U126 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P126 = PInt\u003cU126\u003e; pub type N126 = NInt\u003cU126\u003e;\n    pub type U127 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P127 = PInt\u003cU127\u003e; pub type N127 = NInt\u003cU127\u003e;\n    pub type U128 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P128 = PInt\u003cU128\u003e; pub type N128 = NInt\u003cU128\u003e;\n    pub type U129 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P129 = PInt\u003cU129\u003e; pub type N129 = NInt\u003cU129\u003e;\n    pub type U130 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P130 = PInt\u003cU130\u003e; pub type N130 = NInt\u003cU130\u003e;\n    pub type U131 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P131 = PInt\u003cU131\u003e; pub type N131 = NInt\u003cU131\u003e;\n    pub type U132 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P132 = PInt\u003cU132\u003e; pub type N132 = NInt\u003cU132\u003e;\n    pub type U133 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P133 = PInt\u003cU133\u003e; pub type N133 = NInt\u003cU133\u003e;\n    pub type U134 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P134 = PInt\u003cU134\u003e; pub type N134 = NInt\u003cU134\u003e;\n    pub type U135 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P135 = PInt\u003cU135\u003e; pub type N135 = NInt\u003cU135\u003e;\n    pub type U136 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P136 = PInt\u003cU136\u003e; pub type N136 = NInt\u003cU136\u003e;\n    pub type U137 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P137 = PInt\u003cU137\u003e; pub type N137 = NInt\u003cU137\u003e;\n    pub type U138 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P138 = PInt\u003cU138\u003e; pub type N138 = NInt\u003cU138\u003e;\n    pub type U139 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P139 = PInt\u003cU139\u003e; pub type N139 = NInt\u003cU139\u003e;\n    pub type U140 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P140 = PInt\u003cU140\u003e; pub type N140 = NInt\u003cU140\u003e;\n    pub type U141 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P141 = PInt\u003cU141\u003e; pub type N141 = NInt\u003cU141\u003e;\n    pub type U142 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P142 = PInt\u003cU142\u003e; pub type N142 = NInt\u003cU142\u003e;\n    pub type U143 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P143 = PInt\u003cU143\u003e; pub type N143 = NInt\u003cU143\u003e;\n    pub type U144 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P144 = PInt\u003cU144\u003e; pub type N144 = NInt\u003cU144\u003e;\n    pub type U145 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P145 = PInt\u003cU145\u003e; pub type N145 = NInt\u003cU145\u003e;\n    pub type U146 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P146 = PInt\u003cU146\u003e; pub type N146 = NInt\u003cU146\u003e;\n    pub type U147 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P147 = PInt\u003cU147\u003e; pub type N147 = NInt\u003cU147\u003e;\n    pub type U148 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P148 = PInt\u003cU148\u003e; pub type N148 = NInt\u003cU148\u003e;\n    pub type U149 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P149 = PInt\u003cU149\u003e; pub type N149 = NInt\u003cU149\u003e;\n    pub type U150 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P150 = PInt\u003cU150\u003e; pub type N150 = NInt\u003cU150\u003e;\n    pub type U151 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P151 = PInt\u003cU151\u003e; pub type N151 = NInt\u003cU151\u003e;\n    pub type U152 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P152 = PInt\u003cU152\u003e; pub type N152 = NInt\u003cU152\u003e;\n    pub type U153 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P153 = PInt\u003cU153\u003e; pub type N153 = NInt\u003cU153\u003e;\n    pub type U154 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P154 = PInt\u003cU154\u003e; pub type N154 = NInt\u003cU154\u003e;\n    pub type U155 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P155 = PInt\u003cU155\u003e; pub type N155 = NInt\u003cU155\u003e;\n    pub type U156 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P156 = PInt\u003cU156\u003e; pub type N156 = NInt\u003cU156\u003e;\n    pub type U157 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P157 = PInt\u003cU157\u003e; pub type N157 = NInt\u003cU157\u003e;\n    pub type U158 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P158 = PInt\u003cU158\u003e; pub type N158 = NInt\u003cU158\u003e;\n    pub type U159 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P159 = PInt\u003cU159\u003e; pub type N159 = NInt\u003cU159\u003e;\n    pub type U160 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P160 = PInt\u003cU160\u003e; pub type N160 = NInt\u003cU160\u003e;\n    pub type U161 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P161 = PInt\u003cU161\u003e; pub type N161 = NInt\u003cU161\u003e;\n    pub type U162 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P162 = PInt\u003cU162\u003e; pub type N162 = NInt\u003cU162\u003e;\n    pub type U163 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P163 = PInt\u003cU163\u003e; pub type N163 = NInt\u003cU163\u003e;\n    pub type U164 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P164 = PInt\u003cU164\u003e; pub type N164 = NInt\u003cU164\u003e;\n    pub type U165 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P165 = PInt\u003cU165\u003e; pub type N165 = NInt\u003cU165\u003e;\n    pub type U166 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P166 = PInt\u003cU166\u003e; pub type N166 = NInt\u003cU166\u003e;\n    pub type U167 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P167 = PInt\u003cU167\u003e; pub type N167 = NInt\u003cU167\u003e;\n    pub type U168 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P168 = PInt\u003cU168\u003e; pub type N168 = NInt\u003cU168\u003e;\n    pub type U169 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P169 = PInt\u003cU169\u003e; pub type N169 = NInt\u003cU169\u003e;\n    pub type U170 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P170 = PInt\u003cU170\u003e; pub type N170 = NInt\u003cU170\u003e;\n    pub type U171 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P171 = PInt\u003cU171\u003e; pub type N171 = NInt\u003cU171\u003e;\n    pub type U172 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P172 = PInt\u003cU172\u003e; pub type N172 = NInt\u003cU172\u003e;\n    pub type U173 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P173 = PInt\u003cU173\u003e; pub type N173 = NInt\u003cU173\u003e;\n    pub type U174 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P174 = PInt\u003cU174\u003e; pub type N174 = NInt\u003cU174\u003e;\n    pub type U175 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P175 = PInt\u003cU175\u003e; pub type N175 = NInt\u003cU175\u003e;\n    pub type U176 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P176 = PInt\u003cU176\u003e; pub type N176 = NInt\u003cU176\u003e;\n    pub type U177 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P177 = PInt\u003cU177\u003e; pub type N177 = NInt\u003cU177\u003e;\n    pub type U178 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P178 = PInt\u003cU178\u003e; pub type N178 = NInt\u003cU178\u003e;\n    pub type U179 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P179 = PInt\u003cU179\u003e; pub type N179 = NInt\u003cU179\u003e;\n    pub type U180 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P180 = PInt\u003cU180\u003e; pub type N180 = NInt\u003cU180\u003e;\n    pub type U181 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P181 = PInt\u003cU181\u003e; pub type N181 = NInt\u003cU181\u003e;\n    pub type U182 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P182 = PInt\u003cU182\u003e; pub type N182 = NInt\u003cU182\u003e;\n    pub type U183 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P183 = PInt\u003cU183\u003e; pub type N183 = NInt\u003cU183\u003e;\n    pub type U184 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P184 = PInt\u003cU184\u003e; pub type N184 = NInt\u003cU184\u003e;\n    pub type U185 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P185 = PInt\u003cU185\u003e; pub type N185 = NInt\u003cU185\u003e;\n    pub type U186 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P186 = PInt\u003cU186\u003e; pub type N186 = NInt\u003cU186\u003e;\n    pub type U187 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P187 = PInt\u003cU187\u003e; pub type N187 = NInt\u003cU187\u003e;\n    pub type U188 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P188 = PInt\u003cU188\u003e; pub type N188 = NInt\u003cU188\u003e;\n    pub type U189 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P189 = PInt\u003cU189\u003e; pub type N189 = NInt\u003cU189\u003e;\n    pub type U190 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P190 = PInt\u003cU190\u003e; pub type N190 = NInt\u003cU190\u003e;\n    pub type U191 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P191 = PInt\u003cU191\u003e; pub type N191 = NInt\u003cU191\u003e;\n    pub type U192 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P192 = PInt\u003cU192\u003e; pub type N192 = NInt\u003cU192\u003e;\n    pub type U193 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P193 = PInt\u003cU193\u003e; pub type N193 = NInt\u003cU193\u003e;\n    pub type U194 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P194 = PInt\u003cU194\u003e; pub type N194 = NInt\u003cU194\u003e;\n    pub type U195 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P195 = PInt\u003cU195\u003e; pub type N195 = NInt\u003cU195\u003e;\n    pub type U196 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P196 = PInt\u003cU196\u003e; pub type N196 = NInt\u003cU196\u003e;\n    pub type U197 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P197 = PInt\u003cU197\u003e; pub type N197 = NInt\u003cU197\u003e;\n    pub type U198 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P198 = PInt\u003cU198\u003e; pub type N198 = NInt\u003cU198\u003e;\n    pub type U199 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P199 = PInt\u003cU199\u003e; pub type N199 = NInt\u003cU199\u003e;\n    pub type U200 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P200 = PInt\u003cU200\u003e; pub type N200 = NInt\u003cU200\u003e;\n    pub type U201 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P201 = PInt\u003cU201\u003e; pub type N201 = NInt\u003cU201\u003e;\n    pub type U202 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P202 = PInt\u003cU202\u003e; pub type N202 = NInt\u003cU202\u003e;\n    pub type U203 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P203 = PInt\u003cU203\u003e; pub type N203 = NInt\u003cU203\u003e;\n    pub type U204 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P204 = PInt\u003cU204\u003e; pub type N204 = NInt\u003cU204\u003e;\n    pub type U205 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P205 = PInt\u003cU205\u003e; pub type N205 = NInt\u003cU205\u003e;\n    pub type U206 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P206 = PInt\u003cU206\u003e; pub type N206 = NInt\u003cU206\u003e;\n    pub type U207 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P207 = PInt\u003cU207\u003e; pub type N207 = NInt\u003cU207\u003e;\n    pub type U208 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P208 = PInt\u003cU208\u003e; pub type N208 = NInt\u003cU208\u003e;\n    pub type U209 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P209 = PInt\u003cU209\u003e; pub type N209 = NInt\u003cU209\u003e;\n    pub type U210 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P210 = PInt\u003cU210\u003e; pub type N210 = NInt\u003cU210\u003e;\n    pub type U211 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P211 = PInt\u003cU211\u003e; pub type N211 = NInt\u003cU211\u003e;\n    pub type U212 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P212 = PInt\u003cU212\u003e; pub type N212 = NInt\u003cU212\u003e;\n    pub type U213 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P213 = PInt\u003cU213\u003e; pub type N213 = NInt\u003cU213\u003e;\n    pub type U214 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P214 = PInt\u003cU214\u003e; pub type N214 = NInt\u003cU214\u003e;\n    pub type U215 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P215 = PInt\u003cU215\u003e; pub type N215 = NInt\u003cU215\u003e;\n    pub type U216 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P216 = PInt\u003cU216\u003e; pub type N216 = NInt\u003cU216\u003e;\n    pub type U217 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P217 = PInt\u003cU217\u003e; pub type N217 = NInt\u003cU217\u003e;\n    pub type U218 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P218 = PInt\u003cU218\u003e; pub type N218 = NInt\u003cU218\u003e;\n    pub type U219 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P219 = PInt\u003cU219\u003e; pub type N219 = NInt\u003cU219\u003e;\n    pub type U220 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P220 = PInt\u003cU220\u003e; pub type N220 = NInt\u003cU220\u003e;\n    pub type U221 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P221 = PInt\u003cU221\u003e; pub type N221 = NInt\u003cU221\u003e;\n    pub type U222 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P222 = PInt\u003cU222\u003e; pub type N222 = NInt\u003cU222\u003e;\n    pub type U223 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P223 = PInt\u003cU223\u003e; pub type N223 = NInt\u003cU223\u003e;\n    pub type U224 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P224 = PInt\u003cU224\u003e; pub type N224 = NInt\u003cU224\u003e;\n    pub type U225 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P225 = PInt\u003cU225\u003e; pub type N225 = NInt\u003cU225\u003e;\n    pub type U226 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P226 = PInt\u003cU226\u003e; pub type N226 = NInt\u003cU226\u003e;\n    pub type U227 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P227 = PInt\u003cU227\u003e; pub type N227 = NInt\u003cU227\u003e;\n    pub type U228 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P228 = PInt\u003cU228\u003e; pub type N228 = NInt\u003cU228\u003e;\n    pub type U229 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P229 = PInt\u003cU229\u003e; pub type N229 = NInt\u003cU229\u003e;\n    pub type U230 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P230 = PInt\u003cU230\u003e; pub type N230 = NInt\u003cU230\u003e;\n    pub type U231 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P231 = PInt\u003cU231\u003e; pub type N231 = NInt\u003cU231\u003e;\n    pub type U232 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P232 = PInt\u003cU232\u003e; pub type N232 = NInt\u003cU232\u003e;\n    pub type U233 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P233 = PInt\u003cU233\u003e; pub type N233 = NInt\u003cU233\u003e;\n    pub type U234 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P234 = PInt\u003cU234\u003e; pub type N234 = NInt\u003cU234\u003e;\n    pub type U235 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P235 = PInt\u003cU235\u003e; pub type N235 = NInt\u003cU235\u003e;\n    pub type U236 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P236 = PInt\u003cU236\u003e; pub type N236 = NInt\u003cU236\u003e;\n    pub type U237 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P237 = PInt\u003cU237\u003e; pub type N237 = NInt\u003cU237\u003e;\n    pub type U238 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P238 = PInt\u003cU238\u003e; pub type N238 = NInt\u003cU238\u003e;\n    pub type U239 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P239 = PInt\u003cU239\u003e; pub type N239 = NInt\u003cU239\u003e;\n    pub type U240 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P240 = PInt\u003cU240\u003e; pub type N240 = NInt\u003cU240\u003e;\n    pub type U241 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P241 = PInt\u003cU241\u003e; pub type N241 = NInt\u003cU241\u003e;\n    pub type U242 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P242 = PInt\u003cU242\u003e; pub type N242 = NInt\u003cU242\u003e;\n    pub type U243 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P243 = PInt\u003cU243\u003e; pub type N243 = NInt\u003cU243\u003e;\n    pub type U244 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P244 = PInt\u003cU244\u003e; pub type N244 = NInt\u003cU244\u003e;\n    pub type U245 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P245 = PInt\u003cU245\u003e; pub type N245 = NInt\u003cU245\u003e;\n    pub type U246 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P246 = PInt\u003cU246\u003e; pub type N246 = NInt\u003cU246\u003e;\n    pub type U247 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P247 = PInt\u003cU247\u003e; pub type N247 = NInt\u003cU247\u003e;\n    pub type U248 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P248 = PInt\u003cU248\u003e; pub type N248 = NInt\u003cU248\u003e;\n    pub type U249 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P249 = PInt\u003cU249\u003e; pub type N249 = NInt\u003cU249\u003e;\n    pub type U250 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P250 = PInt\u003cU250\u003e; pub type N250 = NInt\u003cU250\u003e;\n    pub type U251 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P251 = PInt\u003cU251\u003e; pub type N251 = NInt\u003cU251\u003e;\n    pub type U252 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P252 = PInt\u003cU252\u003e; pub type N252 = NInt\u003cU252\u003e;\n    pub type U253 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P253 = PInt\u003cU253\u003e; pub type N253 = NInt\u003cU253\u003e;\n    pub type U254 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P254 = PInt\u003cU254\u003e; pub type N254 = NInt\u003cU254\u003e;\n    pub type U255 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P255 = PInt\u003cU255\u003e; pub type N255 = NInt\u003cU255\u003e;\n    pub type U256 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P256 = PInt\u003cU256\u003e; pub type N256 = NInt\u003cU256\u003e;\n    pub type U257 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P257 = PInt\u003cU257\u003e; pub type N257 = NInt\u003cU257\u003e;\n    pub type U258 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P258 = PInt\u003cU258\u003e; pub type N258 = NInt\u003cU258\u003e;\n    pub type U259 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P259 = PInt\u003cU259\u003e; pub type N259 = NInt\u003cU259\u003e;\n    pub type U260 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P260 = PInt\u003cU260\u003e; pub type N260 = NInt\u003cU260\u003e;\n    pub type U261 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P261 = PInt\u003cU261\u003e; pub type N261 = NInt\u003cU261\u003e;\n    pub type U262 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P262 = PInt\u003cU262\u003e; pub type N262 = NInt\u003cU262\u003e;\n    pub type U263 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P263 = PInt\u003cU263\u003e; pub type N263 = NInt\u003cU263\u003e;\n    pub type U264 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P264 = PInt\u003cU264\u003e; pub type N264 = NInt\u003cU264\u003e;\n    pub type U265 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P265 = PInt\u003cU265\u003e; pub type N265 = NInt\u003cU265\u003e;\n    pub type U266 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P266 = PInt\u003cU266\u003e; pub type N266 = NInt\u003cU266\u003e;\n    pub type U267 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P267 = PInt\u003cU267\u003e; pub type N267 = NInt\u003cU267\u003e;\n    pub type U268 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P268 = PInt\u003cU268\u003e; pub type N268 = NInt\u003cU268\u003e;\n    pub type U269 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P269 = PInt\u003cU269\u003e; pub type N269 = NInt\u003cU269\u003e;\n    pub type U270 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P270 = PInt\u003cU270\u003e; pub type N270 = NInt\u003cU270\u003e;\n    pub type U271 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P271 = PInt\u003cU271\u003e; pub type N271 = NInt\u003cU271\u003e;\n    pub type U272 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P272 = PInt\u003cU272\u003e; pub type N272 = NInt\u003cU272\u003e;\n    pub type U273 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P273 = PInt\u003cU273\u003e; pub type N273 = NInt\u003cU273\u003e;\n    pub type U274 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P274 = PInt\u003cU274\u003e; pub type N274 = NInt\u003cU274\u003e;\n    pub type U275 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P275 = PInt\u003cU275\u003e; pub type N275 = NInt\u003cU275\u003e;\n    pub type U276 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P276 = PInt\u003cU276\u003e; pub type N276 = NInt\u003cU276\u003e;\n    pub type U277 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P277 = PInt\u003cU277\u003e; pub type N277 = NInt\u003cU277\u003e;\n    pub type U278 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P278 = PInt\u003cU278\u003e; pub type N278 = NInt\u003cU278\u003e;\n    pub type U279 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P279 = PInt\u003cU279\u003e; pub type N279 = NInt\u003cU279\u003e;\n    pub type U280 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P280 = PInt\u003cU280\u003e; pub type N280 = NInt\u003cU280\u003e;\n    pub type U281 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P281 = PInt\u003cU281\u003e; pub type N281 = NInt\u003cU281\u003e;\n    pub type U282 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P282 = PInt\u003cU282\u003e; pub type N282 = NInt\u003cU282\u003e;\n    pub type U283 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P283 = PInt\u003cU283\u003e; pub type N283 = NInt\u003cU283\u003e;\n    pub type U284 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P284 = PInt\u003cU284\u003e; pub type N284 = NInt\u003cU284\u003e;\n    pub type U285 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P285 = PInt\u003cU285\u003e; pub type N285 = NInt\u003cU285\u003e;\n    pub type U286 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P286 = PInt\u003cU286\u003e; pub type N286 = NInt\u003cU286\u003e;\n    pub type U287 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P287 = PInt\u003cU287\u003e; pub type N287 = NInt\u003cU287\u003e;\n    pub type U288 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P288 = PInt\u003cU288\u003e; pub type N288 = NInt\u003cU288\u003e;\n    pub type U289 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P289 = PInt\u003cU289\u003e; pub type N289 = NInt\u003cU289\u003e;\n    pub type U290 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P290 = PInt\u003cU290\u003e; pub type N290 = NInt\u003cU290\u003e;\n    pub type U291 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P291 = PInt\u003cU291\u003e; pub type N291 = NInt\u003cU291\u003e;\n    pub type U292 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P292 = PInt\u003cU292\u003e; pub type N292 = NInt\u003cU292\u003e;\n    pub type U293 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P293 = PInt\u003cU293\u003e; pub type N293 = NInt\u003cU293\u003e;\n    pub type U294 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P294 = PInt\u003cU294\u003e; pub type N294 = NInt\u003cU294\u003e;\n    pub type U295 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P295 = PInt\u003cU295\u003e; pub type N295 = NInt\u003cU295\u003e;\n    pub type U296 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P296 = PInt\u003cU296\u003e; pub type N296 = NInt\u003cU296\u003e;\n    pub type U297 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P297 = PInt\u003cU297\u003e; pub type N297 = NInt\u003cU297\u003e;\n    pub type U298 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P298 = PInt\u003cU298\u003e; pub type N298 = NInt\u003cU298\u003e;\n    pub type U299 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P299 = PInt\u003cU299\u003e; pub type N299 = NInt\u003cU299\u003e;\n    pub type U300 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P300 = PInt\u003cU300\u003e; pub type N300 = NInt\u003cU300\u003e;\n    pub type U301 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P301 = PInt\u003cU301\u003e; pub type N301 = NInt\u003cU301\u003e;\n    pub type U302 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P302 = PInt\u003cU302\u003e; pub type N302 = NInt\u003cU302\u003e;\n    pub type U303 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P303 = PInt\u003cU303\u003e; pub type N303 = NInt\u003cU303\u003e;\n    pub type U304 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P304 = PInt\u003cU304\u003e; pub type N304 = NInt\u003cU304\u003e;\n    pub type U305 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P305 = PInt\u003cU305\u003e; pub type N305 = NInt\u003cU305\u003e;\n    pub type U306 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P306 = PInt\u003cU306\u003e; pub type N306 = NInt\u003cU306\u003e;\n    pub type U307 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P307 = PInt\u003cU307\u003e; pub type N307 = NInt\u003cU307\u003e;\n    pub type U308 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P308 = PInt\u003cU308\u003e; pub type N308 = NInt\u003cU308\u003e;\n    pub type U309 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P309 = PInt\u003cU309\u003e; pub type N309 = NInt\u003cU309\u003e;\n    pub type U310 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P310 = PInt\u003cU310\u003e; pub type N310 = NInt\u003cU310\u003e;\n    pub type U311 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P311 = PInt\u003cU311\u003e; pub type N311 = NInt\u003cU311\u003e;\n    pub type U312 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P312 = PInt\u003cU312\u003e; pub type N312 = NInt\u003cU312\u003e;\n    pub type U313 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P313 = PInt\u003cU313\u003e; pub type N313 = NInt\u003cU313\u003e;\n    pub type U314 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P314 = PInt\u003cU314\u003e; pub type N314 = NInt\u003cU314\u003e;\n    pub type U315 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P315 = PInt\u003cU315\u003e; pub type N315 = NInt\u003cU315\u003e;\n    pub type U316 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P316 = PInt\u003cU316\u003e; pub type N316 = NInt\u003cU316\u003e;\n    pub type U317 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P317 = PInt\u003cU317\u003e; pub type N317 = NInt\u003cU317\u003e;\n    pub type U318 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P318 = PInt\u003cU318\u003e; pub type N318 = NInt\u003cU318\u003e;\n    pub type U319 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P319 = PInt\u003cU319\u003e; pub type N319 = NInt\u003cU319\u003e;\n    pub type U320 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P320 = PInt\u003cU320\u003e; pub type N320 = NInt\u003cU320\u003e;\n    pub type U321 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P321 = PInt\u003cU321\u003e; pub type N321 = NInt\u003cU321\u003e;\n    pub type U322 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P322 = PInt\u003cU322\u003e; pub type N322 = NInt\u003cU322\u003e;\n    pub type U323 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P323 = PInt\u003cU323\u003e; pub type N323 = NInt\u003cU323\u003e;\n    pub type U324 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P324 = PInt\u003cU324\u003e; pub type N324 = NInt\u003cU324\u003e;\n    pub type U325 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P325 = PInt\u003cU325\u003e; pub type N325 = NInt\u003cU325\u003e;\n    pub type U326 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P326 = PInt\u003cU326\u003e; pub type N326 = NInt\u003cU326\u003e;\n    pub type U327 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P327 = PInt\u003cU327\u003e; pub type N327 = NInt\u003cU327\u003e;\n    pub type U328 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P328 = PInt\u003cU328\u003e; pub type N328 = NInt\u003cU328\u003e;\n    pub type U329 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P329 = PInt\u003cU329\u003e; pub type N329 = NInt\u003cU329\u003e;\n    pub type U330 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P330 = PInt\u003cU330\u003e; pub type N330 = NInt\u003cU330\u003e;\n    pub type U331 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P331 = PInt\u003cU331\u003e; pub type N331 = NInt\u003cU331\u003e;\n    pub type U332 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P332 = PInt\u003cU332\u003e; pub type N332 = NInt\u003cU332\u003e;\n    pub type U333 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P333 = PInt\u003cU333\u003e; pub type N333 = NInt\u003cU333\u003e;\n    pub type U334 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P334 = PInt\u003cU334\u003e; pub type N334 = NInt\u003cU334\u003e;\n    pub type U335 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P335 = PInt\u003cU335\u003e; pub type N335 = NInt\u003cU335\u003e;\n    pub type U336 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P336 = PInt\u003cU336\u003e; pub type N336 = NInt\u003cU336\u003e;\n    pub type U337 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P337 = PInt\u003cU337\u003e; pub type N337 = NInt\u003cU337\u003e;\n    pub type U338 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P338 = PInt\u003cU338\u003e; pub type N338 = NInt\u003cU338\u003e;\n    pub type U339 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P339 = PInt\u003cU339\u003e; pub type N339 = NInt\u003cU339\u003e;\n    pub type U340 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P340 = PInt\u003cU340\u003e; pub type N340 = NInt\u003cU340\u003e;\n    pub type U341 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P341 = PInt\u003cU341\u003e; pub type N341 = NInt\u003cU341\u003e;\n    pub type U342 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P342 = PInt\u003cU342\u003e; pub type N342 = NInt\u003cU342\u003e;\n    pub type U343 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P343 = PInt\u003cU343\u003e; pub type N343 = NInt\u003cU343\u003e;\n    pub type U344 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P344 = PInt\u003cU344\u003e; pub type N344 = NInt\u003cU344\u003e;\n    pub type U345 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P345 = PInt\u003cU345\u003e; pub type N345 = NInt\u003cU345\u003e;\n    pub type U346 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P346 = PInt\u003cU346\u003e; pub type N346 = NInt\u003cU346\u003e;\n    pub type U347 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P347 = PInt\u003cU347\u003e; pub type N347 = NInt\u003cU347\u003e;\n    pub type U348 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P348 = PInt\u003cU348\u003e; pub type N348 = NInt\u003cU348\u003e;\n    pub type U349 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P349 = PInt\u003cU349\u003e; pub type N349 = NInt\u003cU349\u003e;\n    pub type U350 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P350 = PInt\u003cU350\u003e; pub type N350 = NInt\u003cU350\u003e;\n    pub type U351 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P351 = PInt\u003cU351\u003e; pub type N351 = NInt\u003cU351\u003e;\n    pub type U352 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P352 = PInt\u003cU352\u003e; pub type N352 = NInt\u003cU352\u003e;\n    pub type U353 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P353 = PInt\u003cU353\u003e; pub type N353 = NInt\u003cU353\u003e;\n    pub type U354 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P354 = PInt\u003cU354\u003e; pub type N354 = NInt\u003cU354\u003e;\n    pub type U355 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P355 = PInt\u003cU355\u003e; pub type N355 = NInt\u003cU355\u003e;\n    pub type U356 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P356 = PInt\u003cU356\u003e; pub type N356 = NInt\u003cU356\u003e;\n    pub type U357 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P357 = PInt\u003cU357\u003e; pub type N357 = NInt\u003cU357\u003e;\n    pub type U358 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P358 = PInt\u003cU358\u003e; pub type N358 = NInt\u003cU358\u003e;\n    pub type U359 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P359 = PInt\u003cU359\u003e; pub type N359 = NInt\u003cU359\u003e;\n    pub type U360 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P360 = PInt\u003cU360\u003e; pub type N360 = NInt\u003cU360\u003e;\n    pub type U361 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P361 = PInt\u003cU361\u003e; pub type N361 = NInt\u003cU361\u003e;\n    pub type U362 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P362 = PInt\u003cU362\u003e; pub type N362 = NInt\u003cU362\u003e;\n    pub type U363 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P363 = PInt\u003cU363\u003e; pub type N363 = NInt\u003cU363\u003e;\n    pub type U364 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P364 = PInt\u003cU364\u003e; pub type N364 = NInt\u003cU364\u003e;\n    pub type U365 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P365 = PInt\u003cU365\u003e; pub type N365 = NInt\u003cU365\u003e;\n    pub type U366 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P366 = PInt\u003cU366\u003e; pub type N366 = NInt\u003cU366\u003e;\n    pub type U367 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P367 = PInt\u003cU367\u003e; pub type N367 = NInt\u003cU367\u003e;\n    pub type U368 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P368 = PInt\u003cU368\u003e; pub type N368 = NInt\u003cU368\u003e;\n    pub type U369 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P369 = PInt\u003cU369\u003e; pub type N369 = NInt\u003cU369\u003e;\n    pub type U370 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P370 = PInt\u003cU370\u003e; pub type N370 = NInt\u003cU370\u003e;\n    pub type U371 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P371 = PInt\u003cU371\u003e; pub type N371 = NInt\u003cU371\u003e;\n    pub type U372 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P372 = PInt\u003cU372\u003e; pub type N372 = NInt\u003cU372\u003e;\n    pub type U373 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P373 = PInt\u003cU373\u003e; pub type N373 = NInt\u003cU373\u003e;\n    pub type U374 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P374 = PInt\u003cU374\u003e; pub type N374 = NInt\u003cU374\u003e;\n    pub type U375 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P375 = PInt\u003cU375\u003e; pub type N375 = NInt\u003cU375\u003e;\n    pub type U376 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P376 = PInt\u003cU376\u003e; pub type N376 = NInt\u003cU376\u003e;\n    pub type U377 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P377 = PInt\u003cU377\u003e; pub type N377 = NInt\u003cU377\u003e;\n    pub type U378 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P378 = PInt\u003cU378\u003e; pub type N378 = NInt\u003cU378\u003e;\n    pub type U379 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P379 = PInt\u003cU379\u003e; pub type N379 = NInt\u003cU379\u003e;\n    pub type U380 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P380 = PInt\u003cU380\u003e; pub type N380 = NInt\u003cU380\u003e;\n    pub type U381 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P381 = PInt\u003cU381\u003e; pub type N381 = NInt\u003cU381\u003e;\n    pub type U382 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P382 = PInt\u003cU382\u003e; pub type N382 = NInt\u003cU382\u003e;\n    pub type U383 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P383 = PInt\u003cU383\u003e; pub type N383 = NInt\u003cU383\u003e;\n    pub type U384 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P384 = PInt\u003cU384\u003e; pub type N384 = NInt\u003cU384\u003e;\n    pub type U385 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P385 = PInt\u003cU385\u003e; pub type N385 = NInt\u003cU385\u003e;\n    pub type U386 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P386 = PInt\u003cU386\u003e; pub type N386 = NInt\u003cU386\u003e;\n    pub type U387 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P387 = PInt\u003cU387\u003e; pub type N387 = NInt\u003cU387\u003e;\n    pub type U388 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P388 = PInt\u003cU388\u003e; pub type N388 = NInt\u003cU388\u003e;\n    pub type U389 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P389 = PInt\u003cU389\u003e; pub type N389 = NInt\u003cU389\u003e;\n    pub type U390 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P390 = PInt\u003cU390\u003e; pub type N390 = NInt\u003cU390\u003e;\n    pub type U391 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P391 = PInt\u003cU391\u003e; pub type N391 = NInt\u003cU391\u003e;\n    pub type U392 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P392 = PInt\u003cU392\u003e; pub type N392 = NInt\u003cU392\u003e;\n    pub type U393 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P393 = PInt\u003cU393\u003e; pub type N393 = NInt\u003cU393\u003e;\n    pub type U394 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P394 = PInt\u003cU394\u003e; pub type N394 = NInt\u003cU394\u003e;\n    pub type U395 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P395 = PInt\u003cU395\u003e; pub type N395 = NInt\u003cU395\u003e;\n    pub type U396 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P396 = PInt\u003cU396\u003e; pub type N396 = NInt\u003cU396\u003e;\n    pub type U397 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P397 = PInt\u003cU397\u003e; pub type N397 = NInt\u003cU397\u003e;\n    pub type U398 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P398 = PInt\u003cU398\u003e; pub type N398 = NInt\u003cU398\u003e;\n    pub type U399 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P399 = PInt\u003cU399\u003e; pub type N399 = NInt\u003cU399\u003e;\n    pub type U400 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P400 = PInt\u003cU400\u003e; pub type N400 = NInt\u003cU400\u003e;\n    pub type U401 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P401 = PInt\u003cU401\u003e; pub type N401 = NInt\u003cU401\u003e;\n    pub type U402 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P402 = PInt\u003cU402\u003e; pub type N402 = NInt\u003cU402\u003e;\n    pub type U403 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P403 = PInt\u003cU403\u003e; pub type N403 = NInt\u003cU403\u003e;\n    pub type U404 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P404 = PInt\u003cU404\u003e; pub type N404 = NInt\u003cU404\u003e;\n    pub type U405 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P405 = PInt\u003cU405\u003e; pub type N405 = NInt\u003cU405\u003e;\n    pub type U406 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P406 = PInt\u003cU406\u003e; pub type N406 = NInt\u003cU406\u003e;\n    pub type U407 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P407 = PInt\u003cU407\u003e; pub type N407 = NInt\u003cU407\u003e;\n    pub type U408 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P408 = PInt\u003cU408\u003e; pub type N408 = NInt\u003cU408\u003e;\n    pub type U409 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P409 = PInt\u003cU409\u003e; pub type N409 = NInt\u003cU409\u003e;\n    pub type U410 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P410 = PInt\u003cU410\u003e; pub type N410 = NInt\u003cU410\u003e;\n    pub type U411 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P411 = PInt\u003cU411\u003e; pub type N411 = NInt\u003cU411\u003e;\n    pub type U412 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P412 = PInt\u003cU412\u003e; pub type N412 = NInt\u003cU412\u003e;\n    pub type U413 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P413 = PInt\u003cU413\u003e; pub type N413 = NInt\u003cU413\u003e;\n    pub type U414 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P414 = PInt\u003cU414\u003e; pub type N414 = NInt\u003cU414\u003e;\n    pub type U415 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P415 = PInt\u003cU415\u003e; pub type N415 = NInt\u003cU415\u003e;\n    pub type U416 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P416 = PInt\u003cU416\u003e; pub type N416 = NInt\u003cU416\u003e;\n    pub type U417 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P417 = PInt\u003cU417\u003e; pub type N417 = NInt\u003cU417\u003e;\n    pub type U418 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P418 = PInt\u003cU418\u003e; pub type N418 = NInt\u003cU418\u003e;\n    pub type U419 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P419 = PInt\u003cU419\u003e; pub type N419 = NInt\u003cU419\u003e;\n    pub type U420 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P420 = PInt\u003cU420\u003e; pub type N420 = NInt\u003cU420\u003e;\n    pub type U421 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P421 = PInt\u003cU421\u003e; pub type N421 = NInt\u003cU421\u003e;\n    pub type U422 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P422 = PInt\u003cU422\u003e; pub type N422 = NInt\u003cU422\u003e;\n    pub type U423 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P423 = PInt\u003cU423\u003e; pub type N423 = NInt\u003cU423\u003e;\n    pub type U424 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P424 = PInt\u003cU424\u003e; pub type N424 = NInt\u003cU424\u003e;\n    pub type U425 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P425 = PInt\u003cU425\u003e; pub type N425 = NInt\u003cU425\u003e;\n    pub type U426 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P426 = PInt\u003cU426\u003e; pub type N426 = NInt\u003cU426\u003e;\n    pub type U427 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P427 = PInt\u003cU427\u003e; pub type N427 = NInt\u003cU427\u003e;\n    pub type U428 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P428 = PInt\u003cU428\u003e; pub type N428 = NInt\u003cU428\u003e;\n    pub type U429 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P429 = PInt\u003cU429\u003e; pub type N429 = NInt\u003cU429\u003e;\n    pub type U430 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P430 = PInt\u003cU430\u003e; pub type N430 = NInt\u003cU430\u003e;\n    pub type U431 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P431 = PInt\u003cU431\u003e; pub type N431 = NInt\u003cU431\u003e;\n    pub type U432 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P432 = PInt\u003cU432\u003e; pub type N432 = NInt\u003cU432\u003e;\n    pub type U433 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P433 = PInt\u003cU433\u003e; pub type N433 = NInt\u003cU433\u003e;\n    pub type U434 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P434 = PInt\u003cU434\u003e; pub type N434 = NInt\u003cU434\u003e;\n    pub type U435 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P435 = PInt\u003cU435\u003e; pub type N435 = NInt\u003cU435\u003e;\n    pub type U436 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P436 = PInt\u003cU436\u003e; pub type N436 = NInt\u003cU436\u003e;\n    pub type U437 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P437 = PInt\u003cU437\u003e; pub type N437 = NInt\u003cU437\u003e;\n    pub type U438 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P438 = PInt\u003cU438\u003e; pub type N438 = NInt\u003cU438\u003e;\n    pub type U439 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P439 = PInt\u003cU439\u003e; pub type N439 = NInt\u003cU439\u003e;\n    pub type U440 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P440 = PInt\u003cU440\u003e; pub type N440 = NInt\u003cU440\u003e;\n    pub type U441 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P441 = PInt\u003cU441\u003e; pub type N441 = NInt\u003cU441\u003e;\n    pub type U442 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P442 = PInt\u003cU442\u003e; pub type N442 = NInt\u003cU442\u003e;\n    pub type U443 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P443 = PInt\u003cU443\u003e; pub type N443 = NInt\u003cU443\u003e;\n    pub type U444 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P444 = PInt\u003cU444\u003e; pub type N444 = NInt\u003cU444\u003e;\n    pub type U445 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P445 = PInt\u003cU445\u003e; pub type N445 = NInt\u003cU445\u003e;\n    pub type U446 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P446 = PInt\u003cU446\u003e; pub type N446 = NInt\u003cU446\u003e;\n    pub type U447 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P447 = PInt\u003cU447\u003e; pub type N447 = NInt\u003cU447\u003e;\n    pub type U448 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P448 = PInt\u003cU448\u003e; pub type N448 = NInt\u003cU448\u003e;\n    pub type U449 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P449 = PInt\u003cU449\u003e; pub type N449 = NInt\u003cU449\u003e;\n    pub type U450 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P450 = PInt\u003cU450\u003e; pub type N450 = NInt\u003cU450\u003e;\n    pub type U451 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P451 = PInt\u003cU451\u003e; pub type N451 = NInt\u003cU451\u003e;\n    pub type U452 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P452 = PInt\u003cU452\u003e; pub type N452 = NInt\u003cU452\u003e;\n    pub type U453 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P453 = PInt\u003cU453\u003e; pub type N453 = NInt\u003cU453\u003e;\n    pub type U454 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P454 = PInt\u003cU454\u003e; pub type N454 = NInt\u003cU454\u003e;\n    pub type U455 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P455 = PInt\u003cU455\u003e; pub type N455 = NInt\u003cU455\u003e;\n    pub type U456 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P456 = PInt\u003cU456\u003e; pub type N456 = NInt\u003cU456\u003e;\n    pub type U457 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P457 = PInt\u003cU457\u003e; pub type N457 = NInt\u003cU457\u003e;\n    pub type U458 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P458 = PInt\u003cU458\u003e; pub type N458 = NInt\u003cU458\u003e;\n    pub type U459 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P459 = PInt\u003cU459\u003e; pub type N459 = NInt\u003cU459\u003e;\n    pub type U460 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P460 = PInt\u003cU460\u003e; pub type N460 = NInt\u003cU460\u003e;\n    pub type U461 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P461 = PInt\u003cU461\u003e; pub type N461 = NInt\u003cU461\u003e;\n    pub type U462 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P462 = PInt\u003cU462\u003e; pub type N462 = NInt\u003cU462\u003e;\n    pub type U463 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P463 = PInt\u003cU463\u003e; pub type N463 = NInt\u003cU463\u003e;\n    pub type U464 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P464 = PInt\u003cU464\u003e; pub type N464 = NInt\u003cU464\u003e;\n    pub type U465 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P465 = PInt\u003cU465\u003e; pub type N465 = NInt\u003cU465\u003e;\n    pub type U466 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P466 = PInt\u003cU466\u003e; pub type N466 = NInt\u003cU466\u003e;\n    pub type U467 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P467 = PInt\u003cU467\u003e; pub type N467 = NInt\u003cU467\u003e;\n    pub type U468 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P468 = PInt\u003cU468\u003e; pub type N468 = NInt\u003cU468\u003e;\n    pub type U469 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P469 = PInt\u003cU469\u003e; pub type N469 = NInt\u003cU469\u003e;\n    pub type U470 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P470 = PInt\u003cU470\u003e; pub type N470 = NInt\u003cU470\u003e;\n    pub type U471 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P471 = PInt\u003cU471\u003e; pub type N471 = NInt\u003cU471\u003e;\n    pub type U472 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P472 = PInt\u003cU472\u003e; pub type N472 = NInt\u003cU472\u003e;\n    pub type U473 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P473 = PInt\u003cU473\u003e; pub type N473 = NInt\u003cU473\u003e;\n    pub type U474 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P474 = PInt\u003cU474\u003e; pub type N474 = NInt\u003cU474\u003e;\n    pub type U475 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P475 = PInt\u003cU475\u003e; pub type N475 = NInt\u003cU475\u003e;\n    pub type U476 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P476 = PInt\u003cU476\u003e; pub type N476 = NInt\u003cU476\u003e;\n    pub type U477 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P477 = PInt\u003cU477\u003e; pub type N477 = NInt\u003cU477\u003e;\n    pub type U478 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P478 = PInt\u003cU478\u003e; pub type N478 = NInt\u003cU478\u003e;\n    pub type U479 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P479 = PInt\u003cU479\u003e; pub type N479 = NInt\u003cU479\u003e;\n    pub type U480 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P480 = PInt\u003cU480\u003e; pub type N480 = NInt\u003cU480\u003e;\n    pub type U481 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P481 = PInt\u003cU481\u003e; pub type N481 = NInt\u003cU481\u003e;\n    pub type U482 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P482 = PInt\u003cU482\u003e; pub type N482 = NInt\u003cU482\u003e;\n    pub type U483 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P483 = PInt\u003cU483\u003e; pub type N483 = NInt\u003cU483\u003e;\n    pub type U484 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P484 = PInt\u003cU484\u003e; pub type N484 = NInt\u003cU484\u003e;\n    pub type U485 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P485 = PInt\u003cU485\u003e; pub type N485 = NInt\u003cU485\u003e;\n    pub type U486 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P486 = PInt\u003cU486\u003e; pub type N486 = NInt\u003cU486\u003e;\n    pub type U487 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P487 = PInt\u003cU487\u003e; pub type N487 = NInt\u003cU487\u003e;\n    pub type U488 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P488 = PInt\u003cU488\u003e; pub type N488 = NInt\u003cU488\u003e;\n    pub type U489 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P489 = PInt\u003cU489\u003e; pub type N489 = NInt\u003cU489\u003e;\n    pub type U490 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P490 = PInt\u003cU490\u003e; pub type N490 = NInt\u003cU490\u003e;\n    pub type U491 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P491 = PInt\u003cU491\u003e; pub type N491 = NInt\u003cU491\u003e;\n    pub type U492 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P492 = PInt\u003cU492\u003e; pub type N492 = NInt\u003cU492\u003e;\n    pub type U493 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P493 = PInt\u003cU493\u003e; pub type N493 = NInt\u003cU493\u003e;\n    pub type U494 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P494 = PInt\u003cU494\u003e; pub type N494 = NInt\u003cU494\u003e;\n    pub type U495 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P495 = PInt\u003cU495\u003e; pub type N495 = NInt\u003cU495\u003e;\n    pub type U496 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P496 = PInt\u003cU496\u003e; pub type N496 = NInt\u003cU496\u003e;\n    pub type U497 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P497 = PInt\u003cU497\u003e; pub type N497 = NInt\u003cU497\u003e;\n    pub type U498 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P498 = PInt\u003cU498\u003e; pub type N498 = NInt\u003cU498\u003e;\n    pub type U499 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P499 = PInt\u003cU499\u003e; pub type N499 = NInt\u003cU499\u003e;\n    pub type U500 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P500 = PInt\u003cU500\u003e; pub type N500 = NInt\u003cU500\u003e;\n    pub type U501 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P501 = PInt\u003cU501\u003e; pub type N501 = NInt\u003cU501\u003e;\n    pub type U502 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P502 = PInt\u003cU502\u003e; pub type N502 = NInt\u003cU502\u003e;\n    pub type U503 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P503 = PInt\u003cU503\u003e; pub type N503 = NInt\u003cU503\u003e;\n    pub type U504 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P504 = PInt\u003cU504\u003e; pub type N504 = NInt\u003cU504\u003e;\n    pub type U505 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P505 = PInt\u003cU505\u003e; pub type N505 = NInt\u003cU505\u003e;\n    pub type U506 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P506 = PInt\u003cU506\u003e; pub type N506 = NInt\u003cU506\u003e;\n    pub type U507 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P507 = PInt\u003cU507\u003e; pub type N507 = NInt\u003cU507\u003e;\n    pub type U508 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P508 = PInt\u003cU508\u003e; pub type N508 = NInt\u003cU508\u003e;\n    pub type U509 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P509 = PInt\u003cU509\u003e; pub type N509 = NInt\u003cU509\u003e;\n    pub type U510 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P510 = PInt\u003cU510\u003e; pub type N510 = NInt\u003cU510\u003e;\n    pub type U511 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P511 = PInt\u003cU511\u003e; pub type N511 = NInt\u003cU511\u003e;\n    pub type U512 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P512 = PInt\u003cU512\u003e; pub type N512 = NInt\u003cU512\u003e;\n    pub type U513 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P513 = PInt\u003cU513\u003e; pub type N513 = NInt\u003cU513\u003e;\n    pub type U514 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P514 = PInt\u003cU514\u003e; pub type N514 = NInt\u003cU514\u003e;\n    pub type U515 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P515 = PInt\u003cU515\u003e; pub type N515 = NInt\u003cU515\u003e;\n    pub type U516 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P516 = PInt\u003cU516\u003e; pub type N516 = NInt\u003cU516\u003e;\n    pub type U517 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P517 = PInt\u003cU517\u003e; pub type N517 = NInt\u003cU517\u003e;\n    pub type U518 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P518 = PInt\u003cU518\u003e; pub type N518 = NInt\u003cU518\u003e;\n    pub type U519 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P519 = PInt\u003cU519\u003e; pub type N519 = NInt\u003cU519\u003e;\n    pub type U520 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P520 = PInt\u003cU520\u003e; pub type N520 = NInt\u003cU520\u003e;\n    pub type U521 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P521 = PInt\u003cU521\u003e; pub type N521 = NInt\u003cU521\u003e;\n    pub type U522 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P522 = PInt\u003cU522\u003e; pub type N522 = NInt\u003cU522\u003e;\n    pub type U523 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P523 = PInt\u003cU523\u003e; pub type N523 = NInt\u003cU523\u003e;\n    pub type U524 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P524 = PInt\u003cU524\u003e; pub type N524 = NInt\u003cU524\u003e;\n    pub type U525 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P525 = PInt\u003cU525\u003e; pub type N525 = NInt\u003cU525\u003e;\n    pub type U526 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P526 = PInt\u003cU526\u003e; pub type N526 = NInt\u003cU526\u003e;\n    pub type U527 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P527 = PInt\u003cU527\u003e; pub type N527 = NInt\u003cU527\u003e;\n    pub type U528 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P528 = PInt\u003cU528\u003e; pub type N528 = NInt\u003cU528\u003e;\n    pub type U529 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P529 = PInt\u003cU529\u003e; pub type N529 = NInt\u003cU529\u003e;\n    pub type U530 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P530 = PInt\u003cU530\u003e; pub type N530 = NInt\u003cU530\u003e;\n    pub type U531 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P531 = PInt\u003cU531\u003e; pub type N531 = NInt\u003cU531\u003e;\n    pub type U532 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P532 = PInt\u003cU532\u003e; pub type N532 = NInt\u003cU532\u003e;\n    pub type U533 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P533 = PInt\u003cU533\u003e; pub type N533 = NInt\u003cU533\u003e;\n    pub type U534 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P534 = PInt\u003cU534\u003e; pub type N534 = NInt\u003cU534\u003e;\n    pub type U535 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P535 = PInt\u003cU535\u003e; pub type N535 = NInt\u003cU535\u003e;\n    pub type U536 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P536 = PInt\u003cU536\u003e; pub type N536 = NInt\u003cU536\u003e;\n    pub type U537 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P537 = PInt\u003cU537\u003e; pub type N537 = NInt\u003cU537\u003e;\n    pub type U538 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P538 = PInt\u003cU538\u003e; pub type N538 = NInt\u003cU538\u003e;\n    pub type U539 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P539 = PInt\u003cU539\u003e; pub type N539 = NInt\u003cU539\u003e;\n    pub type U540 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P540 = PInt\u003cU540\u003e; pub type N540 = NInt\u003cU540\u003e;\n    pub type U541 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P541 = PInt\u003cU541\u003e; pub type N541 = NInt\u003cU541\u003e;\n    pub type U542 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P542 = PInt\u003cU542\u003e; pub type N542 = NInt\u003cU542\u003e;\n    pub type U543 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P543 = PInt\u003cU543\u003e; pub type N543 = NInt\u003cU543\u003e;\n    pub type U544 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P544 = PInt\u003cU544\u003e; pub type N544 = NInt\u003cU544\u003e;\n    pub type U545 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P545 = PInt\u003cU545\u003e; pub type N545 = NInt\u003cU545\u003e;\n    pub type U546 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P546 = PInt\u003cU546\u003e; pub type N546 = NInt\u003cU546\u003e;\n    pub type U547 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P547 = PInt\u003cU547\u003e; pub type N547 = NInt\u003cU547\u003e;\n    pub type U548 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P548 = PInt\u003cU548\u003e; pub type N548 = NInt\u003cU548\u003e;\n    pub type U549 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P549 = PInt\u003cU549\u003e; pub type N549 = NInt\u003cU549\u003e;\n    pub type U550 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P550 = PInt\u003cU550\u003e; pub type N550 = NInt\u003cU550\u003e;\n    pub type U551 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P551 = PInt\u003cU551\u003e; pub type N551 = NInt\u003cU551\u003e;\n    pub type U552 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P552 = PInt\u003cU552\u003e; pub type N552 = NInt\u003cU552\u003e;\n    pub type U553 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P553 = PInt\u003cU553\u003e; pub type N553 = NInt\u003cU553\u003e;\n    pub type U554 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P554 = PInt\u003cU554\u003e; pub type N554 = NInt\u003cU554\u003e;\n    pub type U555 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P555 = PInt\u003cU555\u003e; pub type N555 = NInt\u003cU555\u003e;\n    pub type U556 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P556 = PInt\u003cU556\u003e; pub type N556 = NInt\u003cU556\u003e;\n    pub type U557 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P557 = PInt\u003cU557\u003e; pub type N557 = NInt\u003cU557\u003e;\n    pub type U558 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P558 = PInt\u003cU558\u003e; pub type N558 = NInt\u003cU558\u003e;\n    pub type U559 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P559 = PInt\u003cU559\u003e; pub type N559 = NInt\u003cU559\u003e;\n    pub type U560 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P560 = PInt\u003cU560\u003e; pub type N560 = NInt\u003cU560\u003e;\n    pub type U561 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P561 = PInt\u003cU561\u003e; pub type N561 = NInt\u003cU561\u003e;\n    pub type U562 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P562 = PInt\u003cU562\u003e; pub type N562 = NInt\u003cU562\u003e;\n    pub type U563 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P563 = PInt\u003cU563\u003e; pub type N563 = NInt\u003cU563\u003e;\n    pub type U564 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P564 = PInt\u003cU564\u003e; pub type N564 = NInt\u003cU564\u003e;\n    pub type U565 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P565 = PInt\u003cU565\u003e; pub type N565 = NInt\u003cU565\u003e;\n    pub type U566 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P566 = PInt\u003cU566\u003e; pub type N566 = NInt\u003cU566\u003e;\n    pub type U567 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P567 = PInt\u003cU567\u003e; pub type N567 = NInt\u003cU567\u003e;\n    pub type U568 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P568 = PInt\u003cU568\u003e; pub type N568 = NInt\u003cU568\u003e;\n    pub type U569 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P569 = PInt\u003cU569\u003e; pub type N569 = NInt\u003cU569\u003e;\n    pub type U570 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P570 = PInt\u003cU570\u003e; pub type N570 = NInt\u003cU570\u003e;\n    pub type U571 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P571 = PInt\u003cU571\u003e; pub type N571 = NInt\u003cU571\u003e;\n    pub type U572 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P572 = PInt\u003cU572\u003e; pub type N572 = NInt\u003cU572\u003e;\n    pub type U573 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P573 = PInt\u003cU573\u003e; pub type N573 = NInt\u003cU573\u003e;\n    pub type U574 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P574 = PInt\u003cU574\u003e; pub type N574 = NInt\u003cU574\u003e;\n    pub type U575 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P575 = PInt\u003cU575\u003e; pub type N575 = NInt\u003cU575\u003e;\n    pub type U576 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P576 = PInt\u003cU576\u003e; pub type N576 = NInt\u003cU576\u003e;\n    pub type U577 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P577 = PInt\u003cU577\u003e; pub type N577 = NInt\u003cU577\u003e;\n    pub type U578 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P578 = PInt\u003cU578\u003e; pub type N578 = NInt\u003cU578\u003e;\n    pub type U579 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P579 = PInt\u003cU579\u003e; pub type N579 = NInt\u003cU579\u003e;\n    pub type U580 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P580 = PInt\u003cU580\u003e; pub type N580 = NInt\u003cU580\u003e;\n    pub type U581 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P581 = PInt\u003cU581\u003e; pub type N581 = NInt\u003cU581\u003e;\n    pub type U582 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P582 = PInt\u003cU582\u003e; pub type N582 = NInt\u003cU582\u003e;\n    pub type U583 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P583 = PInt\u003cU583\u003e; pub type N583 = NInt\u003cU583\u003e;\n    pub type U584 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P584 = PInt\u003cU584\u003e; pub type N584 = NInt\u003cU584\u003e;\n    pub type U585 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P585 = PInt\u003cU585\u003e; pub type N585 = NInt\u003cU585\u003e;\n    pub type U586 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P586 = PInt\u003cU586\u003e; pub type N586 = NInt\u003cU586\u003e;\n    pub type U587 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P587 = PInt\u003cU587\u003e; pub type N587 = NInt\u003cU587\u003e;\n    pub type U588 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P588 = PInt\u003cU588\u003e; pub type N588 = NInt\u003cU588\u003e;\n    pub type U589 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P589 = PInt\u003cU589\u003e; pub type N589 = NInt\u003cU589\u003e;\n    pub type U590 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P590 = PInt\u003cU590\u003e; pub type N590 = NInt\u003cU590\u003e;\n    pub type U591 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P591 = PInt\u003cU591\u003e; pub type N591 = NInt\u003cU591\u003e;\n    pub type U592 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P592 = PInt\u003cU592\u003e; pub type N592 = NInt\u003cU592\u003e;\n    pub type U593 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P593 = PInt\u003cU593\u003e; pub type N593 = NInt\u003cU593\u003e;\n    pub type U594 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P594 = PInt\u003cU594\u003e; pub type N594 = NInt\u003cU594\u003e;\n    pub type U595 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P595 = PInt\u003cU595\u003e; pub type N595 = NInt\u003cU595\u003e;\n    pub type U596 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P596 = PInt\u003cU596\u003e; pub type N596 = NInt\u003cU596\u003e;\n    pub type U597 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P597 = PInt\u003cU597\u003e; pub type N597 = NInt\u003cU597\u003e;\n    pub type U598 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P598 = PInt\u003cU598\u003e; pub type N598 = NInt\u003cU598\u003e;\n    pub type U599 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P599 = PInt\u003cU599\u003e; pub type N599 = NInt\u003cU599\u003e;\n    pub type U600 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P600 = PInt\u003cU600\u003e; pub type N600 = NInt\u003cU600\u003e;\n    pub type U601 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P601 = PInt\u003cU601\u003e; pub type N601 = NInt\u003cU601\u003e;\n    pub type U602 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P602 = PInt\u003cU602\u003e; pub type N602 = NInt\u003cU602\u003e;\n    pub type U603 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P603 = PInt\u003cU603\u003e; pub type N603 = NInt\u003cU603\u003e;\n    pub type U604 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P604 = PInt\u003cU604\u003e; pub type N604 = NInt\u003cU604\u003e;\n    pub type U605 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P605 = PInt\u003cU605\u003e; pub type N605 = NInt\u003cU605\u003e;\n    pub type U606 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P606 = PInt\u003cU606\u003e; pub type N606 = NInt\u003cU606\u003e;\n    pub type U607 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P607 = PInt\u003cU607\u003e; pub type N607 = NInt\u003cU607\u003e;\n    pub type U608 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P608 = PInt\u003cU608\u003e; pub type N608 = NInt\u003cU608\u003e;\n    pub type U609 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P609 = PInt\u003cU609\u003e; pub type N609 = NInt\u003cU609\u003e;\n    pub type U610 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P610 = PInt\u003cU610\u003e; pub type N610 = NInt\u003cU610\u003e;\n    pub type U611 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P611 = PInt\u003cU611\u003e; pub type N611 = NInt\u003cU611\u003e;\n    pub type U612 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P612 = PInt\u003cU612\u003e; pub type N612 = NInt\u003cU612\u003e;\n    pub type U613 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P613 = PInt\u003cU613\u003e; pub type N613 = NInt\u003cU613\u003e;\n    pub type U614 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P614 = PInt\u003cU614\u003e; pub type N614 = NInt\u003cU614\u003e;\n    pub type U615 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P615 = PInt\u003cU615\u003e; pub type N615 = NInt\u003cU615\u003e;\n    pub type U616 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P616 = PInt\u003cU616\u003e; pub type N616 = NInt\u003cU616\u003e;\n    pub type U617 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P617 = PInt\u003cU617\u003e; pub type N617 = NInt\u003cU617\u003e;\n    pub type U618 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P618 = PInt\u003cU618\u003e; pub type N618 = NInt\u003cU618\u003e;\n    pub type U619 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P619 = PInt\u003cU619\u003e; pub type N619 = NInt\u003cU619\u003e;\n    pub type U620 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P620 = PInt\u003cU620\u003e; pub type N620 = NInt\u003cU620\u003e;\n    pub type U621 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P621 = PInt\u003cU621\u003e; pub type N621 = NInt\u003cU621\u003e;\n    pub type U622 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P622 = PInt\u003cU622\u003e; pub type N622 = NInt\u003cU622\u003e;\n    pub type U623 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P623 = PInt\u003cU623\u003e; pub type N623 = NInt\u003cU623\u003e;\n    pub type U624 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P624 = PInt\u003cU624\u003e; pub type N624 = NInt\u003cU624\u003e;\n    pub type U625 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P625 = PInt\u003cU625\u003e; pub type N625 = NInt\u003cU625\u003e;\n    pub type U626 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P626 = PInt\u003cU626\u003e; pub type N626 = NInt\u003cU626\u003e;\n    pub type U627 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P627 = PInt\u003cU627\u003e; pub type N627 = NInt\u003cU627\u003e;\n    pub type U628 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P628 = PInt\u003cU628\u003e; pub type N628 = NInt\u003cU628\u003e;\n    pub type U629 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P629 = PInt\u003cU629\u003e; pub type N629 = NInt\u003cU629\u003e;\n    pub type U630 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P630 = PInt\u003cU630\u003e; pub type N630 = NInt\u003cU630\u003e;\n    pub type U631 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P631 = PInt\u003cU631\u003e; pub type N631 = NInt\u003cU631\u003e;\n    pub type U632 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P632 = PInt\u003cU632\u003e; pub type N632 = NInt\u003cU632\u003e;\n    pub type U633 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P633 = PInt\u003cU633\u003e; pub type N633 = NInt\u003cU633\u003e;\n    pub type U634 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P634 = PInt\u003cU634\u003e; pub type N634 = NInt\u003cU634\u003e;\n    pub type U635 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P635 = PInt\u003cU635\u003e; pub type N635 = NInt\u003cU635\u003e;\n    pub type U636 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P636 = PInt\u003cU636\u003e; pub type N636 = NInt\u003cU636\u003e;\n    pub type U637 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P637 = PInt\u003cU637\u003e; pub type N637 = NInt\u003cU637\u003e;\n    pub type U638 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P638 = PInt\u003cU638\u003e; pub type N638 = NInt\u003cU638\u003e;\n    pub type U639 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P639 = PInt\u003cU639\u003e; pub type N639 = NInt\u003cU639\u003e;\n    pub type U640 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P640 = PInt\u003cU640\u003e; pub type N640 = NInt\u003cU640\u003e;\n    pub type U641 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P641 = PInt\u003cU641\u003e; pub type N641 = NInt\u003cU641\u003e;\n    pub type U642 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P642 = PInt\u003cU642\u003e; pub type N642 = NInt\u003cU642\u003e;\n    pub type U643 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P643 = PInt\u003cU643\u003e; pub type N643 = NInt\u003cU643\u003e;\n    pub type U644 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P644 = PInt\u003cU644\u003e; pub type N644 = NInt\u003cU644\u003e;\n    pub type U645 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P645 = PInt\u003cU645\u003e; pub type N645 = NInt\u003cU645\u003e;\n    pub type U646 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P646 = PInt\u003cU646\u003e; pub type N646 = NInt\u003cU646\u003e;\n    pub type U647 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P647 = PInt\u003cU647\u003e; pub type N647 = NInt\u003cU647\u003e;\n    pub type U648 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P648 = PInt\u003cU648\u003e; pub type N648 = NInt\u003cU648\u003e;\n    pub type U649 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P649 = PInt\u003cU649\u003e; pub type N649 = NInt\u003cU649\u003e;\n    pub type U650 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P650 = PInt\u003cU650\u003e; pub type N650 = NInt\u003cU650\u003e;\n    pub type U651 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P651 = PInt\u003cU651\u003e; pub type N651 = NInt\u003cU651\u003e;\n    pub type U652 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P652 = PInt\u003cU652\u003e; pub type N652 = NInt\u003cU652\u003e;\n    pub type U653 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P653 = PInt\u003cU653\u003e; pub type N653 = NInt\u003cU653\u003e;\n    pub type U654 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P654 = PInt\u003cU654\u003e; pub type N654 = NInt\u003cU654\u003e;\n    pub type U655 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P655 = PInt\u003cU655\u003e; pub type N655 = NInt\u003cU655\u003e;\n    pub type U656 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P656 = PInt\u003cU656\u003e; pub type N656 = NInt\u003cU656\u003e;\n    pub type U657 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P657 = PInt\u003cU657\u003e; pub type N657 = NInt\u003cU657\u003e;\n    pub type U658 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P658 = PInt\u003cU658\u003e; pub type N658 = NInt\u003cU658\u003e;\n    pub type U659 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P659 = PInt\u003cU659\u003e; pub type N659 = NInt\u003cU659\u003e;\n    pub type U660 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P660 = PInt\u003cU660\u003e; pub type N660 = NInt\u003cU660\u003e;\n    pub type U661 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P661 = PInt\u003cU661\u003e; pub type N661 = NInt\u003cU661\u003e;\n    pub type U662 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P662 = PInt\u003cU662\u003e; pub type N662 = NInt\u003cU662\u003e;\n    pub type U663 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P663 = PInt\u003cU663\u003e; pub type N663 = NInt\u003cU663\u003e;\n    pub type U664 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P664 = PInt\u003cU664\u003e; pub type N664 = NInt\u003cU664\u003e;\n    pub type U665 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P665 = PInt\u003cU665\u003e; pub type N665 = NInt\u003cU665\u003e;\n    pub type U666 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P666 = PInt\u003cU666\u003e; pub type N666 = NInt\u003cU666\u003e;\n    pub type U667 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P667 = PInt\u003cU667\u003e; pub type N667 = NInt\u003cU667\u003e;\n    pub type U668 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P668 = PInt\u003cU668\u003e; pub type N668 = NInt\u003cU668\u003e;\n    pub type U669 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P669 = PInt\u003cU669\u003e; pub type N669 = NInt\u003cU669\u003e;\n    pub type U670 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P670 = PInt\u003cU670\u003e; pub type N670 = NInt\u003cU670\u003e;\n    pub type U671 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P671 = PInt\u003cU671\u003e; pub type N671 = NInt\u003cU671\u003e;\n    pub type U672 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P672 = PInt\u003cU672\u003e; pub type N672 = NInt\u003cU672\u003e;\n    pub type U673 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P673 = PInt\u003cU673\u003e; pub type N673 = NInt\u003cU673\u003e;\n    pub type U674 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P674 = PInt\u003cU674\u003e; pub type N674 = NInt\u003cU674\u003e;\n    pub type U675 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P675 = PInt\u003cU675\u003e; pub type N675 = NInt\u003cU675\u003e;\n    pub type U676 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P676 = PInt\u003cU676\u003e; pub type N676 = NInt\u003cU676\u003e;\n    pub type U677 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P677 = PInt\u003cU677\u003e; pub type N677 = NInt\u003cU677\u003e;\n    pub type U678 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P678 = PInt\u003cU678\u003e; pub type N678 = NInt\u003cU678\u003e;\n    pub type U679 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P679 = PInt\u003cU679\u003e; pub type N679 = NInt\u003cU679\u003e;\n    pub type U680 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P680 = PInt\u003cU680\u003e; pub type N680 = NInt\u003cU680\u003e;\n    pub type U681 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P681 = PInt\u003cU681\u003e; pub type N681 = NInt\u003cU681\u003e;\n    pub type U682 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P682 = PInt\u003cU682\u003e; pub type N682 = NInt\u003cU682\u003e;\n    pub type U683 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P683 = PInt\u003cU683\u003e; pub type N683 = NInt\u003cU683\u003e;\n    pub type U684 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P684 = PInt\u003cU684\u003e; pub type N684 = NInt\u003cU684\u003e;\n    pub type U685 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P685 = PInt\u003cU685\u003e; pub type N685 = NInt\u003cU685\u003e;\n    pub type U686 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P686 = PInt\u003cU686\u003e; pub type N686 = NInt\u003cU686\u003e;\n    pub type U687 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P687 = PInt\u003cU687\u003e; pub type N687 = NInt\u003cU687\u003e;\n    pub type U688 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P688 = PInt\u003cU688\u003e; pub type N688 = NInt\u003cU688\u003e;\n    pub type U689 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P689 = PInt\u003cU689\u003e; pub type N689 = NInt\u003cU689\u003e;\n    pub type U690 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P690 = PInt\u003cU690\u003e; pub type N690 = NInt\u003cU690\u003e;\n    pub type U691 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P691 = PInt\u003cU691\u003e; pub type N691 = NInt\u003cU691\u003e;\n    pub type U692 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P692 = PInt\u003cU692\u003e; pub type N692 = NInt\u003cU692\u003e;\n    pub type U693 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P693 = PInt\u003cU693\u003e; pub type N693 = NInt\u003cU693\u003e;\n    pub type U694 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P694 = PInt\u003cU694\u003e; pub type N694 = NInt\u003cU694\u003e;\n    pub type U695 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P695 = PInt\u003cU695\u003e; pub type N695 = NInt\u003cU695\u003e;\n    pub type U696 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P696 = PInt\u003cU696\u003e; pub type N696 = NInt\u003cU696\u003e;\n    pub type U697 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P697 = PInt\u003cU697\u003e; pub type N697 = NInt\u003cU697\u003e;\n    pub type U698 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P698 = PInt\u003cU698\u003e; pub type N698 = NInt\u003cU698\u003e;\n    pub type U699 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P699 = PInt\u003cU699\u003e; pub type N699 = NInt\u003cU699\u003e;\n    pub type U700 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P700 = PInt\u003cU700\u003e; pub type N700 = NInt\u003cU700\u003e;\n    pub type U701 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P701 = PInt\u003cU701\u003e; pub type N701 = NInt\u003cU701\u003e;\n    pub type U702 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P702 = PInt\u003cU702\u003e; pub type N702 = NInt\u003cU702\u003e;\n    pub type U703 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P703 = PInt\u003cU703\u003e; pub type N703 = NInt\u003cU703\u003e;\n    pub type U704 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P704 = PInt\u003cU704\u003e; pub type N704 = NInt\u003cU704\u003e;\n    pub type U705 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P705 = PInt\u003cU705\u003e; pub type N705 = NInt\u003cU705\u003e;\n    pub type U706 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P706 = PInt\u003cU706\u003e; pub type N706 = NInt\u003cU706\u003e;\n    pub type U707 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P707 = PInt\u003cU707\u003e; pub type N707 = NInt\u003cU707\u003e;\n    pub type U708 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P708 = PInt\u003cU708\u003e; pub type N708 = NInt\u003cU708\u003e;\n    pub type U709 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P709 = PInt\u003cU709\u003e; pub type N709 = NInt\u003cU709\u003e;\n    pub type U710 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P710 = PInt\u003cU710\u003e; pub type N710 = NInt\u003cU710\u003e;\n    pub type U711 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P711 = PInt\u003cU711\u003e; pub type N711 = NInt\u003cU711\u003e;\n    pub type U712 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P712 = PInt\u003cU712\u003e; pub type N712 = NInt\u003cU712\u003e;\n    pub type U713 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P713 = PInt\u003cU713\u003e; pub type N713 = NInt\u003cU713\u003e;\n    pub type U714 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P714 = PInt\u003cU714\u003e; pub type N714 = NInt\u003cU714\u003e;\n    pub type U715 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P715 = PInt\u003cU715\u003e; pub type N715 = NInt\u003cU715\u003e;\n    pub type U716 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P716 = PInt\u003cU716\u003e; pub type N716 = NInt\u003cU716\u003e;\n    pub type U717 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P717 = PInt\u003cU717\u003e; pub type N717 = NInt\u003cU717\u003e;\n    pub type U718 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P718 = PInt\u003cU718\u003e; pub type N718 = NInt\u003cU718\u003e;\n    pub type U719 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P719 = PInt\u003cU719\u003e; pub type N719 = NInt\u003cU719\u003e;\n    pub type U720 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P720 = PInt\u003cU720\u003e; pub type N720 = NInt\u003cU720\u003e;\n    pub type U721 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P721 = PInt\u003cU721\u003e; pub type N721 = NInt\u003cU721\u003e;\n    pub type U722 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P722 = PInt\u003cU722\u003e; pub type N722 = NInt\u003cU722\u003e;\n    pub type U723 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P723 = PInt\u003cU723\u003e; pub type N723 = NInt\u003cU723\u003e;\n    pub type U724 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P724 = PInt\u003cU724\u003e; pub type N724 = NInt\u003cU724\u003e;\n    pub type U725 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P725 = PInt\u003cU725\u003e; pub type N725 = NInt\u003cU725\u003e;\n    pub type U726 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P726 = PInt\u003cU726\u003e; pub type N726 = NInt\u003cU726\u003e;\n    pub type U727 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P727 = PInt\u003cU727\u003e; pub type N727 = NInt\u003cU727\u003e;\n    pub type U728 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P728 = PInt\u003cU728\u003e; pub type N728 = NInt\u003cU728\u003e;\n    pub type U729 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P729 = PInt\u003cU729\u003e; pub type N729 = NInt\u003cU729\u003e;\n    pub type U730 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P730 = PInt\u003cU730\u003e; pub type N730 = NInt\u003cU730\u003e;\n    pub type U731 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P731 = PInt\u003cU731\u003e; pub type N731 = NInt\u003cU731\u003e;\n    pub type U732 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P732 = PInt\u003cU732\u003e; pub type N732 = NInt\u003cU732\u003e;\n    pub type U733 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P733 = PInt\u003cU733\u003e; pub type N733 = NInt\u003cU733\u003e;\n    pub type U734 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P734 = PInt\u003cU734\u003e; pub type N734 = NInt\u003cU734\u003e;\n    pub type U735 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P735 = PInt\u003cU735\u003e; pub type N735 = NInt\u003cU735\u003e;\n    pub type U736 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P736 = PInt\u003cU736\u003e; pub type N736 = NInt\u003cU736\u003e;\n    pub type U737 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P737 = PInt\u003cU737\u003e; pub type N737 = NInt\u003cU737\u003e;\n    pub type U738 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P738 = PInt\u003cU738\u003e; pub type N738 = NInt\u003cU738\u003e;\n    pub type U739 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P739 = PInt\u003cU739\u003e; pub type N739 = NInt\u003cU739\u003e;\n    pub type U740 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P740 = PInt\u003cU740\u003e; pub type N740 = NInt\u003cU740\u003e;\n    pub type U741 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P741 = PInt\u003cU741\u003e; pub type N741 = NInt\u003cU741\u003e;\n    pub type U742 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P742 = PInt\u003cU742\u003e; pub type N742 = NInt\u003cU742\u003e;\n    pub type U743 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P743 = PInt\u003cU743\u003e; pub type N743 = NInt\u003cU743\u003e;\n    pub type U744 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P744 = PInt\u003cU744\u003e; pub type N744 = NInt\u003cU744\u003e;\n    pub type U745 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P745 = PInt\u003cU745\u003e; pub type N745 = NInt\u003cU745\u003e;\n    pub type U746 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P746 = PInt\u003cU746\u003e; pub type N746 = NInt\u003cU746\u003e;\n    pub type U747 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P747 = PInt\u003cU747\u003e; pub type N747 = NInt\u003cU747\u003e;\n    pub type U748 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P748 = PInt\u003cU748\u003e; pub type N748 = NInt\u003cU748\u003e;\n    pub type U749 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P749 = PInt\u003cU749\u003e; pub type N749 = NInt\u003cU749\u003e;\n    pub type U750 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P750 = PInt\u003cU750\u003e; pub type N750 = NInt\u003cU750\u003e;\n    pub type U751 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P751 = PInt\u003cU751\u003e; pub type N751 = NInt\u003cU751\u003e;\n    pub type U752 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P752 = PInt\u003cU752\u003e; pub type N752 = NInt\u003cU752\u003e;\n    pub type U753 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P753 = PInt\u003cU753\u003e; pub type N753 = NInt\u003cU753\u003e;\n    pub type U754 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P754 = PInt\u003cU754\u003e; pub type N754 = NInt\u003cU754\u003e;\n    pub type U755 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P755 = PInt\u003cU755\u003e; pub type N755 = NInt\u003cU755\u003e;\n    pub type U756 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P756 = PInt\u003cU756\u003e; pub type N756 = NInt\u003cU756\u003e;\n    pub type U757 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P757 = PInt\u003cU757\u003e; pub type N757 = NInt\u003cU757\u003e;\n    pub type U758 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P758 = PInt\u003cU758\u003e; pub type N758 = NInt\u003cU758\u003e;\n    pub type U759 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P759 = PInt\u003cU759\u003e; pub type N759 = NInt\u003cU759\u003e;\n    pub type U760 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P760 = PInt\u003cU760\u003e; pub type N760 = NInt\u003cU760\u003e;\n    pub type U761 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P761 = PInt\u003cU761\u003e; pub type N761 = NInt\u003cU761\u003e;\n    pub type U762 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P762 = PInt\u003cU762\u003e; pub type N762 = NInt\u003cU762\u003e;\n    pub type U763 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P763 = PInt\u003cU763\u003e; pub type N763 = NInt\u003cU763\u003e;\n    pub type U764 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P764 = PInt\u003cU764\u003e; pub type N764 = NInt\u003cU764\u003e;\n    pub type U765 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P765 = PInt\u003cU765\u003e; pub type N765 = NInt\u003cU765\u003e;\n    pub type U766 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P766 = PInt\u003cU766\u003e; pub type N766 = NInt\u003cU766\u003e;\n    pub type U767 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P767 = PInt\u003cU767\u003e; pub type N767 = NInt\u003cU767\u003e;\n    pub type U768 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P768 = PInt\u003cU768\u003e; pub type N768 = NInt\u003cU768\u003e;\n    pub type U769 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P769 = PInt\u003cU769\u003e; pub type N769 = NInt\u003cU769\u003e;\n    pub type U770 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P770 = PInt\u003cU770\u003e; pub type N770 = NInt\u003cU770\u003e;\n    pub type U771 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P771 = PInt\u003cU771\u003e; pub type N771 = NInt\u003cU771\u003e;\n    pub type U772 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P772 = PInt\u003cU772\u003e; pub type N772 = NInt\u003cU772\u003e;\n    pub type U773 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P773 = PInt\u003cU773\u003e; pub type N773 = NInt\u003cU773\u003e;\n    pub type U774 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P774 = PInt\u003cU774\u003e; pub type N774 = NInt\u003cU774\u003e;\n    pub type U775 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P775 = PInt\u003cU775\u003e; pub type N775 = NInt\u003cU775\u003e;\n    pub type U776 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P776 = PInt\u003cU776\u003e; pub type N776 = NInt\u003cU776\u003e;\n    pub type U777 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P777 = PInt\u003cU777\u003e; pub type N777 = NInt\u003cU777\u003e;\n    pub type U778 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P778 = PInt\u003cU778\u003e; pub type N778 = NInt\u003cU778\u003e;\n    pub type U779 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P779 = PInt\u003cU779\u003e; pub type N779 = NInt\u003cU779\u003e;\n    pub type U780 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P780 = PInt\u003cU780\u003e; pub type N780 = NInt\u003cU780\u003e;\n    pub type U781 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P781 = PInt\u003cU781\u003e; pub type N781 = NInt\u003cU781\u003e;\n    pub type U782 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P782 = PInt\u003cU782\u003e; pub type N782 = NInt\u003cU782\u003e;\n    pub type U783 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P783 = PInt\u003cU783\u003e; pub type N783 = NInt\u003cU783\u003e;\n    pub type U784 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P784 = PInt\u003cU784\u003e; pub type N784 = NInt\u003cU784\u003e;\n    pub type U785 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P785 = PInt\u003cU785\u003e; pub type N785 = NInt\u003cU785\u003e;\n    pub type U786 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P786 = PInt\u003cU786\u003e; pub type N786 = NInt\u003cU786\u003e;\n    pub type U787 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P787 = PInt\u003cU787\u003e; pub type N787 = NInt\u003cU787\u003e;\n    pub type U788 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P788 = PInt\u003cU788\u003e; pub type N788 = NInt\u003cU788\u003e;\n    pub type U789 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P789 = PInt\u003cU789\u003e; pub type N789 = NInt\u003cU789\u003e;\n    pub type U790 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P790 = PInt\u003cU790\u003e; pub type N790 = NInt\u003cU790\u003e;\n    pub type U791 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P791 = PInt\u003cU791\u003e; pub type N791 = NInt\u003cU791\u003e;\n    pub type U792 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P792 = PInt\u003cU792\u003e; pub type N792 = NInt\u003cU792\u003e;\n    pub type U793 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P793 = PInt\u003cU793\u003e; pub type N793 = NInt\u003cU793\u003e;\n    pub type U794 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P794 = PInt\u003cU794\u003e; pub type N794 = NInt\u003cU794\u003e;\n    pub type U795 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P795 = PInt\u003cU795\u003e; pub type N795 = NInt\u003cU795\u003e;\n    pub type U796 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P796 = PInt\u003cU796\u003e; pub type N796 = NInt\u003cU796\u003e;\n    pub type U797 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P797 = PInt\u003cU797\u003e; pub type N797 = NInt\u003cU797\u003e;\n    pub type U798 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P798 = PInt\u003cU798\u003e; pub type N798 = NInt\u003cU798\u003e;\n    pub type U799 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P799 = PInt\u003cU799\u003e; pub type N799 = NInt\u003cU799\u003e;\n    pub type U800 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P800 = PInt\u003cU800\u003e; pub type N800 = NInt\u003cU800\u003e;\n    pub type U801 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P801 = PInt\u003cU801\u003e; pub type N801 = NInt\u003cU801\u003e;\n    pub type U802 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P802 = PInt\u003cU802\u003e; pub type N802 = NInt\u003cU802\u003e;\n    pub type U803 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P803 = PInt\u003cU803\u003e; pub type N803 = NInt\u003cU803\u003e;\n    pub type U804 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P804 = PInt\u003cU804\u003e; pub type N804 = NInt\u003cU804\u003e;\n    pub type U805 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P805 = PInt\u003cU805\u003e; pub type N805 = NInt\u003cU805\u003e;\n    pub type U806 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P806 = PInt\u003cU806\u003e; pub type N806 = NInt\u003cU806\u003e;\n    pub type U807 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P807 = PInt\u003cU807\u003e; pub type N807 = NInt\u003cU807\u003e;\n    pub type U808 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P808 = PInt\u003cU808\u003e; pub type N808 = NInt\u003cU808\u003e;\n    pub type U809 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P809 = PInt\u003cU809\u003e; pub type N809 = NInt\u003cU809\u003e;\n    pub type U810 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P810 = PInt\u003cU810\u003e; pub type N810 = NInt\u003cU810\u003e;\n    pub type U811 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P811 = PInt\u003cU811\u003e; pub type N811 = NInt\u003cU811\u003e;\n    pub type U812 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P812 = PInt\u003cU812\u003e; pub type N812 = NInt\u003cU812\u003e;\n    pub type U813 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P813 = PInt\u003cU813\u003e; pub type N813 = NInt\u003cU813\u003e;\n    pub type U814 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P814 = PInt\u003cU814\u003e; pub type N814 = NInt\u003cU814\u003e;\n    pub type U815 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P815 = PInt\u003cU815\u003e; pub type N815 = NInt\u003cU815\u003e;\n    pub type U816 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P816 = PInt\u003cU816\u003e; pub type N816 = NInt\u003cU816\u003e;\n    pub type U817 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P817 = PInt\u003cU817\u003e; pub type N817 = NInt\u003cU817\u003e;\n    pub type U818 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P818 = PInt\u003cU818\u003e; pub type N818 = NInt\u003cU818\u003e;\n    pub type U819 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P819 = PInt\u003cU819\u003e; pub type N819 = NInt\u003cU819\u003e;\n    pub type U820 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P820 = PInt\u003cU820\u003e; pub type N820 = NInt\u003cU820\u003e;\n    pub type U821 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P821 = PInt\u003cU821\u003e; pub type N821 = NInt\u003cU821\u003e;\n    pub type U822 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P822 = PInt\u003cU822\u003e; pub type N822 = NInt\u003cU822\u003e;\n    pub type U823 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P823 = PInt\u003cU823\u003e; pub type N823 = NInt\u003cU823\u003e;\n    pub type U824 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P824 = PInt\u003cU824\u003e; pub type N824 = NInt\u003cU824\u003e;\n    pub type U825 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P825 = PInt\u003cU825\u003e; pub type N825 = NInt\u003cU825\u003e;\n    pub type U826 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P826 = PInt\u003cU826\u003e; pub type N826 = NInt\u003cU826\u003e;\n    pub type U827 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P827 = PInt\u003cU827\u003e; pub type N827 = NInt\u003cU827\u003e;\n    pub type U828 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P828 = PInt\u003cU828\u003e; pub type N828 = NInt\u003cU828\u003e;\n    pub type U829 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P829 = PInt\u003cU829\u003e; pub type N829 = NInt\u003cU829\u003e;\n    pub type U830 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P830 = PInt\u003cU830\u003e; pub type N830 = NInt\u003cU830\u003e;\n    pub type U831 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P831 = PInt\u003cU831\u003e; pub type N831 = NInt\u003cU831\u003e;\n    pub type U832 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P832 = PInt\u003cU832\u003e; pub type N832 = NInt\u003cU832\u003e;\n    pub type U833 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P833 = PInt\u003cU833\u003e; pub type N833 = NInt\u003cU833\u003e;\n    pub type U834 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P834 = PInt\u003cU834\u003e; pub type N834 = NInt\u003cU834\u003e;\n    pub type U835 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P835 = PInt\u003cU835\u003e; pub type N835 = NInt\u003cU835\u003e;\n    pub type U836 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P836 = PInt\u003cU836\u003e; pub type N836 = NInt\u003cU836\u003e;\n    pub type U837 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P837 = PInt\u003cU837\u003e; pub type N837 = NInt\u003cU837\u003e;\n    pub type U838 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P838 = PInt\u003cU838\u003e; pub type N838 = NInt\u003cU838\u003e;\n    pub type U839 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P839 = PInt\u003cU839\u003e; pub type N839 = NInt\u003cU839\u003e;\n    pub type U840 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P840 = PInt\u003cU840\u003e; pub type N840 = NInt\u003cU840\u003e;\n    pub type U841 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P841 = PInt\u003cU841\u003e; pub type N841 = NInt\u003cU841\u003e;\n    pub type U842 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P842 = PInt\u003cU842\u003e; pub type N842 = NInt\u003cU842\u003e;\n    pub type U843 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P843 = PInt\u003cU843\u003e; pub type N843 = NInt\u003cU843\u003e;\n    pub type U844 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P844 = PInt\u003cU844\u003e; pub type N844 = NInt\u003cU844\u003e;\n    pub type U845 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P845 = PInt\u003cU845\u003e; pub type N845 = NInt\u003cU845\u003e;\n    pub type U846 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P846 = PInt\u003cU846\u003e; pub type N846 = NInt\u003cU846\u003e;\n    pub type U847 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P847 = PInt\u003cU847\u003e; pub type N847 = NInt\u003cU847\u003e;\n    pub type U848 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P848 = PInt\u003cU848\u003e; pub type N848 = NInt\u003cU848\u003e;\n    pub type U849 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P849 = PInt\u003cU849\u003e; pub type N849 = NInt\u003cU849\u003e;\n    pub type U850 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P850 = PInt\u003cU850\u003e; pub type N850 = NInt\u003cU850\u003e;\n    pub type U851 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P851 = PInt\u003cU851\u003e; pub type N851 = NInt\u003cU851\u003e;\n    pub type U852 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P852 = PInt\u003cU852\u003e; pub type N852 = NInt\u003cU852\u003e;\n    pub type U853 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P853 = PInt\u003cU853\u003e; pub type N853 = NInt\u003cU853\u003e;\n    pub type U854 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P854 = PInt\u003cU854\u003e; pub type N854 = NInt\u003cU854\u003e;\n    pub type U855 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P855 = PInt\u003cU855\u003e; pub type N855 = NInt\u003cU855\u003e;\n    pub type U856 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P856 = PInt\u003cU856\u003e; pub type N856 = NInt\u003cU856\u003e;\n    pub type U857 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P857 = PInt\u003cU857\u003e; pub type N857 = NInt\u003cU857\u003e;\n    pub type U858 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P858 = PInt\u003cU858\u003e; pub type N858 = NInt\u003cU858\u003e;\n    pub type U859 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P859 = PInt\u003cU859\u003e; pub type N859 = NInt\u003cU859\u003e;\n    pub type U860 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P860 = PInt\u003cU860\u003e; pub type N860 = NInt\u003cU860\u003e;\n    pub type U861 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P861 = PInt\u003cU861\u003e; pub type N861 = NInt\u003cU861\u003e;\n    pub type U862 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P862 = PInt\u003cU862\u003e; pub type N862 = NInt\u003cU862\u003e;\n    pub type U863 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P863 = PInt\u003cU863\u003e; pub type N863 = NInt\u003cU863\u003e;\n    pub type U864 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P864 = PInt\u003cU864\u003e; pub type N864 = NInt\u003cU864\u003e;\n    pub type U865 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P865 = PInt\u003cU865\u003e; pub type N865 = NInt\u003cU865\u003e;\n    pub type U866 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P866 = PInt\u003cU866\u003e; pub type N866 = NInt\u003cU866\u003e;\n    pub type U867 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P867 = PInt\u003cU867\u003e; pub type N867 = NInt\u003cU867\u003e;\n    pub type U868 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P868 = PInt\u003cU868\u003e; pub type N868 = NInt\u003cU868\u003e;\n    pub type U869 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P869 = PInt\u003cU869\u003e; pub type N869 = NInt\u003cU869\u003e;\n    pub type U870 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P870 = PInt\u003cU870\u003e; pub type N870 = NInt\u003cU870\u003e;\n    pub type U871 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P871 = PInt\u003cU871\u003e; pub type N871 = NInt\u003cU871\u003e;\n    pub type U872 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P872 = PInt\u003cU872\u003e; pub type N872 = NInt\u003cU872\u003e;\n    pub type U873 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P873 = PInt\u003cU873\u003e; pub type N873 = NInt\u003cU873\u003e;\n    pub type U874 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P874 = PInt\u003cU874\u003e; pub type N874 = NInt\u003cU874\u003e;\n    pub type U875 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P875 = PInt\u003cU875\u003e; pub type N875 = NInt\u003cU875\u003e;\n    pub type U876 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P876 = PInt\u003cU876\u003e; pub type N876 = NInt\u003cU876\u003e;\n    pub type U877 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P877 = PInt\u003cU877\u003e; pub type N877 = NInt\u003cU877\u003e;\n    pub type U878 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P878 = PInt\u003cU878\u003e; pub type N878 = NInt\u003cU878\u003e;\n    pub type U879 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P879 = PInt\u003cU879\u003e; pub type N879 = NInt\u003cU879\u003e;\n    pub type U880 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P880 = PInt\u003cU880\u003e; pub type N880 = NInt\u003cU880\u003e;\n    pub type U881 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P881 = PInt\u003cU881\u003e; pub type N881 = NInt\u003cU881\u003e;\n    pub type U882 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P882 = PInt\u003cU882\u003e; pub type N882 = NInt\u003cU882\u003e;\n    pub type U883 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P883 = PInt\u003cU883\u003e; pub type N883 = NInt\u003cU883\u003e;\n    pub type U884 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P884 = PInt\u003cU884\u003e; pub type N884 = NInt\u003cU884\u003e;\n    pub type U885 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P885 = PInt\u003cU885\u003e; pub type N885 = NInt\u003cU885\u003e;\n    pub type U886 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P886 = PInt\u003cU886\u003e; pub type N886 = NInt\u003cU886\u003e;\n    pub type U887 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P887 = PInt\u003cU887\u003e; pub type N887 = NInt\u003cU887\u003e;\n    pub type U888 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P888 = PInt\u003cU888\u003e; pub type N888 = NInt\u003cU888\u003e;\n    pub type U889 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P889 = PInt\u003cU889\u003e; pub type N889 = NInt\u003cU889\u003e;\n    pub type U890 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P890 = PInt\u003cU890\u003e; pub type N890 = NInt\u003cU890\u003e;\n    pub type U891 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P891 = PInt\u003cU891\u003e; pub type N891 = NInt\u003cU891\u003e;\n    pub type U892 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P892 = PInt\u003cU892\u003e; pub type N892 = NInt\u003cU892\u003e;\n    pub type U893 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P893 = PInt\u003cU893\u003e; pub type N893 = NInt\u003cU893\u003e;\n    pub type U894 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P894 = PInt\u003cU894\u003e; pub type N894 = NInt\u003cU894\u003e;\n    pub type U895 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P895 = PInt\u003cU895\u003e; pub type N895 = NInt\u003cU895\u003e;\n    pub type U896 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P896 = PInt\u003cU896\u003e; pub type N896 = NInt\u003cU896\u003e;\n    pub type U897 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P897 = PInt\u003cU897\u003e; pub type N897 = NInt\u003cU897\u003e;\n    pub type U898 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P898 = PInt\u003cU898\u003e; pub type N898 = NInt\u003cU898\u003e;\n    pub type U899 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P899 = PInt\u003cU899\u003e; pub type N899 = NInt\u003cU899\u003e;\n    pub type U900 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P900 = PInt\u003cU900\u003e; pub type N900 = NInt\u003cU900\u003e;\n    pub type U901 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P901 = PInt\u003cU901\u003e; pub type N901 = NInt\u003cU901\u003e;\n    pub type U902 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P902 = PInt\u003cU902\u003e; pub type N902 = NInt\u003cU902\u003e;\n    pub type U903 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P903 = PInt\u003cU903\u003e; pub type N903 = NInt\u003cU903\u003e;\n    pub type U904 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P904 = PInt\u003cU904\u003e; pub type N904 = NInt\u003cU904\u003e;\n    pub type U905 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P905 = PInt\u003cU905\u003e; pub type N905 = NInt\u003cU905\u003e;\n    pub type U906 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P906 = PInt\u003cU906\u003e; pub type N906 = NInt\u003cU906\u003e;\n    pub type U907 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P907 = PInt\u003cU907\u003e; pub type N907 = NInt\u003cU907\u003e;\n    pub type U908 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P908 = PInt\u003cU908\u003e; pub type N908 = NInt\u003cU908\u003e;\n    pub type U909 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P909 = PInt\u003cU909\u003e; pub type N909 = NInt\u003cU909\u003e;\n    pub type U910 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P910 = PInt\u003cU910\u003e; pub type N910 = NInt\u003cU910\u003e;\n    pub type U911 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P911 = PInt\u003cU911\u003e; pub type N911 = NInt\u003cU911\u003e;\n    pub type U912 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P912 = PInt\u003cU912\u003e; pub type N912 = NInt\u003cU912\u003e;\n    pub type U913 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P913 = PInt\u003cU913\u003e; pub type N913 = NInt\u003cU913\u003e;\n    pub type U914 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P914 = PInt\u003cU914\u003e; pub type N914 = NInt\u003cU914\u003e;\n    pub type U915 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P915 = PInt\u003cU915\u003e; pub type N915 = NInt\u003cU915\u003e;\n    pub type U916 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P916 = PInt\u003cU916\u003e; pub type N916 = NInt\u003cU916\u003e;\n    pub type U917 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P917 = PInt\u003cU917\u003e; pub type N917 = NInt\u003cU917\u003e;\n    pub type U918 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P918 = PInt\u003cU918\u003e; pub type N918 = NInt\u003cU918\u003e;\n    pub type U919 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P919 = PInt\u003cU919\u003e; pub type N919 = NInt\u003cU919\u003e;\n    pub type U920 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P920 = PInt\u003cU920\u003e; pub type N920 = NInt\u003cU920\u003e;\n    pub type U921 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P921 = PInt\u003cU921\u003e; pub type N921 = NInt\u003cU921\u003e;\n    pub type U922 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P922 = PInt\u003cU922\u003e; pub type N922 = NInt\u003cU922\u003e;\n    pub type U923 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P923 = PInt\u003cU923\u003e; pub type N923 = NInt\u003cU923\u003e;\n    pub type U924 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P924 = PInt\u003cU924\u003e; pub type N924 = NInt\u003cU924\u003e;\n    pub type U925 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P925 = PInt\u003cU925\u003e; pub type N925 = NInt\u003cU925\u003e;\n    pub type U926 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P926 = PInt\u003cU926\u003e; pub type N926 = NInt\u003cU926\u003e;\n    pub type U927 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P927 = PInt\u003cU927\u003e; pub type N927 = NInt\u003cU927\u003e;\n    pub type U928 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P928 = PInt\u003cU928\u003e; pub type N928 = NInt\u003cU928\u003e;\n    pub type U929 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P929 = PInt\u003cU929\u003e; pub type N929 = NInt\u003cU929\u003e;\n    pub type U930 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P930 = PInt\u003cU930\u003e; pub type N930 = NInt\u003cU930\u003e;\n    pub type U931 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P931 = PInt\u003cU931\u003e; pub type N931 = NInt\u003cU931\u003e;\n    pub type U932 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P932 = PInt\u003cU932\u003e; pub type N932 = NInt\u003cU932\u003e;\n    pub type U933 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P933 = PInt\u003cU933\u003e; pub type N933 = NInt\u003cU933\u003e;\n    pub type U934 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P934 = PInt\u003cU934\u003e; pub type N934 = NInt\u003cU934\u003e;\n    pub type U935 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P935 = PInt\u003cU935\u003e; pub type N935 = NInt\u003cU935\u003e;\n    pub type U936 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P936 = PInt\u003cU936\u003e; pub type N936 = NInt\u003cU936\u003e;\n    pub type U937 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P937 = PInt\u003cU937\u003e; pub type N937 = NInt\u003cU937\u003e;\n    pub type U938 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P938 = PInt\u003cU938\u003e; pub type N938 = NInt\u003cU938\u003e;\n    pub type U939 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P939 = PInt\u003cU939\u003e; pub type N939 = NInt\u003cU939\u003e;\n    pub type U940 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P940 = PInt\u003cU940\u003e; pub type N940 = NInt\u003cU940\u003e;\n    pub type U941 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P941 = PInt\u003cU941\u003e; pub type N941 = NInt\u003cU941\u003e;\n    pub type U942 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P942 = PInt\u003cU942\u003e; pub type N942 = NInt\u003cU942\u003e;\n    pub type U943 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P943 = PInt\u003cU943\u003e; pub type N943 = NInt\u003cU943\u003e;\n    pub type U944 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P944 = PInt\u003cU944\u003e; pub type N944 = NInt\u003cU944\u003e;\n    pub type U945 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P945 = PInt\u003cU945\u003e; pub type N945 = NInt\u003cU945\u003e;\n    pub type U946 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P946 = PInt\u003cU946\u003e; pub type N946 = NInt\u003cU946\u003e;\n    pub type U947 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P947 = PInt\u003cU947\u003e; pub type N947 = NInt\u003cU947\u003e;\n    pub type U948 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P948 = PInt\u003cU948\u003e; pub type N948 = NInt\u003cU948\u003e;\n    pub type U949 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P949 = PInt\u003cU949\u003e; pub type N949 = NInt\u003cU949\u003e;\n    pub type U950 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P950 = PInt\u003cU950\u003e; pub type N950 = NInt\u003cU950\u003e;\n    pub type U951 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P951 = PInt\u003cU951\u003e; pub type N951 = NInt\u003cU951\u003e;\n    pub type U952 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P952 = PInt\u003cU952\u003e; pub type N952 = NInt\u003cU952\u003e;\n    pub type U953 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P953 = PInt\u003cU953\u003e; pub type N953 = NInt\u003cU953\u003e;\n    pub type U954 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P954 = PInt\u003cU954\u003e; pub type N954 = NInt\u003cU954\u003e;\n    pub type U955 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P955 = PInt\u003cU955\u003e; pub type N955 = NInt\u003cU955\u003e;\n    pub type U956 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P956 = PInt\u003cU956\u003e; pub type N956 = NInt\u003cU956\u003e;\n    pub type U957 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P957 = PInt\u003cU957\u003e; pub type N957 = NInt\u003cU957\u003e;\n    pub type U958 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P958 = PInt\u003cU958\u003e; pub type N958 = NInt\u003cU958\u003e;\n    pub type U959 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P959 = PInt\u003cU959\u003e; pub type N959 = NInt\u003cU959\u003e;\n    pub type U960 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P960 = PInt\u003cU960\u003e; pub type N960 = NInt\u003cU960\u003e;\n    pub type U961 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P961 = PInt\u003cU961\u003e; pub type N961 = NInt\u003cU961\u003e;\n    pub type U962 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P962 = PInt\u003cU962\u003e; pub type N962 = NInt\u003cU962\u003e;\n    pub type U963 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P963 = PInt\u003cU963\u003e; pub type N963 = NInt\u003cU963\u003e;\n    pub type U964 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P964 = PInt\u003cU964\u003e; pub type N964 = NInt\u003cU964\u003e;\n    pub type U965 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P965 = PInt\u003cU965\u003e; pub type N965 = NInt\u003cU965\u003e;\n    pub type U966 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P966 = PInt\u003cU966\u003e; pub type N966 = NInt\u003cU966\u003e;\n    pub type U967 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P967 = PInt\u003cU967\u003e; pub type N967 = NInt\u003cU967\u003e;\n    pub type U968 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P968 = PInt\u003cU968\u003e; pub type N968 = NInt\u003cU968\u003e;\n    pub type U969 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P969 = PInt\u003cU969\u003e; pub type N969 = NInt\u003cU969\u003e;\n    pub type U970 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P970 = PInt\u003cU970\u003e; pub type N970 = NInt\u003cU970\u003e;\n    pub type U971 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P971 = PInt\u003cU971\u003e; pub type N971 = NInt\u003cU971\u003e;\n    pub type U972 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P972 = PInt\u003cU972\u003e; pub type N972 = NInt\u003cU972\u003e;\n    pub type U973 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P973 = PInt\u003cU973\u003e; pub type N973 = NInt\u003cU973\u003e;\n    pub type U974 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P974 = PInt\u003cU974\u003e; pub type N974 = NInt\u003cU974\u003e;\n    pub type U975 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P975 = PInt\u003cU975\u003e; pub type N975 = NInt\u003cU975\u003e;\n    pub type U976 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P976 = PInt\u003cU976\u003e; pub type N976 = NInt\u003cU976\u003e;\n    pub type U977 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P977 = PInt\u003cU977\u003e; pub type N977 = NInt\u003cU977\u003e;\n    pub type U978 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P978 = PInt\u003cU978\u003e; pub type N978 = NInt\u003cU978\u003e;\n    pub type U979 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P979 = PInt\u003cU979\u003e; pub type N979 = NInt\u003cU979\u003e;\n    pub type U980 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P980 = PInt\u003cU980\u003e; pub type N980 = NInt\u003cU980\u003e;\n    pub type U981 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P981 = PInt\u003cU981\u003e; pub type N981 = NInt\u003cU981\u003e;\n    pub type U982 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P982 = PInt\u003cU982\u003e; pub type N982 = NInt\u003cU982\u003e;\n    pub type U983 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P983 = PInt\u003cU983\u003e; pub type N983 = NInt\u003cU983\u003e;\n    pub type U984 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P984 = PInt\u003cU984\u003e; pub type N984 = NInt\u003cU984\u003e;\n    pub type U985 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P985 = PInt\u003cU985\u003e; pub type N985 = NInt\u003cU985\u003e;\n    pub type U986 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P986 = PInt\u003cU986\u003e; pub type N986 = NInt\u003cU986\u003e;\n    pub type U987 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P987 = PInt\u003cU987\u003e; pub type N987 = NInt\u003cU987\u003e;\n    pub type U988 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P988 = PInt\u003cU988\u003e; pub type N988 = NInt\u003cU988\u003e;\n    pub type U989 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P989 = PInt\u003cU989\u003e; pub type N989 = NInt\u003cU989\u003e;\n    pub type U990 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P990 = PInt\u003cU990\u003e; pub type N990 = NInt\u003cU990\u003e;\n    pub type U991 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P991 = PInt\u003cU991\u003e; pub type N991 = NInt\u003cU991\u003e;\n    pub type U992 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P992 = PInt\u003cU992\u003e; pub type N992 = NInt\u003cU992\u003e;\n    pub type U993 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P993 = PInt\u003cU993\u003e; pub type N993 = NInt\u003cU993\u003e;\n    pub type U994 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P994 = PInt\u003cU994\u003e; pub type N994 = NInt\u003cU994\u003e;\n    pub type U995 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P995 = PInt\u003cU995\u003e; pub type N995 = NInt\u003cU995\u003e;\n    pub type U996 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P996 = PInt\u003cU996\u003e; pub type N996 = NInt\u003cU996\u003e;\n    pub type U997 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P997 = PInt\u003cU997\u003e; pub type N997 = NInt\u003cU997\u003e;\n    pub type U998 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P998 = PInt\u003cU998\u003e; pub type N998 = NInt\u003cU998\u003e;\n    pub type U999 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P999 = PInt\u003cU999\u003e; pub type N999 = NInt\u003cU999\u003e;\n    pub type U1000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000 = PInt\u003cU1000\u003e; pub type N1000 = NInt\u003cU1000\u003e;\n    pub type U1001 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P1001 = PInt\u003cU1001\u003e; pub type N1001 = NInt\u003cU1001\u003e;\n    pub type U1002 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P1002 = PInt\u003cU1002\u003e; pub type N1002 = NInt\u003cU1002\u003e;\n    pub type U1003 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P1003 = PInt\u003cU1003\u003e; pub type N1003 = NInt\u003cU1003\u003e;\n    pub type U1004 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P1004 = PInt\u003cU1004\u003e; pub type N1004 = NInt\u003cU1004\u003e;\n    pub type U1005 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P1005 = PInt\u003cU1005\u003e; pub type N1005 = NInt\u003cU1005\u003e;\n    pub type U1006 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P1006 = PInt\u003cU1006\u003e; pub type N1006 = NInt\u003cU1006\u003e;\n    pub type U1007 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P1007 = PInt\u003cU1007\u003e; pub type N1007 = NInt\u003cU1007\u003e;\n    pub type U1008 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1008 = PInt\u003cU1008\u003e; pub type N1008 = NInt\u003cU1008\u003e;\n    pub type U1009 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P1009 = PInt\u003cU1009\u003e; pub type N1009 = NInt\u003cU1009\u003e;\n    pub type U1010 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P1010 = PInt\u003cU1010\u003e; pub type N1010 = NInt\u003cU1010\u003e;\n    pub type U1011 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P1011 = PInt\u003cU1011\u003e; pub type N1011 = NInt\u003cU1011\u003e;\n    pub type U1012 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P1012 = PInt\u003cU1012\u003e; pub type N1012 = NInt\u003cU1012\u003e;\n    pub type U1013 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P1013 = PInt\u003cU1013\u003e; pub type N1013 = NInt\u003cU1013\u003e;\n    pub type U1014 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P1014 = PInt\u003cU1014\u003e; pub type N1014 = NInt\u003cU1014\u003e;\n    pub type U1015 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P1015 = PInt\u003cU1015\u003e; pub type N1015 = NInt\u003cU1015\u003e;\n    pub type U1016 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1016 = PInt\u003cU1016\u003e; pub type N1016 = NInt\u003cU1016\u003e;\n    pub type U1017 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n    pub type P1017 = PInt\u003cU1017\u003e; pub type N1017 = NInt\u003cU1017\u003e;\n    pub type U1018 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n    pub type P1018 = PInt\u003cU1018\u003e; pub type N1018 = NInt\u003cU1018\u003e;\n    pub type U1019 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n    pub type P1019 = PInt\u003cU1019\u003e; pub type N1019 = NInt\u003cU1019\u003e;\n    pub type U1020 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n    pub type P1020 = PInt\u003cU1020\u003e; pub type N1020 = NInt\u003cU1020\u003e;\n    pub type U1021 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n    pub type P1021 = PInt\u003cU1021\u003e; pub type N1021 = NInt\u003cU1021\u003e;\n    pub type U1022 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e;\n    pub type P1022 = PInt\u003cU1022\u003e; pub type N1022 = NInt\u003cU1022\u003e;\n    pub type U1023 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n    pub type P1023 = PInt\u003cU1023\u003e; pub type N1023 = NInt\u003cU1023\u003e;\n    pub type U1024 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1024 = PInt\u003cU1024\u003e; pub type N1024 = NInt\u003cU1024\u003e;\n    pub type U2048 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2048 = PInt\u003cU2048\u003e; pub type N2048 = NInt\u003cU2048\u003e;\n    pub type U4096 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4096 = PInt\u003cU4096\u003e; pub type N4096 = NInt\u003cU4096\u003e;\n    pub type U8192 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P8192 = PInt\u003cU8192\u003e; pub type N8192 = NInt\u003cU8192\u003e;\n    pub type U16384 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P16384 = PInt\u003cU16384\u003e; pub type N16384 = NInt\u003cU16384\u003e;\n    pub type U32768 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P32768 = PInt\u003cU32768\u003e; pub type N32768 = NInt\u003cU32768\u003e;\n    pub type U65536 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P65536 = PInt\u003cU65536\u003e; pub type N65536 = NInt\u003cU65536\u003e;\n    pub type U131072 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P131072 = PInt\u003cU131072\u003e; pub type N131072 = NInt\u003cU131072\u003e;\n    pub type U262144 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P262144 = PInt\u003cU262144\u003e; pub type N262144 = NInt\u003cU262144\u003e;\n    pub type U524288 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P524288 = PInt\u003cU524288\u003e; pub type N524288 = NInt\u003cU524288\u003e;\n    pub type U1048576 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1048576 = PInt\u003cU1048576\u003e; pub type N1048576 = NInt\u003cU1048576\u003e;\n    pub type U2097152 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2097152 = PInt\u003cU2097152\u003e; pub type N2097152 = NInt\u003cU2097152\u003e;\n    pub type U4194304 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4194304 = PInt\u003cU4194304\u003e; pub type N4194304 = NInt\u003cU4194304\u003e;\n    pub type U8388608 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P8388608 = PInt\u003cU8388608\u003e; pub type N8388608 = NInt\u003cU8388608\u003e;\n    pub type U16777216 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P16777216 = PInt\u003cU16777216\u003e; pub type N16777216 = NInt\u003cU16777216\u003e;\n    pub type U33554432 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P33554432 = PInt\u003cU33554432\u003e; pub type N33554432 = NInt\u003cU33554432\u003e;\n    pub type U67108864 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P67108864 = PInt\u003cU67108864\u003e; pub type N67108864 = NInt\u003cU67108864\u003e;\n    pub type U134217728 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P134217728 = PInt\u003cU134217728\u003e; pub type N134217728 = NInt\u003cU134217728\u003e;\n    pub type U268435456 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P268435456 = PInt\u003cU268435456\u003e; pub type N268435456 = NInt\u003cU268435456\u003e;\n    pub type U536870912 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P536870912 = PInt\u003cU536870912\u003e; pub type N536870912 = NInt\u003cU536870912\u003e;\n    pub type U1073741824 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1073741824 = PInt\u003cU1073741824\u003e; pub type N1073741824 = NInt\u003cU1073741824\u003e;\n    pub type U2147483648 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2147483648 = PInt\u003cU2147483648\u003e; pub type N2147483648 = NInt\u003cU2147483648\u003e;\n    pub type U4294967296 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4294967296 = PInt\u003cU4294967296\u003e; pub type N4294967296 = NInt\u003cU4294967296\u003e;\n    pub type U8589934592 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P8589934592 = PInt\u003cU8589934592\u003e; pub type N8589934592 = NInt\u003cU8589934592\u003e;\n    pub type U17179869184 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P17179869184 = PInt\u003cU17179869184\u003e; pub type N17179869184 = NInt\u003cU17179869184\u003e;\n    pub type U34359738368 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P34359738368 = PInt\u003cU34359738368\u003e; pub type N34359738368 = NInt\u003cU34359738368\u003e;\n    pub type U68719476736 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P68719476736 = PInt\u003cU68719476736\u003e; pub type N68719476736 = NInt\u003cU68719476736\u003e;\n    pub type U137438953472 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P137438953472 = PInt\u003cU137438953472\u003e; pub type N137438953472 = NInt\u003cU137438953472\u003e;\n    pub type U274877906944 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P274877906944 = PInt\u003cU274877906944\u003e; pub type N274877906944 = NInt\u003cU274877906944\u003e;\n    pub type U549755813888 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P549755813888 = PInt\u003cU549755813888\u003e; pub type N549755813888 = NInt\u003cU549755813888\u003e;\n    pub type U1099511627776 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1099511627776 = PInt\u003cU1099511627776\u003e; pub type N1099511627776 = NInt\u003cU1099511627776\u003e;\n    pub type U2199023255552 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2199023255552 = PInt\u003cU2199023255552\u003e; pub type N2199023255552 = NInt\u003cU2199023255552\u003e;\n    pub type U4398046511104 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4398046511104 = PInt\u003cU4398046511104\u003e; pub type N4398046511104 = NInt\u003cU4398046511104\u003e;\n    pub type U8796093022208 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P8796093022208 = PInt\u003cU8796093022208\u003e; pub type N8796093022208 = NInt\u003cU8796093022208\u003e;\n    pub type U17592186044416 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P17592186044416 = PInt\u003cU17592186044416\u003e; pub type N17592186044416 = NInt\u003cU17592186044416\u003e;\n    pub type U35184372088832 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P35184372088832 = PInt\u003cU35184372088832\u003e; pub type N35184372088832 = NInt\u003cU35184372088832\u003e;\n    pub type U70368744177664 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P70368744177664 = PInt\u003cU70368744177664\u003e; pub type N70368744177664 = NInt\u003cU70368744177664\u003e;\n    pub type U140737488355328 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P140737488355328 = PInt\u003cU140737488355328\u003e; pub type N140737488355328 = NInt\u003cU140737488355328\u003e;\n    pub type U281474976710656 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P281474976710656 = PInt\u003cU281474976710656\u003e; pub type N281474976710656 = NInt\u003cU281474976710656\u003e;\n    pub type U562949953421312 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P562949953421312 = PInt\u003cU562949953421312\u003e; pub type N562949953421312 = NInt\u003cU562949953421312\u003e;\n    pub type U1125899906842624 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1125899906842624 = PInt\u003cU1125899906842624\u003e; pub type N1125899906842624 = NInt\u003cU1125899906842624\u003e;\n    pub type U2251799813685248 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2251799813685248 = PInt\u003cU2251799813685248\u003e; pub type N2251799813685248 = NInt\u003cU2251799813685248\u003e;\n    pub type U4503599627370496 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4503599627370496 = PInt\u003cU4503599627370496\u003e; pub type N4503599627370496 = NInt\u003cU4503599627370496\u003e;\n    pub type U9007199254740992 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P9007199254740992 = PInt\u003cU9007199254740992\u003e; pub type N9007199254740992 = NInt\u003cU9007199254740992\u003e;\n    pub type U18014398509481984 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P18014398509481984 = PInt\u003cU18014398509481984\u003e; pub type N18014398509481984 = NInt\u003cU18014398509481984\u003e;\n    pub type U36028797018963968 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P36028797018963968 = PInt\u003cU36028797018963968\u003e; pub type N36028797018963968 = NInt\u003cU36028797018963968\u003e;\n    pub type U72057594037927936 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P72057594037927936 = PInt\u003cU72057594037927936\u003e; pub type N72057594037927936 = NInt\u003cU72057594037927936\u003e;\n    pub type U144115188075855872 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P144115188075855872 = PInt\u003cU144115188075855872\u003e; pub type N144115188075855872 = NInt\u003cU144115188075855872\u003e;\n    pub type U288230376151711744 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P288230376151711744 = PInt\u003cU288230376151711744\u003e; pub type N288230376151711744 = NInt\u003cU288230376151711744\u003e;\n    pub type U576460752303423488 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P576460752303423488 = PInt\u003cU576460752303423488\u003e; pub type N576460752303423488 = NInt\u003cU576460752303423488\u003e;\n    pub type U1152921504606846976 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1152921504606846976 = PInt\u003cU1152921504606846976\u003e; pub type N1152921504606846976 = NInt\u003cU1152921504606846976\u003e;\n    pub type U2305843009213693952 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P2305843009213693952 = PInt\u003cU2305843009213693952\u003e; pub type N2305843009213693952 = NInt\u003cU2305843009213693952\u003e;\n    pub type U4611686018427387904 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P4611686018427387904 = PInt\u003cU4611686018427387904\u003e; pub type N4611686018427387904 = NInt\u003cU4611686018427387904\u003e;\n    pub type U9223372036854775808 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type U10000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P10000 = PInt\u003cU10000\u003e; pub type N10000 = NInt\u003cU10000\u003e;\n    pub type U100000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P100000 = PInt\u003cU100000\u003e; pub type N100000 = NInt\u003cU100000\u003e;\n    pub type U1000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000000 = PInt\u003cU1000000\u003e; pub type N1000000 = NInt\u003cU1000000\u003e;\n    pub type U10000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P10000000 = PInt\u003cU10000000\u003e; pub type N10000000 = NInt\u003cU10000000\u003e;\n    pub type U100000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P100000000 = PInt\u003cU100000000\u003e; pub type N100000000 = NInt\u003cU100000000\u003e;\n    pub type U1000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000000000 = PInt\u003cU1000000000\u003e; pub type N1000000000 = NInt\u003cU1000000000\u003e;\n    pub type U10000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P10000000000 = PInt\u003cU10000000000\u003e; pub type N10000000000 = NInt\u003cU10000000000\u003e;\n    pub type U100000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P100000000000 = PInt\u003cU100000000000\u003e; pub type N100000000000 = NInt\u003cU100000000000\u003e;\n    pub type U1000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000000000000 = PInt\u003cU1000000000000\u003e; pub type N1000000000000 = NInt\u003cU1000000000000\u003e;\n    pub type U10000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P10000000000000 = PInt\u003cU10000000000000\u003e; pub type N10000000000000 = NInt\u003cU10000000000000\u003e;\n    pub type U100000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P100000000000000 = PInt\u003cU100000000000000\u003e; pub type N100000000000000 = NInt\u003cU100000000000000\u003e;\n    pub type U1000000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000000000000000 = PInt\u003cU1000000000000000\u003e; pub type N1000000000000000 = NInt\u003cU1000000000000000\u003e;\n    pub type U10000000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P10000000000000000 = PInt\u003cU10000000000000000\u003e; pub type N10000000000000000 = NInt\u003cU10000000000000000\u003e;\n    pub type U100000000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P100000000000000000 = PInt\u003cU100000000000000000\u003e; pub type N100000000000000000 = NInt\u003cU100000000000000000\u003e;\n    pub type U1000000000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n    pub type P1000000000000000000 = PInt\u003cU1000000000000000000\u003e; pub type N1000000000000000000 = NInt\u003cU1000000000000000000\u003e;\n    pub type U10000000000000000000 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","tests","target","debug","build","typenum-116a99f005dfe29f","out","op.rs"],"content":"\n/**\nConvenient type operations.\n\nAny types representing values must be able to be expressed as `ident`s. That means they need to be\nin scope.\n\nFor example, `P5` is okay, but `typenum::P5` is not.\n\nYou may combine operators arbitrarily, although doing so excessively may require raising the\nrecursion limit.\n\n# Example\n```rust\n#![recursion_limit=\"128\"]\n#[macro_use] extern crate typenum;\nuse typenum::consts::*;\n\nfn main() {\n    assert_type!(\n        op!(min((P1 - P2) * (N3 + N7), P5 * (P3 + P4)) == P10)\n    );\n}\n```\nOperators are evaluated based on the operator precedence outlined\n[here](https://doc.rust-lang.org/reference.html#operator-precedence).\n\nThe full list of supported operators and functions is as follows:\n\n`*`, `/`, `%`, `+`, `-`, `\u003c\u003c`, `\u003e\u003e`, `\u0026`, `^`, `|`, `==`, `!=`, `\u003c=`, `\u003e=`, `\u003c`, `\u003e`, `cmp`, `sqr`, `sqrt`, `abs`, `cube`, `pow`, `min`, `max`, `log2`, `gcd`\n\nThey all expand to type aliases defined in the `operator_aliases` module. Here is an expanded list,\nincluding examples:\n\n---\nOperator `*`. Expands to `Prod`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P2 * P3), P6);\n# }\n```\n\n---\nOperator `/`. Expands to `Quot`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P6 / P2), P3);\n# }\n```\n\n---\nOperator `%`. Expands to `Mod`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P5 % P3), P2);\n# }\n```\n\n---\nOperator `+`. Expands to `Sum`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P2 + P3), P5);\n# }\n```\n\n---\nOperator `-`. Expands to `Diff`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P2 - P3), N1);\n# }\n```\n\n---\nOperator `\u003c\u003c`. Expands to `Shleft`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(U1 \u003c\u003c U5), U32);\n# }\n```\n\n---\nOperator `\u003e\u003e`. Expands to `Shright`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(U32 \u003e\u003e U5), U1);\n# }\n```\n\n---\nOperator `\u0026`. Expands to `And`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(U5 \u0026 U3), U1);\n# }\n```\n\n---\nOperator `^`. Expands to `Xor`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(U5 ^ U3), U6);\n# }\n```\n\n---\nOperator `|`. Expands to `Or`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(U5 | U3), U7);\n# }\n```\n\n---\nOperator `==`. Expands to `Eq`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P5 == P3 + P2), True);\n# }\n```\n\n---\nOperator `!=`. Expands to `NotEq`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P5 != P3 + P2), False);\n# }\n```\n\n---\nOperator `\u003c=`. Expands to `LeEq`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P6 \u003c= P3 + P2), False);\n# }\n```\n\n---\nOperator `\u003e=`. Expands to `GrEq`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P6 \u003e= P3 + P2), True);\n# }\n```\n\n---\nOperator `\u003c`. Expands to `Le`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P4 \u003c P3 + P2), True);\n# }\n```\n\n---\nOperator `\u003e`. Expands to `Gr`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(P5 \u003c P3 + P2), False);\n# }\n```\n\n---\nOperator `cmp`. Expands to `Compare`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(cmp(P2, P3)), Less);\n# }\n```\n\n---\nOperator `sqr`. Expands to `Square`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(sqr(P2)), P4);\n# }\n```\n\n---\nOperator `sqrt`. Expands to `Sqrt`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(sqrt(U9)), U3);\n# }\n```\n\n---\nOperator `abs`. Expands to `AbsVal`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(abs(N2)), P2);\n# }\n```\n\n---\nOperator `cube`. Expands to `Cube`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(cube(P2)), P8);\n# }\n```\n\n---\nOperator `pow`. Expands to `Exp`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(pow(P2, P3)), P8);\n# }\n```\n\n---\nOperator `min`. Expands to `Minimum`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(min(P2, P3)), P2);\n# }\n```\n\n---\nOperator `max`. Expands to `Maximum`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(max(P2, P3)), P3);\n# }\n```\n\n---\nOperator `log2`. Expands to `Log2`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(log2(U9)), U3);\n# }\n```\n\n---\nOperator `gcd`. Expands to `Gcf`.\n\n```rust\n# #[macro_use] extern crate typenum;\n# use typenum::*;\n# fn main() {\nassert_type_eq!(op!(gcd(U9, U21)), U3);\n# }\n```\n\n*/\n#[macro_export(local_inner_macros)]\nmacro_rules! op {\n    ($($tail:tt)*) =\u003e ( __op_internal__!($($tail)*) );\n}\n\n    #[doc(hidden)]\n    #[macro_export(local_inner_macros)]\n    macro_rules! __op_internal__ {\n\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: cmp $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Compare, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: sqr $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Square, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: sqrt $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Sqrt, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: abs $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[AbsVal, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: cube $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Cube, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: pow $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Exp, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: min $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Minimum, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: max $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Maximum, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: log2 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Log2, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: gcd $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Gcf, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[LParen, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: , $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[LParen, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$stack_top:ident, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: , $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[$stack_top, $($queue,)*] @tail: , $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: * $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: * $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: * $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: * $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Prod, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: / $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: / $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: / $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: / $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Quot, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: % $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: % $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: % $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: % $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Mod, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: + $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: + $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: + $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: + $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: + $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: + $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Sum, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: - $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: - $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: - $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: - $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: - $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: - $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Diff, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003c\u003c $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c\u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Shleft, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003e\u003e $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e\u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Shright, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: \u0026 $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u0026 $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[And, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: ^ $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ^ $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Xor, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: | $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: | $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Or, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: == $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: == $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Eq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: != $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: != $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[NotEq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: \u003c= $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[LeEq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: \u003e= $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e= $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[GrEq, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: \u003c $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003c $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Le, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[Prod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Prod, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Quot, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Quot, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Mod, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Mod, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Sum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sum, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Diff, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Diff, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Shleft, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shleft, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Shright, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Shright, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[And, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[And, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Xor, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Xor, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Or, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Or, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Eq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Eq, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[NotEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[NotEq, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[LeEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[LeEq, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[GrEq, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[GrEq, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Le, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Le, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[Gr, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gr, $($queue,)*] @tail: \u003e $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: \u003e $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[Gr, $($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: ( $($stuff:tt)* ) $($tail:tt)* )\n =\u003e (\n    __op_internal__!(@stack[LParen, $($stack,)*] @queue[$($queue,)*]\n                     @tail: $($stuff)* RParen $($tail)*)\n);\n(@stack[LParen, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: RParen $($tail:tt)*) =\u003e (\n    __op_internal__!(@rp3 @stack[$($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$stack_top:ident, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: RParen $($tail:tt)*)\n =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[$stack_top, $($queue,)*] @tail: RParen $($tail)*)\n);\n(@rp3 @stack[Compare, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Compare, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Square, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Square, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Sqrt, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Sqrt, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[AbsVal, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[AbsVal, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Cube, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Cube, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Exp, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Exp, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Minimum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Minimum, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Maximum, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Maximum, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Log2, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Log2, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[Gcf, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[Gcf, $($queue,)*] @tail: $($tail)*)\n);\n(@rp3 @stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[$($queue,)*] @tail: $($tail)*)\n);\n(@stack[$($stack:ident,)*] @queue[$($queue:ident,)*] @tail: $num:ident $($tail:tt)*) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[$num, $($queue,)*] @tail: $($tail)*)\n);\n(@stack[] @queue[$($queue:ident,)*] @tail: ) =\u003e (\n    __op_internal__!(@reverse[] @input: $($queue,)*)\n);\n(@stack[$stack_top:ident, $($stack:ident,)*] @queue[$($queue:ident,)*] @tail:) =\u003e (\n    __op_internal__!(@stack[$($stack,)*] @queue[$stack_top, $($queue,)*] @tail: )\n);\n(@reverse[$($revved:ident,)*] @input: $head:ident, $($tail:ident,)* ) =\u003e (\n    __op_internal__!(@reverse[$head, $($revved,)*] @input: $($tail,)*)\n);\n(@reverse[$($revved:ident,)*] @input: ) =\u003e (\n    __op_internal__!(@eval @stack[] @input[$($revved,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Prod, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Prod\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Quot, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Quot\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Mod, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Mod\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Sum, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Sum\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Diff, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Diff\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Shleft, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Shleft\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Shright, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Shright\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[And, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::And\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Xor, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Xor\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Or, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Or\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Eq, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Eq\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[NotEq, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::NotEq\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[LeEq, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::LeEq\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[GrEq, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::GrEq\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Le, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Le\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Gr, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Gr\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Compare, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Compare\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Exp, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Exp\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Minimum, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Minimum\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Maximum, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Maximum\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $b:ty, $($stack:ty,)*] @input[Gcf, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Gcf\u003c$b, $a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $($stack:ty,)*] @input[Square, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Square\u003c$a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $($stack:ty,)*] @input[Sqrt, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Sqrt\u003c$a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $($stack:ty,)*] @input[AbsVal, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::AbsVal\u003c$a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $($stack:ty,)*] @input[Cube, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Cube\u003c$a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$a:ty, $($stack:ty,)*] @input[Log2, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$crate::Log2\u003c$a\u003e, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$($stack:ty,)*] @input[$head:ident, $($tail:ident,)*]) =\u003e (\n    __op_internal__!(@eval @stack[$head, $($stack,)*] @input[$($tail,)*])\n);\n(@eval @stack[$stack:ty,] @input[]) =\u003e (\n    $stack\n);\n($($tail:tt)* ) =\u003e (\n    __op_internal__!(@stack[] @queue[] @tail: $($tail)*)\n);\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","tests","target","debug","build","typenum-116a99f005dfe29f","out","tests.rs"],"content":"\nextern crate typenum;\n\nuse std::ops::*;\nuse std::cmp::Ordering;\nuse typenum::*;\n\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Sub_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0SubU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_0() {\n    type A = UTerm;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_0() {\n    type A = UTerm;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU0 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_1() {\n    type A = UTerm;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_2() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_3() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_4() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitAnd_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitAndU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitOr_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_BitXor_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0BitXorU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shl_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShlU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Shr_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Add_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0AddU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Min_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MinU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Max_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Gcd_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0GcdU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Mul_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0MulU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Div_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Rem_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0RemU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_PartialDiv_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PartialDivU5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PartialDivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Pow_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U0PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU0PowU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_0_Cmp_5() {\n    type A = UTerm;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U0CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU0CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1SubU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_0() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Sub_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1SubU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_PartialDiv_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_1() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_2() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU3 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_3() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_4() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitAnd_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitAndU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitOr_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_BitXor_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1BitXorU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shl_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShlU5 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Shr_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Add_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1AddU5 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Min_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MinU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Max_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Gcd_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Mul_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1MulU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Div_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U1DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Rem_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1RemU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Pow_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU1PowU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_1_Cmp_5() {\n    type A = UInt\u003cUTerm, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U1CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU1CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU0 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU2 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Sub_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2SubU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_PartialDiv_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU3 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU3 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU4 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU4 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU4 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU4 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitAndU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitOrU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2BitXorU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shl_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShlU5 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Shr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Add_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2AddU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Min_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MinU5 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Max_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Mul_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2MulU5 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Div_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U2DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Rem_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2RemU5 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Pow_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU2PowU5 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_2_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U2CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU2CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU0 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU1 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU2 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU2 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU2 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U24 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU24\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU3 as Unsigned\u003e::to_u64(), \u003cU24 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Sub_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3SubU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU3 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_PartialDiv_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PartialDivU3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PartialDivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U27 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU27\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU3 as Unsigned\u003e::to_u64(), \u003cU27 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U48 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU48\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU4 as Unsigned\u003e::to_u64(), \u003cU48 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU4 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU4 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU4 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU4 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U81 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU81\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU4 as Unsigned\u003e::to_u64(), \u003cU81 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitAndU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitOrU5 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3BitXorU5 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shl_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U96 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU96\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShlU5 as Unsigned\u003e::to_u64(), \u003cU96 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Shr_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Add_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3AddU5 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Min_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MinU5 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Max_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Mul_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U15 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU15\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3MulU5 as Unsigned\u003e::to_u64(), \u003cU15 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Div_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U3DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Rem_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3RemU5 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Pow_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U243 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU243\u003e\u003e::Output;\n\n    assert_eq!(\u003cU3PowU5 as Unsigned\u003e::to_u64(), \u003cU243 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_3_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U3CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU3CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU0 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU1 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU1 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU2 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU2 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU2 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU2 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU2 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U32 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU32\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU3 as Unsigned\u003e::to_u64(), \u003cU32 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU3 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U12 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU12\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU3 as Unsigned\u003e::to_u64(), \u003cU12 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU3 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U64 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU64\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU4 as Unsigned\u003e::to_u64(), \u003cU64 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU4 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Sub_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4SubU4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4SubU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U16 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU16\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU4 as Unsigned\u003e::to_u64(), \u003cU16 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_PartialDiv_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PartialDivU4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PartialDivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U256 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU256\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU4 as Unsigned\u003e::to_u64(), \u003cU256 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitAndU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4BitXorU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shl_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U128 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU128\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShlU5 as Unsigned\u003e::to_u64(), \u003cU128 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Shr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Add_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4AddU5 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Min_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MinU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Max_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4GcdU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Mul_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4MulU5 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Div_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U4DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4DivU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Rem_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4RemU5 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Pow_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1024 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cU4PowU5 as Unsigned\u003e::to_u64(), \u003cU1024 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_4_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U4CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU4CmpU5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU0 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU0 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU0 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU0 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU0 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU0 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU0 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU0 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_0() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU1 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU1 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU1 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU1 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU1 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU1 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU1 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU1 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU1 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU1 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU1 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PartialDivU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU1 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_1() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU2 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU2 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU2 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU2 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU2 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU2 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU2 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU2 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU2 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU2 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU2 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU2 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU2 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n    type U25 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU25\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU2 as Unsigned\u003e::to_u64(), \u003cU25 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_2() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU3 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U7 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU3 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU7\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU3 as Unsigned\u003e::to_u64(), \u003cU7 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U6 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU3 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU6\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU3 as Unsigned\u003e::to_u64(), \u003cU6 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U40 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU3 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU40\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU3 as Unsigned\u003e::to_u64(), \u003cU40 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU3 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU3 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U8 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU8\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU3 as Unsigned\u003e::to_u64(), \u003cU8 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U3 = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU3\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU3 as Unsigned\u003e::to_u64(), \u003cU3 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU3 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U15 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU15\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU3 as Unsigned\u003e::to_u64(), \u003cU15 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU3 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U2 = UInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU2\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU3 as Unsigned\u003e::to_u64(), \u003cU2 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n    type U125 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU125\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU3 as Unsigned\u003e::to_u64(), \u003cU125 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_3() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU4 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU4 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU4 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U80 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU4 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU80\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU4 as Unsigned\u003e::to_u64(), \u003cU80 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU4 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU4 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U9 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU9\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU4 as Unsigned\u003e::to_u64(), \u003cU9 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U4 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU4\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU4 as Unsigned\u003e::to_u64(), \u003cU4 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU4 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U20 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU20\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU4 as Unsigned\u003e::to_u64(), \u003cU20 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU4 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n    type U625 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU625\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU4 as Unsigned\u003e::to_u64(), \u003cU625 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_4() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitAnd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitAndU5 = \u003c\u003cA as BitAnd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitAndU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitOr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5BitOrU5 = \u003c\u003cA as BitOr\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitOrU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_BitXor_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5BitXorU5 = \u003c\u003cA as BitXor\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5BitXorU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shl_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U160 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5ShlU5 = \u003c\u003cA as Shl\u003cB\u003e\u003e::Output as Same\u003cU160\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShlU5 as Unsigned\u003e::to_u64(), \u003cU160 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Shr_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5ShrU5 = \u003c\u003cA as Shr\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5ShrU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Add_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U10 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5AddU5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cU10\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5AddU5 as Unsigned\u003e::to_u64(), \u003cU10 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Min_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MinU5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MinU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Max_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MaxU5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MaxU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Gcd_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U5 = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5GcdU5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cU5\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5GcdU5 as Unsigned\u003e::to_u64(), \u003cU5 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Sub_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5SubU5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5SubU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Mul_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U25 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5MulU5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cU25\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5MulU5 as Unsigned\u003e::to_u64(), \u003cU25 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Div_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5DivU5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5DivU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Rem_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U0 = UTerm;\n\n    #[allow(non_camel_case_types)]\n    type U5RemU5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cU0\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5RemU5 as Unsigned\u003e::to_u64(), \u003cU0 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_PartialDiv_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U1 = UInt\u003cUTerm, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PartialDivU5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cU1\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PartialDivU5 as Unsigned\u003e::to_u64(), \u003cU1 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Pow_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type U3125 = UInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5PowU5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cU3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cU5PowU5 as Unsigned\u003e::to_u64(), \u003cU3125 as Unsigned\u003e::to_u64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_5_Cmp_5() {\n    type A = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n    type B = UInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e;\n\n    #[allow(non_camel_case_types)]\n    type U5CmpU5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cU5CmpU5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN5 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN4 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN4 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN3 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN2 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN2 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddN1 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Add_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Sub_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Min_0 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Gcd_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP1 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP2 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP2 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP2 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP3 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N125 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN125\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP3 as Integer\u003e::to_i64(), \u003cN125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP4 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP4 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P625 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP625\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP4 as Integer\u003e::to_i64(), \u003cP625 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5AddP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5SubP5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N25 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN25\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MulP5 as Integer\u003e::to_i64(), \u003cN25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MinP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5DivP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N5RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_PartialDiv_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PartialDivP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3125 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cN5PowP5 as Integer\u003e::to_i64(), \u003cN3125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N5CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN5CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN5 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN5 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN3 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN3 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN2 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Add_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Sub_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Min_0 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Gcd_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP2 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP2 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP3 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP3 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N64 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN64\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP3 as Integer\u003e::to_i64(), \u003cN64 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N16 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP4 as Integer\u003e::to_i64(), \u003cN16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_PartialDiv_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PartialDivP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P256 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP256\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP4 as Integer\u003e::to_i64(), \u003cP256 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4AddP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4SubP5 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MulP5 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MinP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N4DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4RemP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1024 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cN4PowP5 as Integer\u003e::to_i64(), \u003cN1024 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N4CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN4CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN5 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN5 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN4 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN4 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN3 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Add_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Sub_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Min_0 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Gcd_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP2 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP2 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP3 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_PartialDiv_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PartialDivP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N27 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN27\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP3 as Integer\u003e::to_i64(), \u003cN27 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP4 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP4 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P81 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP81\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP4 as Integer\u003e::to_i64(), \u003cP81 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3AddP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3SubP5 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MulP5 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MinP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N3DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3RemP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N243 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN243\u003e\u003e::Output;\n\n    assert_eq!(\u003cN3PowP5 as Integer\u003e::to_i64(), \u003cN243 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N3CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN3CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN5 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN4 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpN1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Add_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Sub_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Min_0 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Gcd_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_PartialDiv_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PartialDivP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP3 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP3 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP4 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Add_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2AddP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N7 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN7\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2SubP5 as Integer\u003e::to_i64(), \u003cN7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MulP5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Min_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MinP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Max_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Div_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N2DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2RemP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N32 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN32\u003e\u003e::Output;\n\n    assert_eq!(\u003cN2PowP5 as Integer\u003e::to_i64(), \u003cN32 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N2CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN2CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN5 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PartialDivN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowN1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_N1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpN1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Add_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Sub_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Min_0 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Gcd_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp__0() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1Cmp_0 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_PartialDiv_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PartialDivP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P1() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP2 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P2() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP3 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P3() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP4 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P4() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Add_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1AddP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Sub_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1SubP5 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Mul_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MulP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Min_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MinP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Max_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Gcd_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Div_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type N1DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Rem_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1RemP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Pow_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cN1PowP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Cmp_P5() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type N1CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cN1CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N5() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N4() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N3() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N2() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_N1() {\n    type A = Z0;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Add_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Sub_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Max_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd__0() {\n    type A = Z0;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Gcd_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow__0() {\n    type A = Z0;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp__0() {\n    type A = Z0;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0Cmp_0 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P1() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP1 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P2() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P3() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P4() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Add_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0AddP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Sub_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0SubP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Mul_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MulP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Min_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MinP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Max_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Gcd_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Div_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Rem_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_PartialDiv_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PartialDivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Pow_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type _0PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003c_0PowP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Cmp_P5() {\n    type A = Z0;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type _0CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003c_0CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN5 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PartialDivN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowN1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Add_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Sub_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Max_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Gcd_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PartialDivP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP1 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP2 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP3 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP4 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Add_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1AddP5 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1SubP5 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MulP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Min_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MinP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Max_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Div_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P1DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1RemP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP1PowP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P1CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP1CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN5 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN5 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN4 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN4 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN3 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN2 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivN1 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Add_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Sub_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Max_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Gcd_0 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_PartialDiv_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PartialDivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP2 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP3 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP4 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP4 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP4 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2AddP5 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2SubP5 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MulP5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MinP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P2DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2RemP5 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P32 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP32\u003e\u003e::Output;\n\n    assert_eq!(\u003cP2PowP5 as Integer\u003e::to_i64(), \u003cP32 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P2CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP2CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN5 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN5 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN4 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN4 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N9 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN3 as Integer\u003e::to_i64(), \u003cN9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N6 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN2 as Integer\u003e::to_i64(), \u003cN6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN2 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddN1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivN1 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Add_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Sub_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Max_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Gcd_0 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP1 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP2 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP3 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP3 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP3 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_PartialDiv_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PartialDivP3 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PartialDivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P27 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP27\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP3 as Integer\u003e::to_i64(), \u003cP27 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP3 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP4 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP4 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP4 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P81 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP81\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP4 as Integer\u003e::to_i64(), \u003cP81 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP4 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3AddP5 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3SubP5 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MulP5 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MinP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P3DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3RemP5 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P243 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP243\u003e\u003e::Output;\n\n    assert_eq!(\u003cP3PowP5 as Integer\u003e::to_i64(), \u003cP243 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P3CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP3CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN5 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN5 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N16 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN4 as Integer\u003e::to_i64(), \u003cN16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN3 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N12 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN3 as Integer\u003e::to_i64(), \u003cN12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N8 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN2 as Integer\u003e::to_i64(), \u003cN8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddN1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivN1 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Add_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Sub_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Max_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Gcd_0 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP1 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP2 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP2 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP2 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP2 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP2 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP2 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP3 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P12 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP12\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP3 as Integer\u003e::to_i64(), \u003cP12 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP3 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P64 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP64\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP3 as Integer\u003e::to_i64(), \u003cP64 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP4 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P16 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP16\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP4 as Integer\u003e::to_i64(), \u003cP16 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP4 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_PartialDiv_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PartialDivP4 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PartialDivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P256 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP256\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP4 as Integer\u003e::to_i64(), \u003cP256 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP4 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4AddP5 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4SubP5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MulP5 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MinP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4GcdP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P4DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4DivP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4RemP5 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1024 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1024\u003e\u003e::Output;\n\n    assert_eq!(\u003cP4PowP5 as Integer\u003e::to_i64(), \u003cP1024 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P4CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP4CmpP5 as Ord\u003e::to_ordering(), Ordering::Less);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N25 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN5 as Integer\u003e::to_i64(), \u003cN25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivN5 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN5 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN4 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N20 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN4 as Integer\u003e::to_i64(), \u003cN20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN4 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N15 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN3 as Integer\u003e::to_i64(), \u003cN15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN3 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN2 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N10 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN2 as Integer\u003e::to_i64(), \u003cN10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddN1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddN1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubN1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubN1 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulN1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinN1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinN1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxN1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxN1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdN1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivN1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemN1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemN1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivN1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivN1 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_N1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpN1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpN1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Add_0 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Add_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Sub_0 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Sub_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Mul_0 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Mul_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Min_0 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Min_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Max_0 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Max_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Gcd_0 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Gcd_0 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5Pow_0 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5Pow_0 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp__0() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5Cmp_0 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5Cmp_0 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P6 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP1 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP6\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP1 as Integer\u003e::to_i64(), \u003cP6 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP1 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP1 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP1 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP1 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP1 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP1 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP1 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP1 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP1 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP1 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP1 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP1 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P1() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP1 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP1 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P7 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP2 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP7\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP2 as Integer\u003e::to_i64(), \u003cP7 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP2 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP2 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP2 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP2 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP2 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP2 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP2 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP2 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP2 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP2 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP2 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP2 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP2 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P2() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP2 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP2 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P8 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP3 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP8\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP3 as Integer\u003e::to_i64(), \u003cP8 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP3 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P15 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP3 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP15\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP3 as Integer\u003e::to_i64(), \u003cP15 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP3 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP3 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP3 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP3 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP3 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP3 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP3 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP3 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P125 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP3 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP125\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP3 as Integer\u003e::to_i64(), \u003cP125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P3() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP3 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP3 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P9 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP4 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP9\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP4 as Integer\u003e::to_i64(), \u003cP9 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP4 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P20 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP4 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP20\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP4 as Integer\u003e::to_i64(), \u003cP20 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP4 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP4 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP4 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP4 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP4 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP4 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP4 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P625 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP4 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP625\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP4 as Integer\u003e::to_i64(), \u003cP625 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P4() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP4 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP4 as Ord\u003e::to_ordering(), Ordering::Greater);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Add_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P10 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5AddP5 = \u003c\u003cA as Add\u003cB\u003e\u003e::Output as Same\u003cP10\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5AddP5 as Integer\u003e::to_i64(), \u003cP10 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Sub_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5SubP5 = \u003c\u003cA as Sub\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5SubP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Mul_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P25 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MulP5 = \u003c\u003cA as Mul\u003cB\u003e\u003e::Output as Same\u003cP25\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MulP5 as Integer\u003e::to_i64(), \u003cP25 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Min_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MinP5 = \u003c\u003cA as Min\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MinP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Max_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5MaxP5 = \u003c\u003cA as Max\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5MaxP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Gcd_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5GcdP5 = \u003c\u003cA as Gcd\u003cB\u003e\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5GcdP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Div_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5DivP5 = \u003c\u003cA as Div\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5DivP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Rem_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type P5RemP5 = \u003c\u003cA as Rem\u003cB\u003e\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5RemP5 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_PartialDiv_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PartialDivP5 = \u003c\u003cA as PartialDiv\u003cB\u003e\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PartialDivP5 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Pow_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P3125 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e, B0\u003e, B0\u003e, B0\u003e, B0\u003e, B1\u003e, B1\u003e, B0\u003e, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5PowP5 = \u003c\u003cA as Pow\u003cB\u003e\u003e::Output as Same\u003cP3125\u003e\u003e::Output;\n\n    assert_eq!(\u003cP5PowP5 as Integer\u003e::to_i64(), \u003cP3125 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Cmp_P5() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type B = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type P5CmpP5 = \u003cA as Cmp\u003cB\u003e\u003e::Output;\n    assert_eq!(\u003cP5CmpP5 as Ord\u003e::to_ordering(), Ordering::Equal);\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN5 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cNegN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N5_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN5 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN4 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cNegN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N4_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN4 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN3 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cNegN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N3_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN3 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Neg() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN2 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cNegN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N2_Abs() {\n    type A = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN2 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Neg() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegN1 = \u003c\u003cA as Neg\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cNegN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_N1_Abs() {\n    type A = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsN1 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cAbsN1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Neg() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Neg_0 = \u003c\u003cA as Neg\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n    assert_eq!(\u003cNeg_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test__0_Abs() {\n    type A = Z0;\n    type _0 = Z0;\n\n    #[allow(non_camel_case_types)]\n    type Abs_0 = \u003c\u003cA as Abs\u003e::Output as Same\u003c_0\u003e\u003e::Output;\n    assert_eq!(\u003cAbs_0 as Integer\u003e::to_i64(), \u003c_0 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Neg() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type N1 = NInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP1 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN1\u003e\u003e::Output;\n    assert_eq!(\u003cNegP1 as Integer\u003e::to_i64(), \u003cN1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P1_Abs() {\n    type A = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n    type P1 = PInt\u003cUInt\u003cUTerm, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP1 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP1\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP1 as Integer\u003e::to_i64(), \u003cP1 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type N2 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP2 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN2\u003e\u003e::Output;\n    assert_eq!(\u003cNegP2 as Integer\u003e::to_i64(), \u003cN2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P2_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n    type P2 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP2 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP2\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP2 as Integer\u003e::to_i64(), \u003cP2 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type N3 = NInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP3 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN3\u003e\u003e::Output;\n    assert_eq!(\u003cNegP3 as Integer\u003e::to_i64(), \u003cN3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P3_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n    type P3 = PInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP3 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP3\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP3 as Integer\u003e::to_i64(), \u003cP3 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type N4 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP4 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN4\u003e\u003e::Output;\n    assert_eq!(\u003cNegP4 as Integer\u003e::to_i64(), \u003cN4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P4_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n    type P4 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B0\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP4 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP4\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP4 as Integer\u003e::to_i64(), \u003cP4 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Neg() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type N5 = NInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type NegP5 = \u003c\u003cA as Neg\u003e::Output as Same\u003cN5\u003e\u003e::Output;\n    assert_eq!(\u003cNegP5 as Integer\u003e::to_i64(), \u003cN5 as Integer\u003e::to_i64());\n}\n#[test]\n#[allow(non_snake_case)]\nfn test_P5_Abs() {\n    type A = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n    type P5 = PInt\u003cUInt\u003cUInt\u003cUInt\u003cUTerm, B1\u003e, B0\u003e, B1\u003e\u003e;\n\n    #[allow(non_camel_case_types)]\n    type AbsP5 = \u003c\u003cA as Abs\u003e::Output as Same\u003cP5\u003e\u003e::Output;\n    assert_eq!(\u003cAbsP5 as Integer\u003e::to_i64(), \u003cP5 as Integer\u003e::to_i64());\n}","traces":[],"covered":0,"coverable":0},{"path":["/","home","kvothe","repos","24C1-Rustic-City-Eye","rustic_city_eye","tests","target","debug","build","x11-dl-f5f6482e282050f2","out","config.rs"],"content":"pub mod config { pub mod libdir {\npub const xext: Option\u003c\u0026'static str\u003e = Some(\"/usr/lib/x86_64-linux-gnu\");\npub const gl: Option\u003c\u0026'static str\u003e = Some(\"/usr/lib/x86_64-linux-gnu\");\npub const xcursor: Option\u003c\u0026'static str\u003e = Some(\"/usr/lib/x86_64-linux-gnu\");\npub const xxf86vm: Option\u003c\u0026'static str\u003e = None;\npub const xft: Option\u003c\u0026'static str\u003e = Some(\"/usr/lib/x86_64-linux-gnu\");\npub const xinerama: Option\u003c\u0026'static str\u003e = Some(\"/usr/lib/x86_64-linux-gnu\");\npub const xi: Option\u003c\u0026'static str\u003e = Some(\"/usr/lib/x86_64-linux-gnu\");\npub const x11: Option\u003c\u0026'static str\u003e = Some(\"/usr/lib/x86_64-linux-gnu\");\npub const xlib_xcb: Option\u003c\u0026'static str\u003e = None;\npub const xmu: Option\u003c\u0026'static str\u003e = None;\npub const xrandr: Option\u003c\u0026'static str\u003e = Some(\"/usr/lib/x86_64-linux-gnu\");\npub const xtst: Option\u003c\u0026'static str\u003e = Some(\"/usr/lib/x86_64-linux-gnu\");\npub const xrender: Option\u003c\u0026'static str\u003e = Some(\"/usr/lib/x86_64-linux-gnu\");\npub const xpresent: Option\u003c\u0026'static str\u003e = None;\npub const xscrnsaver: Option\u003c\u0026'static str\u003e = None;\npub const xt: Option\u003c\u0026'static str\u003e = None;\n}\n}","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>